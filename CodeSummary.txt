Directory structure:
└── mushitaro-openwam/
    ├── CMakeLists.txt
    └── Source/
        ├── CMakeLists.txt
        ├── OpenWAM.cpp
        ├── OpenWAM.rc
        ├── TCGestorWAM.cpp
        ├── TCGestorWAM.h
        ├── TOpenWAM.h
        ├── TTimeControl.cpp
        ├── TTimeControl.h
        ├── Version.h
        ├── version.ver
        ├── 1DPipes/
        │   ├── CMakeLists.txt
        │   └── TTubo.h
        ├── Act/
        │   ├── act_def.h
        │   ├── ACT_Sub_DLL.h
        │   ├── CMakeLists.txt
        │   └── INJECTION_RATE.cpp
        ├── Boundaries/
        │   ├── BoundaryFunctions.cpp
        │   ├── BoundaryFunctions.h
        │   ├── CMakeLists.txt
        │   ├── TCCCilindro.cpp
        │   ├── TCCCilindro.h
        │   ├── TCCCompresor.cpp
        │   ├── TCCCompresor.h
        │   ├── TCCCompresorVolumetrico.cpp
        │   ├── TCCCompresorVolumetrico.h
        │   ├── TCCDeposito.cpp
        │   ├── TCCDeposito.h
        │   ├── TCCDescargaExtremoAbierto.cpp
        │   ├── TCCDescargaExtremoAbierto.h
        │   ├── TCCEntradaCompresor.cpp
        │   ├── TCCEntradaCompresor.h
        │   ├── TCCExternalConnection.cpp
        │   ├── TCCExternalConnection.h
        │   ├── TCCExternalConnectionVol.cpp
        │   ├── TCCExternalConnectionVol.h
        │   ├── TCCExtremoAnecoico.cpp
        │   ├── TCCExtremoAnecoico.h
        │   ├── TCCExtremoCerrado.cpp
        │   ├── TCCExtremoCerrado.h
        │   ├── TCCExtremoInyeccion.cpp
        │   ├── TCCExtremoInyeccion.h
        │   ├── TCCPerdidadePresion.cpp
        │   ├── TCCPerdidadePresion.h
        │   ├── TCCPreVble.cpp
        │   ├── TCCPreVble.h
        │   ├── TCCPulso.cpp
        │   ├── TCCPulso.h
        │   ├── TCCRamificacion.cpp
        │   ├── TCCRamificacion.h
        │   ├── TCCUnionEntreDepositos.cpp
        │   ├── TCCUnionEntreDepositos.h
        │   ├── TCCUnionEntreTubos.cpp
        │   ├── TCCUnionEntreTubos.h
        │   ├── TCFDConnection.cpp
        │   ├── TCFDConnection.h
        │   ├── TCondicionContorno.cpp
        │   ├── TCondicionContorno.h
        │   ├── TEntradaPulso.cpp
        │   └── TEntradaPulso.h
        ├── Concentric Pipe/
        │   ├── TConcentrico.h
        │   ├── TConcentricoDPF.h
        │   └── TConcentricoTubos.h
        ├── Connections/
        │   ├── CMakeLists.txt
        │   ├── TCDExterno.cpp
        │   ├── TCDExterno.h
        │   ├── TCDFijo.cpp
        │   ├── TCDFijo.h
        │   ├── TDiscoRotativo.cpp
        │   ├── TDiscoRotativo.h
        │   ├── TEstatorTurbina.cpp
        │   ├── TEstatorTurbina.h
        │   ├── TLamina.cpp
        │   ├── TLamina.h
        │   ├── TLumbrera.cpp
        │   ├── TLumbrera.h
        │   ├── TMariposa.cpp
        │   ├── TMariposa.h
        │   ├── TRotorTurbina.cpp
        │   ├── TRotorTurbina.h
        │   ├── TTipoValvula.cpp
        │   ├── TTipoValvula.h
        │   ├── TValvula4T.cpp
        │   ├── TValvula4T.h
        │   ├── TValvulaContr.cpp
        │   ├── TValvulaContr.h
        │   ├── TWasteGate.cpp
        │   └── TWasteGate.h
        ├── Control/
        │   ├── CMakeLists.txt
        │   ├── TController.cpp
        │   ├── TController.h
        │   ├── TDecisor.cpp
        │   ├── TDecisor.h
        │   ├── TGain.cpp
        │   ├── TGain.h
        │   ├── TPIDController.cpp
        │   ├── TPIDController.h
        │   ├── TSensor.cpp
        │   ├── TSensor.h
        │   ├── TTable.cpp
        │   ├── TTable.h
        │   ├── TTable1D.cpp
        │   └── TTable1D.h
        ├── DPF/
        │   ├── TCanalDPF.h
        │   └── TDPF.h
        ├── Engine/
        │   ├── CMakeLists.txt
        │   ├── TBloqueMotor.h
        │   ├── TCilindro.h
        │   ├── TCilindro2T.h
        │   ├── TCilindro4T.cpp
        │   └── TCilindro4T.h
        ├── Extern/
        │   ├── CMakeLists.txt
        │   ├── TAjusteTransCalorCil.cpp
        │   ├── TAjusteTransCalorCil.h
        │   ├── TCalculoExtern.h
        │   ├── TCoefDescarga.cpp
        │   ├── TCoefDescarga.h
        │   ├── TControlFuel.cpp
        │   ├── TControlFuel.h
        │   ├── TControlInyeccion.cpp
        │   ├── TControlInyeccion.h
        │   ├── TControlK.cpp
        │   ├── TControlK.h
        │   ├── TEGRV.cpp
        │   ├── TEGRV.h
        │   ├── Tfql.cpp
        │   ├── Tfql.h
        │   ├── TFraccionMasicaCilindro.cpp
        │   ├── TFraccionMasicaCilindro.h
        │   ├── TMatlab.cpp
        │   ├── TMatlab.h
        │   ├── TMuelle.cpp
        │   ├── TMuelle.h
        │   ├── TRegimenMotor.cpp
        │   ├── TRegimenMotor.h
        │   ├── TRemansoMatlab.cpp
        │   ├── TRemansoMatlab.h
        │   ├── TTGV.cpp
        │   └── TTGV.h
        ├── Includes/
        │   ├── Constantes.h
        │   ├── fluids.h
        │   ├── Labels.rc
        │   ├── NewCompSolver.h
        │   ├── SolverCompresor.h
        │   └── THTM_Fluids.h
        ├── Labels/
        │   ├── CMakeLists.txt
        │   ├── labels.cpp
        │   └── labels.hpp
        ├── Math_wam/
        │   ├── CMakeLists.txt
        │   ├── Math_wam.cpp
        │   └── Math_wam.h
        ├── ODModels/
        │   ├── CMakeLists.txt
        │   ├── TAcousticTurbine.cpp
        │   ├── TAcousticTurbine.h
        │   ├── TDeposito.cpp
        │   ├── TDeposito.h
        │   ├── TDepVolCte.cpp
        │   ├── TDepVolCte.h
        │   ├── TDepVolCteBase.cpp
        │   ├── TDepVolCteBase.h
        │   ├── TDepVolVariable.cpp
        │   ├── TDepVolVariable.h
        │   ├── TIsoSpeedLine.cpp
        │   ├── TIsoSpeedLine.h
        │   ├── TTurbina.cpp
        │   ├── TTurbina.h
        │   ├── TTurbinaSimple.cpp
        │   ├── TTurbinaSimple.h
        │   ├── TTurbinaTwin.cpp
        │   ├── TTurbinaTwin.h
        │   ├── TTurbineMap.cpp
        │   ├── TTurbineMap.h
        │   ├── TTurbPosition.cpp
        │   ├── TTurbPosition.h
        │   ├── TUnionDireccional.cpp
        │   ├── TUnionDireccional.h
        │   ├── TVenturi.cpp
        │   └── TVenturi.h
        ├── Output/
        │   ├── CMakeLists.txt
        │   └── TOutputResults.h
        ├── Turbocompressor/
        │   ├── CMakeLists.txt
        │   ├── TAcousticCompressor.cpp
        │   ├── TAcousticCompressor.h
        │   ├── TCompIsoReg.cpp
        │   ├── TCompIsoReg.h
        │   ├── TCompresor.cpp
        │   ├── TCompresor.h
        │   ├── TCompresorDep.cpp
        │   ├── TCompresorDep.h
        │   ├── TCompressorMap.cpp
        │   ├── TCompressorMap.h
        │   ├── TCompTubDep.cpp
        │   ├── TCompTubDep.h
        │   ├── TCompTubos.cpp
        │   ├── TCompTubos.h
        │   ├── TEffCorrector.cpp
        │   ├── TEffCorrector.h
        │   ├── TEjeTurbogrupo.cpp
        │   ├── TEjeTurbogrupo.h
        │   ├── TInterpMapaComp.cpp
        │   ├── TInterpMapaComp.h
        │   ├── TMapaComp.cpp
        │   ├── TMapaComp.h
        │   ├── TMapaComp2Tub.h
        │   ├── TNewMapComp.cpp
        │   ├── TNewMapComp.h
        │   ├── TSAEMap.cpp
        │   ├── TSAEMap.h
        │   ├── TTC_HTM.h
        │   └── turbo_bearings.hpp
        └── Wrappers/
            ├── CMakeLists.txt
            ├── Exception.cpp
            └── Exception.hpp


Files Content:

(Files content cropped to 300k characters, download full ingest to see more)
================================================
FILE: CMakeLists.txt
================================================
project (OpenWAM)
cmake_minimum_required(VERSION 2.8)
set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++11")
set(CMAKE_MODULE_PATH ${PROJECT_SOURCE_DIR}/cmake)
set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib)
set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib)
set(CMAKE_RUNTIME_OUTPUT_DIRECTORY_DEBUG ${CMAKE_BINARY_DIR}/bin/debug)
set(CMAKE_RUNTIME_OUTPUT_DIRECTORY_RELEASE ${CMAKE_BINARY_DIR}/bin/release)
option(BUILD_DOCUMENTATION "Use Doxygen to create the HTML and TEX based API documentation" OFF)
if(BUILD_DOCUMENTATION)
  FIND_PACKAGE(Doxygen)
  if (NOT DOXYGEN_FOUND)
    message(FATAL_ERROR 
      "Doxygen is needed to build the documentation. Please install it correctly")
  endif()
  #-- Configure the Template Doxyfile for our specific project
  configure_file(Doxyfile.in 
                 ${PROJECT_BINARY_DIR}/Doxyfile  @ONLY IMMEDIATE)
  #-- Add a custom target to run Doxygen when ever the project is built
  add_custom_target (doc ALL 
    COMMAND ${DOXYGEN_EXECUTABLE} ${PROJECT_BINARY_DIR}/Doxyfile
    SOURCES ${PROJECT_BINARY_DIR}/Doxyfile)
  add_custom_target (refman.pdf
    ${CMAKE_COMMAND}
    -E chdir ${PROJECT_BINARY_DIR}/doc/latex/ ${CMAKE_MAKE_PROGRAM}
    DEPENDS ${PROJECT_BINARY_DIR}/doc/latex/refman.tex)
  # IF you do NOT want the documentation to be generated EVERY time you build the project
  # then leave out the 'ALL' keyword from the above command.
endif()
option(BUILD_PARALLEL "Build using OpenMP for parallel simulations." OFF)
if(BUILD_PARALLEL)
    find_package(OpenMP)
    if (NOT OPENMP_FOUND)
        message(FATAL_ERROR 
        "OpenMP is needed to build a parallel OpenWAM.  Install it correctly.")
    endif()
    if(OPENMP_FOUND)
        set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} ${OpenMP_C_FLAGS}")
        set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} ${OpenMP_CXX_FLAGS}")
        set(CMAKE_EXE_LINKER_FLAGS
        "${CMAKE_EXE_LINKER_FLAGS} ${OpenMP_EXE_LINKER_FLAGS}")
        add_definitions(-DWITH_OPENMP)
    endif()
endif()
set(CMAKE_RC_COMPILE_OBJECT "<CMAKE_RC_COMPILER> -O coff ${CMAKE_RC_FLAGS} -i <SOURCE> -o <OBJECT>")
add_subdirectory(Source)



================================================
FILE: Source/CMakeLists.txt
================================================
include_directories(1DPipes)
include_directories(Act)
include_directories(Boundaries)
include_directories("Concentric Pipe")
include_directories(Connections)
include_directories(Control)
include_directories(DPF)
include_directories(Engine)
include_directories(Extern)
include_directories(Includes)
include_directories(Labels)
include_directories(Math_wam)
include_directories(ODModels)
include_directories(Output)
include_directories(Turbocompressor)
include_directories(Wrappers)
add_subdirectory(1DPipes)
add_subdirectory(Act)
add_subdirectory(Boundaries)
add_subdirectory(Connections)
add_subdirectory(Control)
add_subdirectory(Engine)
add_subdirectory(Extern)
add_subdirectory(Labels)
add_subdirectory(Math_wam)
add_subdirectory(ODModels)
add_subdirectory(Output)
add_subdirectory(Turbocompressor)
add_subdirectory(Wrappers)
add_executable(OpenWAM
  OpenWAM.cpp
  TOpenWAM.cpp
  TTimeControl.cpp
  OpenWAM.rc
)
target_link_libraries(
  OpenWAM
  1DPipes
  Act
  Boundaries
  Connections
  Control
  Engine
  Extern
  Labels
  Math_wam
  ODModels
  Output
  Turbocompressor
  Wrappers
)



================================================
FILE: Source/OpenWAM.cpp
================================================
/*--------------------------------------------------------------------------------*\
|==========================|
 |\\   /\ /\   // O pen     | OpenWAM: The Open Source 1D Gas-Dynamic Code
 | \\ |  X  | //  W ave     |
 |  \\ \/_\/ //   A ction   | CMT-Motores Termicos / Universidad Politecnica Valencia
 |   \\/   \//    M odel    |
 ----------------------------------------------------------------------------------
 | License
 |
 |	This file is part of OpenWAM.
 |
 |	OpenWAM is free software: you can redistribute it and/or modify
 |	it under the terms of the GNU General Public License as published by
 |	the Free Software Foundation, either version 3 of the License, or
 |	(at your option) any later version.
 |
 |	OpenWAM is distributed in the hope that it will be useful,
 |	but WITHOUT ANY WARRANTY; without even the implied warranty of
 |	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 |	GNU General Public License for more details.
 |
 |	You should have received a copy of the GNU General Public License
 |	along with OpenWAM.  If not, see <http://www.gnu.org/licenses/>.
 |
 \*--------------------------------------------------------------------------------*/

// ---------------------------------------------------------------------------
#ifdef __BORLANDC__
#include <vcl.h>
#endif

#pragma hdrstop

#include "TOpenWAM.h"
#include "labels.hpp"

// #include <tchar.h>
// ---------------------------------------------------------------------------

#pragma argsused

TOpenWAM* Aplication = NULL;

int main(int argc, char *argv[]) {

	init_labels();

	Aplication = new TOpenWAM();

	Aplication->ReadInputData(argv[1]);

	Aplication->ConnectFlowElements();

	Aplication->ConnectControlElements();

	Aplication->InitializeParameters();

	Aplication->InitializeOutput();

	Aplication->ProgressBegin();

	if(Aplication->IsIndependent()) {

		do {

			Aplication->Progress();

			Aplication->DetermineTimeStepIndependent();

			Aplication->NewEngineCycle();

			Aplication->CalculateFlowIndependent();

			Aplication->ManageOutput();

		} while(!Aplication->CalculationEnd());
	} else {
		do {

			Aplication->Progress();

			Aplication->DetermineTimeStepCommon();

			Aplication->NewEngineCycle();

			Aplication->CalculateFlowCommon();

			Aplication->ManageOutput();

		} while(!Aplication->CalculationEnd());
	}

	Aplication->GeneralOutput();

	Aplication->ProgressEnd();

	delete Aplication;

	return 0;

}
// ---------------------------------------------------------------------------



================================================
FILE: Source/OpenWAM.rc
================================================
#include "Version.h"

1 VERSIONINFO
FILEVERSION     VERSION_NUMBER
PRODUCTVERSION  VERSION_NUMBER
BEGIN
  BLOCK "StringFileInfo"
  BEGIN
    BLOCK "080904E4"
    BEGIN
      VALUE "CompanyName", "CMT - Motores Termicos"
      VALUE "FileDescription", "OpenWAM -  the free, open source 1-dimensional gas-dynamic code produced by CMT- Motores Termicos of the Universitat Politecnica de Valencia"
      VALUE "FileVersion", VERSION_STRING "\0"
      VALUE "InternalName", "OpenWAM"
      VALUE "LegalCopyright", "(C) 2014 CMT - Motores Termicos.  Universitat Politecnica de Valencia"
      VALUE "OriginalFilename", "OpenWAM.exe"
      VALUE "ProductName", "OpenWAM"
      VALUE "ProductVersion", VERSION_STRING "\0"
    END
  END

  BLOCK "VarFileInfo"
  BEGIN
    VALUE "Translation", 0x809, 1252
  END
END

101 ICON DISCARDABLE "Icon.ico"



================================================
FILE: Source/TCGestorWAM.cpp
================================================
/*--------------------------------------------------------------------------------*\
|==========================|
 |\\   /\ /\   // O pen     | OpenWAM: The Open Source 1D Gas-Dynamic Code
 | \\ |  X  | //  W ave     |
 |  \\ \/_\/ //   A ction   | CMT-Motores Termicos / Universidad Politecnica Valencia
 |   \\/   \//    M odel    |
 ----------------------------------------------------------------------------------
 | License
 |
 |	This file is part of OpenWAM.
 |
 |	OpenWAM is free software: you can redistribute it and/or modify
 |	it under the terms of the GNU General Public License as published by
 |	the Free Software Foundation, either version 3 of the License, or
 |	(at your option) any later version.
 |
 |	OpenWAM is distributed in the hope that it will be useful,
 |	but WITHOUT ANY WARRANTY; without even the implied warranty of
 |	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 |	GNU General Public License for more details.
 |
 |	You should have received a copy of the GNU General Public License
 |	along with OpenWAM.  If not, see <http://www.gnu.org/licenses/>.
 |
 \*--------------------------------------------------------------------------------*/

//---------------------------------------------------------------------------
#pragma hdrstop

#include "TCGestorWAM.h"

//---------------------------------------------------------------------------

#pragma package(smart_init)

//---------------------------------------------------------------------------
__fastcall TCGestorWAM::TCGestorWAM() {
}

void TCGestorWAM::Init() {
	BOOL fSuccess;
	//std::string lpszPipeName;
	string lpszPipeName;
	LPTSTR lpszPipeNameResp;
	DWORD dwMode;
	stringstream process_id(stringstream::in | stringstream::out);

	process_id << (float) GetCurrentProcessId();

	//lpszPipeName = "\\\\.\\pipe\\pipe" + FloatToStr((float)GetCurrentProcessId());

	lpszPipeName = "\\\\.\\pipe\\pipe" + process_id.str();

	//lpszPipeName = TEXT("\\\\.\\pipe\\pipe");

	lpszPipeNameResp = TEXT("\\\\.\\pipe\\pipeResp");

	//Espera hasta que se puede conectar a la tuberia

	//Sleep(5000); //Espero 5 segundos

	long num_pasadas = 0;

	while(num_pasadas <= 500000) {
		hPipe = CreateFile(lpszPipeName.c_str(), GENERIC_WRITE, 0, NULL,
						   OPEN_EXISTING, 0, NULL);

		if(hPipe != INVALID_HANDLE_VALUE)
			break;

		num_pasadas++;
	}

	//Si se ha llegado al final y no se ha conectado no
	//hacer nada mas
	if(num_pasadas <= 500000) {
		if(GetLastError() != 0)
			throw "Error al abrir tuberia";

		dwMode = PIPE_READMODE_MESSAGE;

		fSuccess = SetNamedPipeHandleState(hPipe, &dwMode, NULL, NULL);

		if(!fSuccess)
			throw "No se puede cambiar de modo la tuberia";
	} else {
		//Coloco hPipe en NULL para no hacer nada al enviar datos
		hPipe = NULL;
	}

	/*while (1)
	 {
	 hPipeResp = CreateFile(lpszPipeNameResp, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);

	 if (hPipeResp != INVALID_HANDLE_VALUE)
	 break;
	 }

	 if (GetLastError()!=0) throw "Error al abrir tuberia respuesta";
	 */
}

void TCGestorWAM::Enviar(char *msg) {
	DWORD cbWritten;
	BOOL fSuccess;
	LPTSTR mensaje;

	if(hPipe != NULL) {
		mensaje = TEXT(msg);

		fSuccess = WriteFile(hPipe, mensaje, (strlen(mensaje) + 1) * sizeof(TCHAR), &cbWritten, NULL);

		if(!fSuccess)
			throw "No se puede escribir en tuberia";
	}

}

void TCGestorWAM::Enviar(float valor) {
	DWORD cbWritten;
	BOOL fSuccess;

	if(hPipe != NULL) {
		fSuccess = WriteFile(hPipe, &valor, sizeof(float), &cbWritten, NULL);

		if(!fSuccess)
			throw "No se puede escribir en tuberia";
	}
}

void TCGestorWAM::EsperarRespuesta() {
	DWORD cbRead;
	BOOL fSuccess;
	TCHAR chBuf[BUFSIZE];

	fSuccess = ReadFile(hPipeResp, chBuf, BUFSIZE * sizeof(TCHAR), &cbRead,
						NULL);
}

void TCGestorWAM::NuevoMensaje(char *msg) {
	Enviar("NUEVOMENSAJE");

	Enviar(msg);

	//EsperarRespuesta();
}

void TCGestorWAM::ProcesoTranscurrido(float valor) {
	Enviar("PROCESOTRANSCURRIDO");

	Enviar(valor);

	//EsperarRespuesta();
}

void TCGestorWAM::CabeceraResInstantActualizada() {
	Enviar("CABECERARESINSTANTACTUALIZADA");
	//EsperarRespuesta();
}

void TCGestorWAM::CabeceraResMediosActualizada() {
	Enviar("CABECERARESMEDIOSACTUALIZADA");
	//EsperarRespuesta();
}

void TCGestorWAM::FichResMediosActualizado() {
	Enviar("FICHRESMEDIOSACTUALIZADO");
	//EsperarRespuesta();
}

void TCGestorWAM::FichResInstantActualizado() {
	Enviar("FICHRESINSTANTACTUALIZADO");
	//EsperarRespuesta();
}

void TCGestorWAM::Terminar() {
	Enviar("TERMINAR");
}




================================================
FILE: Source/TCGestorWAM.h
================================================
/*--------------------------------------------------------------------------------*\
|==========================|
 |\\   /\ /\   // O pen     | OpenWAM: The Open Source 1D Gas-Dynamic Code
 | \\ |  X  | //  W ave     |
 |  \\ \/_\/ //   A ction   | CMT-Motores Termicos / Universidad Politecnica Valencia
 |   \\/   \//    M odel    |
 ----------------------------------------------------------------------------------
 | License
 |
 |	This file is part of OpenWAM.
 |
 |	OpenWAM is free software: you can redistribute it and/or modify
 |	it under the terms of the GNU General Public License as published by
 |	the Free Software Foundation, either version 3 of the License, or
 |	(at your option) any later version.
 |
 |	OpenWAM is distributed in the hope that it will be useful,
 |	but WITHOUT ANY WARRANTY; without even the implied warranty of
 |	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 |	GNU General Public License for more details.
 |
 |	You should have received a copy of the GNU General Public License
 |	along with OpenWAM.  If not, see <http://www.gnu.org/licenses/>.
 |
 \*--------------------------------------------------------------------------------*/

//---------------------------------------------------------------------------
#ifndef TCGestorWAMH
#define TCGestorWAMH
//---------------------------------------------------------------------------
#endif

//#include <Classes.hpp>
//#include <stdio.h>
#include <windows.h>
//#include <iostream>
//#include <sstream>
#include "Globales.h"

#define BUFSIZE 4096

class TCGestorWAM {
  private:
	// User declarations
	HANDLE hPipe;
	HANDLE hPipeResp;

	void Enviar(LPTSTR msg);
	void Enviar(float valor);
	void EsperarRespuesta();
  public:
	__fastcall TCGestorWAM();
	void Init();
	void NuevoMensaje(LPTSTR msg);
	void ProcesoTranscurrido(float valor);
	void CabeceraResInstantActualizada();
	void CabeceraResMediosActualizada();
	void FichResMediosActualizado();
	void FichResInstantActualizado();
	void Terminar();
};



================================================
FILE: Source/TOpenWAM.h
================================================
/*--------------------------------------------------------------------------------*\
|==========================|
 |\\   /\ /\   // O pen     | OpenWAM: The Open Source 1D Gas-Dynamic Code
 | \\ |  X  | //  W ave     |
 |  \\ \/_\/ //   A ction   | CMT-Motores Termicos / Universidad Politecnica Valencia
 |   \\/   \//    M odel    |
 ----------------------------------------------------------------------------------
 | License
 |
 |	This file is part of OpenWAM.
 |
 |	OpenWAM is free software: you can redistribute it and/or modify
 |	it under the terms of the GNU General Public License as published by
 |	the Free Software Foundation, either version 3 of the License, or
 |	(at your option) any later version.
 |
 |	OpenWAM is distributed in the hope that it will be useful,
 |	but WITHOUT ANY WARRANTY; without even the implied warranty of
 |	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 |	GNU General Public License for more details.
 |
 |	You should have received a copy of the GNU General Public License
 |	along with OpenWAM.  If not, see <http://www.gnu.org/licenses/>.
 |
 \*--------------------------------------------------------------------------------*/

// ---------------------------------------------------------------------------
#ifndef TOpenWAMH
#define TOpenWAMH

#ifdef __BORLANDC__
#include <vcl.h>
#endif
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <string>
#include <regex>
#include <fstream>
#pragma hdrstop
#include "Globales.h"

#include "TTimeControl.h"

// ENGINE BLOCK AND CYLINDERS
#include "TBloqueMotor.h"
#include "TCilindro4T.h"

// COMPRESSOR
#include "TCompresorDep.h"
#include "TCompTubDep.h"
#include "TCompTubos.h"

// EXTERNAL CALCULATIONS
#include "TCalculoExtern.h"
#include "TRemansoMatlab.h"
#include "TCoefDescarga.h"
#include "TControlFuel.h"

// VALVES
#include "TCDExterno.h"
#include "TEstatorTurbina.h"
#include "TRotorTurbina.h"
#include "TWasteGate.h"
#include "TValvulaContr.h"
#include "TDiscoRotativo.h"
#include "TLumbrera.h"
#include "TCDFijo.h"
#include "TValvula4T.h"
#include "TLamina.h"
#include "TMariposa.h"

// PIPES
#include "TTubo.h"

// PLENUMS
#include "TDepVolVariable.h"
#include "TDepVolCte.h"
#include "TTurbinaSimple.h"
#include "TTurbinaTwin.h"
#include "TVenturi.h"
#include "TUnionDireccional.h"

// BOUNDARY CONDITIONS
#include "TCCDescargaExtremoAbierto.h"
#include "TCCExtremoAnecoico.h"
#include "TCCExtremoCerrado.h"
#include "TCCPulso.h"
#include "TCCCilindro.h"
#include "TCCUnionEntreTubos.h"
#include "TCCPerdidadePresion.h"
#include "TCCDeposito.h"
#include "TCCRamificacion.h"
#include "TCCExtremoInyeccion.h"
#include "TCCEntradaCompresor.h"
#include "TCCUnionEntreDepositos.h"
#include "TCCCompresorVolumetrico.h"
#include "TCCCompresor.h"
#include "TCCPreVble.h"
#include "TCFDConnection.h"
#include "TCCExternalConnection.h"
#include "TCCExternalConnectionVol.h"

// TURBOCHARGER AXIS
#include "TEjeTurbogrupo.h"

// DIESEL PARTICULATE FILTER
#ifdef ParticulateFilter
#include "TDPF.h"
#include "TCanalDPF.h"
#endif

// CONCENTRIC 1D ELEMENTS
#ifdef ConcentricElement
#include "TConcentricoTubos.h"
#include "TConcentricoDPF.h"
#endif

// CONTROL DEVICES
#include "TSensor.h"
#include "TPIDController.h"
#include "TTable1D.h"
#include "TDecisor.h"
#include "TGain.h"

// OUTPUT RESULTS
#include "TOutputResults.h"
#define completo 1

/* ! \def gestorcom
 Allow the communication with WAMer
 */

#include <sys/timeb.h>

#ifdef __BORLANDC__
#define gestorcom true
#define graphicalout true
#else
//#define gestorcom 0
//#define graphicalout 0
#endif

#ifdef gestorcom
#include "TCGestorWAM.h"
#endif

class TOpenWAM {
  private:

#ifdef gestorcom

	TCGestorWAM *GestorWAM;
#endif

	std::string tzstr;
	struct timeb begining, final, current;

	stRun Run;

	stDatosTGV *DatosTGV;
	std::string fileinput;

	FILE *FileInput;
	// !< Pointers to input and output files.
	FILE *fc; // !< Pointers to input and output files.

	//char fileinput[8];

	TBloqueMotor** Engine;
	TCompresor** Compressor;
	TCalculoExtern* EXTERN;
	TEjeTurbogrupo** Axis;

	// ! ARRAY OF TYPES OF VALVES
	TTipoValvula** TypeOfValve;

	// ! POINTERS ARRAY TO VALVES TYPE TURBINE STATOR
	TEstatorTurbina*** StatorTurbine;
	// ! POINTERS ARRAY TO VALVES TYPE TURBINE ROTOR
	TRotorTurbina** RotorTurbine;
	// ! POINTERS ARRAY TO EXTERNAL CONNECTIONS
	TTipoValvula** CCCalcExtern;
	TTipoValvula** BCButerflyValve;

	// ! ARRAY OF PIPES
	TTubo** Pipe;

	// ! ARRAY OF CONCENTRIC ELEMENTS
#ifdef ConcentricElement
	TConcentrico** Concentric;
#endif

	// ! ARRAY OF DPFs
#ifdef ParticulateFilter
	TDPF** DPF;
#endif

	// ! ARRAYS OF PLENUMS
	TDeposito** Plenum;
	TTurbina** Turbine;
	TVenturi** Venturi;

	// ! ARRAYS OF BOUNDARY CONDITIONS
	TCondicionContorno** BC;
	TCondicionContorno** BCIntakeValve;
	TCondicionContorno** BCExhaustValve;
	TCondicionContorno** BCReedValve;
	TCondicionContorno** BCWasteGate;

	TCCExternalConnection** BCExtConnection;
	TCCExternalConnectionVol** BCExtConnectionVol;

	TCCCompresorVolumetrico** VolumetricCompressor;
	TCCDescargaExtremoAbierto** MatlabDischarge;
	TCCExtremoInyeccion** InjectionEnd;
	TCCPerdidadePresion **PerdidaPresion;

	// !OUTPUT OBJECT
	TOutputResults* Output;

	// ! CONTROL PARAMETERS
	bool FirstIteration;
	int JStepMax;
	int JStepMaxDPF;
	int JCurrent;
	int JCurrentDPF;
	double TimeEndStep;
	double DeltaTPlenums;
	bool Independent;
	bool Is_EndStep;
	bool PipeStepMax;
	bool DPFStepMax;
	bool TimeMinPipe;
	bool TimeMinDPF;

	double CrankAngle;
	double AcumulatedTime;
	double Theta;
	double Theta0;

	// ! SPECIES MODEL PARAMETERS

	stEspecies* SpeciesName;
	int SpeciesNumber;

	nmTipoCalculoEspecies SpeciesModel;

	double* AtmosphericComposition;

	nmTipoCombustible FuelType;
	nmCalculoGamma GammaCalculation;

	// ! GENERAL PARAMETERS
	nmTipoMotor EngineType;

	nmTipoModelado SimulationType;
	bool ThereIsEGR;
	bool ThereIsFuel;
	int OpenWAMVersion;
	int Steps;
	int Increment;
	float Percentage;
	double ThetaIni;
	double ene;
	double agincr;
	double thmax;
	double grmax;
	double SimulationDuration;
	int CyclesWithoutThemalInertia;
	double AmbientPressure;
	double AmbientTemperature;
	bool ConvergenceFirstTime;

	// ! DOES THE ENGINE BLOCK EXIST?
	bool EngineBlock;

	// ! NUMBER OF PIPES
	int NumberOfPipes;

	// ! NUMBER OF CONCENTRIC ELEMENTS
	int NumberOfConcentrics;

	// ! NUMBER OF DIESEL PARTICULATE FILTERS
	int NumberOfDPF;

	// ! VALVES PARAMETERS
	int NumberOfValves;
	int NumberOfReedValves;
	int NumberOfWasteGates;
	int NumberOfExternalCalculatedValves;

	// ! CONNECTIONS PARAMETERS
	int NumberOfConnections;
	int NumberOfVolumetricCompressors;
	int NumberOfExhaustValves;
	int NumberOfIntakeValves;
	int NumberOfCompressorsConnections;
	int NumberOfInjectionEnds;
	int NumberOfConectionsBetweenPlenums;
	int NumberOfButerflyValves;

	// ! NUMBER OF PLENUMS
	int NumberOfPlenums;

	// ! NUMBER OF VENTURIS
	int NumberOfVenturis;

	// ! NUMBER OF DIRECTIONAL JUNCIONS
	int NumberOfDirectionalJunctions;

	// ! PARAMETER FOR THE CONTROL UNIT
	int NumberOfSensors;

	TSensor **Sensor;

	int NumberOfControllers;

	TController **Controller;

	// ! EXTERNAL CALCULATION PARAMETERS
	bool ThereIsDLL;
	int controlvalv;
	int nematlab;

	// ! TURBINE PARAMETERS
	int NumberOfTurbines;
	int CountVGT;

	// ! NUMBER OF TURBOCHARGER AXIS
	int NumberOfAxis;

	// ! NUMBER OF COMPRESSORS
	int NumberOfCompressors;

	// ! NUMBER OF PRESSURE LOSSES
	int NumTCCPerdidaPresion;

	int fi_num_threads; ///< Available threads for CalculateFlowIndependent.

	/**
	 * @brief Assigns the number of threads for CalculateFlowIndependent.
	 *
	 * As CalculateFlowFlowIndependent can use up to 3 threads, it counts
	 * the number of available processors and sets fi_num_threads to 1, 2
	 * or 3 accordingly.  Also, if OMP_NUM_THREADS is set to 2 or 1, it
	 * observes it.
	 */
	void InitFlowIndependentNumThreads();

	void CleanLabelsX();

	void CleanLabels();

	void ReadGeneralData();

	void ReadEngine();

	void ReadPipes();

	void ReadDPF();

	void ReadConcentric();

	void ReadValves();

	void ReadPlenums();

	void ReadCompressors();

	void ReadConnections();

	void ReadTurbochargerAxis();

	void ReadSensors();

	void ReadControllers();

	void ReadOutput(char* FileName);

	void ReadDataDLL();

	void RunningControl();

	void InitializeRunningAngles();

	void AllocateVGTData();

	void CalculateNewHeatPositions();

	void CalculateDistance(int NodoOrigen, int NodoFin, double Longitud, int NumberOfPlenums, int NumberOfPipes,
						   int NumberOfConnections, TTubo **Pipe, TCondicionContorno **BC);

	int SelectPipe(TTubo **Pipe, int NumberOfPipes, int nodo1, int nodo2);

	void MethodStability();

	void SearchMinimumTimeStep();

	void StudyInflowOutflowMass();

	void SearchMinimumTime(int LNumDepInicial, double* LTMinimo, TDeposito **LPlenum);

	void SearchMinimumTimeGroup(double *LTMinimo, int LNumDeposito, TDeposito **LPlenum);

	void FixTimeStep();

	void FixTimeStepExternal(double deltat);

	void RecalculateStability();

	void SolveAdjacentElements(int PipeEnd, double TiempoActual);

	void SolveBranch(int NumDeposito, double TiempoActual);

	void UpdateEngine();

	void SolveRoadLoadModel();

	void RecalculateStabilitySolver();

	void UpdateTurbocharger();

	void comunica_wam_dll();

	void ModificacionControlEjecucion();

	void Actuadores();

  public:

	TOpenWAM();

	~TOpenWAM();

	void ReadInputData(char* FileName);

	void InitializeParameters();

	void ConnectFlowElements();

	void ConnectControlElements();

	void InitialHeatTransferParameters();

	void DetermineTimeStepIndependent();

	void DetermineTimeStepCommon();

	void DetermineTimeStep(double t);

	void InitializeOutput();

	void CalculateFlowIndependent();

	void CalculateFlowCommon();

	void ManageOutput();

	bool CalculationEnd();

	void Progress();

	void ProgressBegin();

	void ProgressEnd();

	void NewEngineCycle();

	void GeneralOutput();

	bool IsIndependent() {
		return Independent;
	}
	;

	void UpdateExternalBoundary(int i, double U0, double U1, double T0, double T1, double P0, double P1, double t);

	void UpdateExternalBoundary(int i, double U0, double T0, double P0, double t);

	void InitiateExternalBoundary(int i, double D0, double D1, double dX);

	void InitiateExternalBoundary(int i, double D0, double dX);

	void LoadNewData(int i, double* p, double* T, double* u);

	bool GetIs_EndStep();

};
// ---------------------------------------------------------------------------
#endif



================================================
FILE: Source/TTimeControl.cpp
================================================
/*--------------------------------------------------------------------------------*\
==========================|
 \\   /\ /\   // O pen     | OpenWAM: The Open Source 1D Gas-Dynamic Code
 \\ |  X  | //  W ave     |
 \\ \/_\/ //   A ction   | CMT-Motores Termicos / Universidad Politecnica Valencia
 \\/   \//    M odel    |
 ----------------------------------------------------------------------------------
 License

 This file is part of OpenWAM.

 OpenWAM is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 OpenWAM is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with OpenWAM.  If not, see <http://www.gnu.org/licenses/>.


 \*--------------------------------------------------------------------------------*/

//---------------------------------------------------------------------------
#pragma hdrstop

#include "TTimeControl.h"

using namespace std;

#ifdef __BORLANDC__
int RDTSC(void) {
	int k = 0;
	asm rdtsc;
	asm mov k, eax;
	return k;
}

#elif _MSC_VER
int RDTSC(void) {
	return 0;
}

#else
extern "C" {
	inline unsigned long long RDTSC(void) {
		unsigned int a = 0, d = 0;
		asm volatile(
			"xorl %%eax, %%eax \n        cpuid"
			::: "%rax", "%rbx", "%rcx", "%rdx");
		asm volatile("rdtsc" : "=a"(a), "=d"(d));
		return (unsigned long long) d << 32 | a;
	}
}
#endif

//---------------------------------------------------------------------------

TTimeControl::TTimeControl() {
	TiempoTotal = 0.;
	TiempoCiclo0 = 0;
	TiempoCiclo1 = 0;
	Procesador = 2.2e9; //Hz
	Pasos = 0;
}

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

TTimeControl::~TTimeControl() {
}

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

void TTimeControl::Ini() {
	int k = 0;
	k = RDTSC();

	Inicio = k;
}

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

void TTimeControl::Fin() {
	int k = 0;
	k = RDTSC();

	Final = k;
	TiempoTotal += (double)(Final - Inicio) / Procesador;
	Pasos++;
}

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

void TTimeControl::PromediaCiclo() {
	TiempoCiclo0 = TiempoCiclo1;
	TiempoCiclo1 = TiempoTotal;
	printf("Tiempo total: %g seg.\n", TiempoTotal);
	printf("Tiempo ultimo ciclo: %g seg.\n\n", TiempoCiclo1 - TiempoCiclo0);
	printf("Pasos: %d\n", Pasos);
	printf("Tiempo por Steps: %g\n", TiempoTotal / (double) Pasos);
}
#pragma package(smart_init)



================================================
FILE: Source/TTimeControl.h
================================================
/*--------------------------------------------------------------------------------*\
==========================|
 \\   /\ /\   // O pen     | OpenWAM: The Open Source 1D Gas-Dynamic Code
 \\ |  X  | //  W ave     |
 \\ \/_\/ //   A ction   | CMT-Motores Termicos / Universidad Politecnica Valencia
 \\/   \//    M odel    |
 ----------------------------------------------------------------------------------
 License

 This file is part of OpenWAM.

 OpenWAM is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 OpenWAM is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with OpenWAM.  If not, see <http://www.gnu.org/licenses/>.


 \*--------------------------------------------------------------------------------*/

//---------------------------------------------------------------------------
#ifndef TTimeControlH
#define TTimeControlH
#include <cstdio>

class TTimeControl {
  private:

	int Inicio;
	int Final;
	int Pasos;
	double TiempoCalculo;
	double TiempoTotal;
	double TiempoCiclo0;
	double TiempoCiclo1;
	double Procesador;

  public:
	TTimeControl();
	~TTimeControl();

	void Ini();
	void Fin();
	void PromediaCiclo();

};

//---------------------------------------------------------------------------
#endif



================================================
FILE: Source/Version.h
================================================
#define VERSION_MAJOR 2
#define VERSION_MINOR 2
#define VERSION_BUILD 0
#define VERSION_QFE 0
#define VERSION_BUILD_DATE "02/12/2015"
#define VERSION_BUILD_TIME "18:00:00UTC"

#define _STR(x) #x
#define STR(x) _STR(x)

#define VERSION_NUMBER VERSION_MAJOR,VERSION_MINOR,VERSION_BUILD,VERSION_QFE
#define VERSION_STRING STR(VERSION_MAJOR) "." STR(VERSION_MINOR) "." STR(VERSION_BUILD) "." STR(VERSION_QFE)
#define VERSION_PRINT "v" STR(VERSION_MAJOR) "." STR(VERSION_MINOR) " build " STR(VERSION_BUILD)
#define VERSION_COMPANY ""
#define VERSION_COPYRIGHT "(C) Gugulea 2005"
#define VERSION_TRADEMARK ""
#define VERSION_BUILD_DATE_TIME VERSION_BUILD_DATE " - " VERSION_BUILD_TIME



================================================
FILE: Source/version.ver
================================================
#define VERSION_MAJOR 2
#define VERSION_MINOR 2
#define VERSION_BUILD 0
#define VERSION_QFE 0
#define VERSION_BUILD_DATE "02/12/2015"
#define VERSION_BUILD_TIME "18:00:00UTC"


================================================
FILE: Source/1DPipes/CMakeLists.txt
================================================
add_library(1DPipes TTubo.cpp)



================================================
FILE: Source/1DPipes/TTubo.h
================================================
/* --------------------------------------------------------------------------------*\
==========================|
 \\   /\ /\   // O pen     | OpenWAM: The Open Source 1D Gas-Dynamic Code
 \\ |  X  | //  W ave     |
 \\ \/_\/ //   A ction   | CMT-Motores Termicos / Universidad Politecnica Valencia
 \\/   \//    M odel    |
 ----------------------------------------------------------------------------------
 License

 This file is part of OpenWAM.

 OpenWAM is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 OpenWAM is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with OpenWAM.  If not, see <http://www.gnu.org/licenses/>.


 \*--------------------------------------------------------------------------------*/

/**
 * @file TTubo.h
 * @author Francisco Jose Arnau <farnau@mot.upv.es>
 *
 * @section LICENSE
 *
 * This file is part of OpenWAM.
 *
 * OpenWAM is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * OpenWAM is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with OpenWAM.  If not, see <http://www.gnu.org/licenses/>.
 *
 * @section DESCRIPTION
 * This file declares a finite differences pipe.
 */

//---------------------------------------------------------------------------
#ifndef TTuboH
#define TTuboH
#include <cstdio>
#include <iostream>
#ifdef __BORLANDC__
#include <vcl.h>
#endif
//#include <cmath>
#include "TCondicionContorno.h"
#include "TDeposito.h"
#include "TBloqueMotor.h"
#include "TCCUnionEntreTubos.h"
#include "TCCCilindro.h"
#include "TCCDeposito.h"
#include "TDPF.h"
#include "Constantes.h"
#include "Globales.h"
//#include "roots.h"

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

class TCondicionContorno;
class TBloqueMotor;
class TDeposito;

struct stFunDisCar {
	double A_0;
	double A_1;
	double V_0;
	double V_1;
	double D_t;
	double Sign;

	stFunDisCar(double a0, double a1, double v0, double v1, double dt, double sg) {
		A_0 = a0;
		A_1 = a1;
		V_0 = v0;
		V_1 = v1;
		D_t = dt;
		Sign = sg;
	}
	double operator()(double x) {
		double xx = 1 - x;
		if(Sign > 0) {
			double a = A_0 * xx + A_1 * x;
			double v = V_0 * xx + V_1 * x;
			return x - (a - v) * D_t;
		} else {
			double a = A_0 * x + A_1 * xx;
			double v = V_0 * x + V_1 * xx;
			return xx - (a + v) * D_t;
		}
	}
};

/**
 * @brief a Finite differences pipe.
 *
 * This class contains the methods, variables and attributes related with
 * finite differences pipes.
 */
class TTubo {
  private:
//---------------------------------------------------------------------------
//          VARIABLES PRIVADAS
//---------------------------------------------------------------------------

	int FTuboCCNodoIzq; //!< Save the position in the struct TuboExtremo of the pipe connected to the left end
	int FTuboCCNodoDer; //!< Save the position in the struct TuboExtremo of the pipe connected to the right end

	// Datos Geometricos

	int FNumeroTubo;          	//!< Number of the pipe
	int FNodoIzq;               //!< Number of the connection at the left end
	int FNodoDer;       		//!< Number of the connection at the rignt end
	int FNin;              		//!< Number of calculation cells
	int FJClase;           		//!< Tipe of the pipe
	double FXref;                 	//!< Cell size
	double FLongitudTotal;   		//!< Total length of the pipe
	double FMallado;           	//!< Initial cell size
	int FNTramos;               //!< Number of parts of the pipe
	nmTipoMallado FTipoMallado;       	//!< Meshing mode 1=Distance 2=Angle
	double *FLTramo;         //!< Array with the length of the parts of the pipe
	double *FDExtTramo; //!< Array with the diameter at the end of the parts of the pipe
	double *FDiametroTubo;         //!< Diametro de cada nodo de calculo
	double *FDiametroD12; //!< Diameter interpolated between two cell using the diameters average
	double *FDiametroS12; //!< Diameter interpolated between two cell using the section average
	double *FArea;				    //!< Array with the cell sections.
	double *FArea12;			//!< Array with the sections between two cells
	double *FDerLin;
	double *FDerLin12;
	double *FDerLinArea;
	double *FDerLinArea12;
	bool FIntercooler;           //!< The pipe is repited to form a set of pipes
	bool FConcentrico;        //!< Does the pipe form part of a concentric duct?
	int FNumeroConductos;       //!< Number of similar pipes that form the set

	// Propiedades termicas y friccion

	double FFriccion;              //!< Friction of the pipe
	nmTipoTransCal FTipoTransCal;     		//!< Type of heat transfer
	double FCoefAjusFric;          //!< Friction multiplier
	double FCoefAjusTC;            //!< Heat transfer multiplier
	double FEspesorIntPrin; //!< Inner thickness of the main layer of the pipe wall
	double FEspesorExtPrin; //!< Outer thickness of the main layer of the pipe wall
	double FEspesorPrin;        //!< Thicknes of the main layer of the pipe wall
	double FDensidadPrin; //!< Density of the material of the main layer of the pipe wall
	double FCalEspPrin; //!< Specific heat of the material of the main layer of the pipe wall
	double FConductPrin; //!< Conductivity of the material of the main layer of the pipe wall
	double FTRefrigerante;         //!< Coolant temperature
	nmRefrigerante FTipRefrig;        		//!< Type of coolant
	int FTctpt;                 //!< Type of wall temperature calculation
	nmTipoCalcTempParedTubos FTipoCalcTempPared; //!< Type of wall temperature calculation
	double FTIniParedTub;          //!< Initial wall temperatura
	double *FVelPro; //!< Array with the temporal average of the gas velocity at each cell
	double *FCoefTurbulencia;      //!< Turbulence coefficient in exhaust pipes
	double ***FSUMTPTuboPro;       //!< Summation of wall temperature
	double FSUMTime;				//!< Summation of the time steps
	double **FTPTubo;            //!< Wall temperature in the current time steps
	double **FTParedAnt;        //!< Wall temperature in the previous time steps
	double FTExt;	                //!< External temperature
	//double FAlpha;
	double FCoefExt;	//!< Heat transfer coeficient multiplier at outer pipe wall
	double *Fhi;                   //!< Inner heat trasnfer coeficient
	double *Fhe;                   //!< Outer heat transfer coeficient
	double *Frho;                  //!< Gas density at each cell
	double *FRe;                   //!< Reynolds number at each cell
	stCapa *FCapa;                 //!< Array with the layers of the pipe wall
	int FNumCapas;              //!< Number of layers
	double FEmisividad;            //!< Emisivity of the pipe wall
	double *FResistRadInt; //!< Inner radial thermal resistance of the pipe wall
	double *FResistRadExt; //!< Outer radial thermal resistance of the pipe wall
	double *FResistAxiAnt; //!< Previus axial thermal resistance of the pipe wall
	double *FResistAxiPos;   //!< Next axial thermal resistance of the pipe wall
	double *FCapInt;               //!< Inner thermal capacity
	double *FCapMed;               //!< Thermal capacity at the middle
	double *FCapExt;               //!< Outer thermal capacity

	// Propiedades termofluidodinamicas

	double FVelMedia;             //!< Average gas velocity along the entry pipe
	double FTini;                  //!< Initial gas temperature
	double FPini;                  //!< Initial pressure
	double *FPresion0;             //!< Pressure at the current time step
	double *FAsonido0; //!< Adimensionalized speed of sound at the current time step
	double *FVelocidad0; //!< Adimensionalized gas velocity at the current time step
	double *FPresion1;             //!< Pressure at the new time step
	double *FAsonido1; //!< Adimensionalized speed of sound at the new time step
	double *FVelocidad1; //!< Adimensionalized gas velocity at the new time step
	double *FVelocidadDim;			//!< Gas velocity at the nodes
	double *FAsonidoDim;			//!< Speed of sound at the nodes
	double *FTemperature;			//!< Gas temperature at the nodes
	double *FFlowMass;				//!< Air mass flow at the nodes

	// Vectores metodo de calculo

	stModeloCalculoTubos FMod;				//!< Struct with the options of the numerical scheme used to solve the duct
	double **FU0;					//!< State vector at the current time
	double **FU0Sum;				//!< Sumatory of the state vector (not used)
	double **FU0Medio;				//!< Average of the state vector (not used)
	double *FVelocidadMedia;		//!< Average gas velocity (not used)
	double *FAsonidoMedia;			//!< Average speed of sound (not used)
	double *FPresionMedia;			//!< Average presseure (not used)
	double **FU1;					//!< State vector at the following time step
	double **FUt;					//!< Variation of the state vector versus time (Used with CE-SE)
	double **FU12;				//!< State vector at the intermediate time step
	double **FW;					//!< Flux vector
	double **FV1;	//!< Source vector (related with cross section variation)
	double **FV2;	//!< Source vector (related with friction and heat transfer)
	double FCcese;					//!< CE-SE constant

	// Vectores del flux corrected transport

	double **FUfct0;			//!< State vector input for the FCT techniques
	double **FUfct1;			//!< State vector output for the FCT techniques
	double **FUfctd;				//!< Difused state vector
	double **FUfctad;				//!< Antidifused state vector
	double **Ffl;					//!< FCT intermediate parameter
	double **FdU;					//!< FCT intermediate parameter
	double **FDeltaFCTd;			//!< FCT intermediate parameter
	double **FflU;					//!< FCT intermediate parameter
	double **FaU;					//!< FCT intermediate parameter

	// Vectores de TVD Davis

	//double **FTVD;
	//double **FTVDdU;
	//double *FTVDpp;
	//double *FTVDpn;
	//double *FTVDphp;
	//double *FTVDphn;
	//double *FTVDrp;
	//double *FTVDrn;
	//double *FTVDGn;
	//double *FTVDGp;

	// Variables del TVD

	stTVD FTVD;		//!< Struct with the intermediate parameters of TVD scheme
	double *sqrtRhoA;

	// Calculo Especies

	int FNumeroEspecies;		//!< Number of chemical species considered
	nmTipoCalculoEspecies FCalculoEspecies; 	//!< Species calculation mode
	nmCalculoGamma FCalculoGamma;	//!< Specific heat ratio calculation mode
	double *FComposicionInicial; 	//!< Initial composition
	double **FFraccionMasicaEspecie; //!< Mass fraction of each chemical specie at every cell
	double **FFraccionMasicaCC;	//!< Mass fraction of each chemical specie at boundaries
	bool FHayEGR;				//!< The EGR specie is considered?
	int FIntEGR;	//!< Integer equal to 1 if EGR is considered else equal to 0

	int FNumEcuaciones;	//!< Total number of conservation equation (including species mass conservation)

	double *FVelocidadCC;			//!< Gas velocity at boundaries
	double *FDensidadCC;			//!< Gas density at boundaries
	double *FAreaCC;				//!< Section at boundaries
	double *FGamma;			//!< Specific heat ratio at every calculation cell.
	double *FRMezcla;		//!< Perfect gas constant at every calculation cell.
	double *FCpMezcla;		//!< Specific heat at constant pressure at every calculation cell.
	double *FCvMezcla; //!< Specific heat at constant volume at every calculation cell.
	double FGammaN;

	double *FGamma1;				//!< Value dependent of specific heat ratio
	double *FGamma3;				//!< Value dependent of specific heat ratio
	double *FGamma4;				//!< Value dependent of specific heat ratio
	double *FGamma5;				//!< Value dependent of specific heat ratio
	double *FGamma6;				//!< Value dependent of specific heat ratio

	// Tiempos

//        double 						FTime0;					//!< Time at current time step
//        double 						FTime1; 				//!< Time at following time step
//        double 						FDeltaTime; 			//!< Time step
	double *FCourantLocal;	//!< Local Courant number at every calculation cell
	double FCourant;				//!< Courant number

	// Resultados medios e instantaneos

	stResMediosTubo *ResultadosMedios; 		//!< Struct with the average results
	int FNumResMedios;			//!< Number of average results selected
	stResInstantTubo *ResultInstantaneos;			//!< Struct with the instantaneous results
	int FNumResInstant;			//!< Number of instantaneous results selected
	double FTiempoMedSUM;	//!< Time acumulation to obtain the average results
	double FControlResMed;	//!< Parameter to control when the average is calculated
	stSensoresTubo *Sensor;				//!< (not used)
	int FNumDistSensores;		//!< (not used)

	double FAnguloTotalCiclo;		//!< Total angle of the engine cycle
	double FRegimenFicticio;	//!< Ficticios engine speed to use when there is not an engine in the model calculated.

	int FCicloTubo; 			//!< Number of the current cycle
	int FCicloActual; // !< Number of the current cycle when there is not engine in the configuration
	double FDuracionCiclo; // !< Cycle duration (in time) to calculate wall temperature convergence when there is not engine in the configuration
	int FNumCiclosSinInerciaTermica; // !< Number of cycles without thermal inertia consideration when there is not engine in the configuration

	TDPF *FDPFSalidaTubo;  		//  DPF connected to the outlet of the duct
	TDPF *FDPFEntradaTubo;       //  DPF connected to the inlet of the duct
	bool FHayDPFNodoIzq; //  bool to identify DPF connected at the inlet of the duct
	bool FHayDPFNodoDer; //  bool to identify DPF connected at the outlet of the duct
	int FNodoDPFEntrada;  //  Node of the DPF connected to the inlet of the duct
	int FNodoDPFSalida;  //  Node of the DPF connected to the outlet of the duct
	int *FTipoCanal; //  bool to identify DPF connected at the outlet of the duct

//---------------------------------------------------------------------------
//          FUNCIONES PRIVADAS
//---------------------------------------------------------------------------

	/*! Generate the mesh in the pipes */
	void CalculoPuntosMalla(double ene						//!< Engine speed
						   );

	//double InterpolaTubo(double  vizq,double  vder,double  axid,double  xif);

	/*! Transfor from the gas velocity, speed of sound and pressure to state vector */
	void Transforma1(const double& v,						//!< Gas velocity
					 const double& a,								//!< Speed of sound
					 const double& p,								//!< Pressure
					 double** U,								//!< State vector
					 const double& Gamma,						//!< Specific heat ratio
					 const double& Gamma1,					//!< f(Specific heat ratio)
					 double* Yespecie,		//!< Array with the specie mass fractions
					 const int& i								//!< Cell index
					);

	/*! Transfor from the gas velocity, speed of sound and pressure to state vector (including the cross section in the state vector) */
	void Transforma1Area(const double& v,					//!< Gas velocity
						 const double& a,								//!< Speed of sound
						 const double& p,								//!< Pressure
						 double** U,								//!< State vector
						 const double& area,							//!< Cross section
						 const double& Gamma,						//!< Specific heat ratio
						 const double& Gamma1,					//!< f(Specific heat ratio)
						 double* Yespecie,		//!< Array with the specie mass fractions
						 const int& i								//!< Cell index
						);

	/*! Transfor from the state vector to gas  velocity, speed of sound and pressure */
	void Transforma2(double& v,								//!< Gas velocity
					 double& a,								//!< Speed of sound
					 double& p,								//!< Pressure
					 double** U,								//!< State vector
					 const double& Gamma,						//!< Specific heat ratio
					 const double& Gamma1,					//!< f(Specific heat ratio)
					 double* Yespecie,			//!< Array with the specie mass fraction
					 const int& i								//!< Cell index
					);

	/*! Transfor from the state vector to gas  velocity, speed of sound and pressure */
	void Transforma2Area(double& v,							//!< Gas velocity
						 double& a,								//!< Comment
						 double& p,								//!< Comment
						 double** U,								//!< Comment
						 const double& area,							//!< Comment
						 const double& Gamma,							//!< Comment
						 const double& Gamma1,							//!< Comment
						 double* Yespecie,						//!< Comment
						 const int& i								//!< Comment
						);

	/*! Comment */
	void Transforma3Area(double** Ufct,								//!< Comment
						 double** U,									//!< Comment
						 double Area,								//!< Comment
						 double Gamma,								//!< Comment
						 double Gamma1,								//!< Comment
						 double Gamma6,								//!< Comment
						 int i									//!< Comment
						);

	/*! Comment */
	void Transforma4Area(double** U1,		//!< Comment
						 double** Ufctd,	//!< Comment
						 double Area,	//!< Comment
						 double Gamma,	//!< Comment
						 double Gamma1,	//!< Comment
						 double Gamma3,	//!< Comment
						 double Gamma4,	//!< Comment
						 double Gamma6,	//!< Comment
						 int i		//!< Comment
						);

	/*! Comment */
	double Maximo(double x,	//!< Comment
				  double y	//!< Comment
				 );

	/*! Comment */
	double Minimo(double x,	//!< Comment
				  double y	//!< Comment
				 );

	/*! Comment */
	void LaxWendroff();

	/*! Comment */
	void LaxWendroffArea();

	/*! Comment */
	void FluxCorrectedTransport();

	/*! Comment */
	void CalculaFlujo(double** U,		//!< Comment
					  double** W,		//!< Comment
					  double* Gamma,	//!< Comment
					  double* Gamma1,	//!< Comment
					  int Nodos	//!< Comment
					 );

	/*! Comment */
	void CalculaFuente1(double** U,		//!< Comment
						double** V1,		//!< Comment
						double* Gamma,	//!< Comment
						double* Gamma1,	//!< Comment
						int Nodos	//!< Comment
					   );

	/*! Comment */
	void CalculaFuente1Area(double** U,		//!< Comment
							double** V1,		//!< Comment
							double* Area,	//!< Comment
							double* Gamma1,	//!< Comment
							int Nodos	//!< Comment
						   );

	/*! Comment */
	void CalculaFuente2(double** U,					//!< Comment
						double** V2,					//!< Comment
						double* Area,				//!< Comment
						double* hi,					//!< Comment
						double* rho,				//!< Comment
						double* Re,					//!< Comment
						double* TempParedTubo,		//!< Comment
						double* Gamma,				//!< Comment
						double* Rmezcla,			//!< Comment
						double* Gamma1,				//!< Comment
						int Nodos				//!< Comment
					   );

	/*! Comment */
	void CalculaFuente2Area(double** U,					//!< Comment
							double** V2,					//!< Comment
							double* Area,				//!< Comment
							double* hi,					//!< Comment
							double* rho,				//!< Comment
							double* Re,					//!< Comment
							double* TempParedTubo,		//!< Comment
							double* Gamma,				//!< Comment
							double* Rmezcla,			//!< Comment
							double* Gamma1,				//!< Comment
							int Nodos				//!< Comment
						   );

	/*! Comment */
	double DerLinF(double d1,	//!< Comment
				   double d2,	//!< Comment
				   double xref	//!< Comment
				  );

	/*! Comment */
	double DerLinFArea(double area1,	//!< Comment
					   double area2,	//!< Comment
					   double xref		//!< Comment
					  );

	/*! Comment */
	void Colebrook(double rug,	//!< Comment
				   double dia,	//!< Comment
				   double& f,		//!< Comment
				   double Re		//!< Comment
				  );

	/*! Comment */
	void TransmisionCalor(double tgas,				//!< Comment
						  double diametro,			//!< Comment
						  double& q,					//!< Comment
						  double hi,					//!< Comment
						  double rho,				//!< Comment
						  double Tw					//!< Comment
						 );

	/*! Comment */
	void TransformaContorno(double& L,		//!< Comment
							double& B,		//!< Comment
							double& E,		//!< Comment
							double& a,		//!< Comment
							double& v,		//!< Comment
							double& p,		//!< Comment
							const int& modo,	//!< Comment
							const double& Gamma1,	//!< Comment
							const double& Gamma3,	//!< Comment
							const double& Gamma4,	//!< Comment
							const double& Gamma5	//!< Comment
						   );

	/*! Comment */
	double CalculaNIT(double a,		//!< Comment
					  double v,		//!< Comment
					  double p,		//!< Comment
					  double d,		//!< Comment
					  double Gamma, double Rmezcla);

	//void FuncionTVD();

	/*! Comment */
	void Calculo_Entropia(double& entropia,		//!< Comment
						  double& velocidadp,		//!< Comment
						  int ind,			//!< Comment
						  double dist,			//!< Comment
						  int signo,			//!< Comment
						  double DeltaTiempo,	//!< Comment
						  int indiceCC		//!< Comment
						 );

	/*! Comment */
	void Calculo_Caracteristica(double& caracteristica,	//!< Comment
								double& velocidadp,		//!< Comment
								double& asonidop,		//!< Comment
								int ind,			//!< Comment
								double dist,			//!< Comment
								int signo,			//!< Comment
								double entropia,		//!< Comment
								double DeltaTiempo		//!< Comment
							   );

	/*! Comment */
	void CalculaB();

	/*! Comment */
	void CalculaBmen();

	/*! Comment */
	void CalculaBmas();

	/*! Comment */
	void CalculaMatrizJacobiana();

	/*! Comment */
	void TVD_Estabilidad();

	/*! Comment */
	void TVD_Limitador();

	void RoeConstants();

	/*! Comment */
	void DimensionaTVD();

	/*! Comment */
	double Limita(double r	//!< Comment
				 );

  public:
//---------------------------------------------------------------------------
//          VARIABLES PUBLICAS
//---------------------------------------------------------------------------

	/**
	 * @brief Gets the pipe id.
	 *
	 * Gets the current pipe id.
	 *
	 * @return Pipe id.
	 */
	int getNumeroTubo() const;

	/**
	 * @brief Gets the left-hand side node.
	 *
	 * Gets the current pipe left-hand side node.
	 *
	 * @return Left-hand side node.
	 */
	int getNodoIzq() const;

	/**
	 * @brief Gets the right-hand side node.
	 *
	 * Gets the current pipe right-hand side node.
	 *
	 * @return Right-hand side node.
	 */
	int getNodoDer() const;

	int getNin() {
		return FNin;
	}
	;
	int getNumeroConductos() {
		return FNumeroConductos;
	}
	;
	double getXRef() {
		return FXref;
	}
	;

	/**
	 * @brief Gets the total length of the pipe.
	 *
	 * Gets the total length of the pipe.
	 *
	 * @return Total length of the pipe.
	 */
	double getLongitudTotal() const;

	nmTipoTransCal getTipoTransCal() {
		return FTipoTransCal;
	}
	;
	double getCoefAjustTC() {
		return FCoefAjusTC;
	}
	;
	double getCoefAjustFric() {
		return FCoefAjusFric;
	}
	;
	double getFriccion() {
		return FFriccion;
	}
	;
	double getEmisividad() {
		return FEmisividad;
	}
	;
	bool getConcentrico() {
		return FConcentrico;
	}
	;
	double getDuracionCiclo() {
		return FDuracionCiclo;
	}
	;
	double getNumCiclosSinInerciaTermica() {
		return FNumCiclosSinInerciaTermica;
	}
	;
	nmTipoCalcTempParedTubos getTipoCalcTempPared() {
		return FTipoCalcTempPared;
	}
	;
	double getAnguloTotalCiclo() {
		return FAnguloTotalCiclo;
	}
	;
	double getTExt() {
		return FTExt;
	}
	;
	double getEspesorIntPrin() {
		return FEspesorIntPrin;
	}
	;
	double getConductPrin() {
		return FConductPrin;
	}
	;
	double getEspesorPrin() {
		return FEspesorPrin;
	}
	;
	double getDensidadPrin() {
		return FDensidadPrin;
	}
	;
	double getCalEspPrin() {
		return FCalEspPrin;
	}
	;
	bool getHayDPFNodoDer() {
		return FHayDPFNodoDer;
	}
	;
	bool getHayDPFNodoIzq() {
		return FHayDPFNodoIzq;
	}
	;
	int getNumCapas() {
		return FNumCapas;
	}
	; /*! Return the number of wall layer */
	TDPF* getDPFEntrada() {
		return FDPFEntradaTubo;
	}
	;
	TDPF* getDPFSalida() {
		return FDPFSalidaTubo;
	}
	;
	int getNodoDPFEntrada() {
		return FNodoDPFEntrada;
	}
	;
	int getNodoDPFSalida() {
		return FNodoDPFSalida;
	}
	;

	double FTime0; //!< Time at current time step

	/**
	 * @brief Gets the current time.
	 *
	 * Gets the current time.
	 *
	 * @return Current time. [s]
	 */
	double getTime0() const;

	/**
	 * @brief Sets the current time.
	 *
	 * Sets the current time.
	 *
	 * @param valor Current time. [s]
	 */
	void PutTime0(double valor);

	double FTime1; //!< Time at following time step

	/**
	 * @brief Gets the time at the following time-step.
	 *
	 * Gets the time at the following time-step.
	 *
	 * @return Time after the following time-step. [s]
	 */
	double getTime1() const;

	/**
	 * @brief Sets the time after the following time-step.
	 *
	 * Sets the time after the following time-step.
	 *
	 * @param valor Time after the following time-step. [s]
	 */
	void PutTime1(double valor);

	double FDeltaTime; //!< Time step

	/**
	 * @brief Gets the time step.
	 *
	 * Gets the current time step.
	 *
	 * @return Time step. [s]
	 */
	double getDeltaTime() const;

	/**
	 * @brief Sets the time step.
	 *
	 * Sets the current time step.
	 *
	 * @param valor Time-step. [s]
	 */
	void PutDeltaTime(double valor);

	/**
	 * @brief Gets the mesh size.
	 *
	 * Gets the mesh size.
	 *
	 * @return Mesh size. [m]
	 */
	double getMallado() const;

	/**
	 * @brief Gets the density.
	 *
	 * Gets the density at a given cell.
	 *
	 * @param i Cell.
	 * @return Density. [kg / (m ** 3)]
	 */
	double GetDensidad(int i) const;

	/**
	 * @brief Gets the cross section at a given cell.
	 *
	 * Gets the cross section at a given cell.
	 *
	 * @param i Cell.
	 * @return Cross section. [m ** 2]
	 */
	double GetArea(int i) const;

	/**
	 * @brief Gets the cell diameter.
	 *
	 * Gets the diameter at a given cell.
	 *
	 * @param i Cell.
	 * @return Diameter. [m]
	 */
	double GetDiametro(int i) const;

	/**
	 * @brief Gets the fluid speed.
	 *
	 * Gets the fluid speed at a given cell.
	 *
	 * @param i Cell.
	 * @return Speed. [m / s]
	 */
	double GetVelocidad(int i) const;

	/**
	 * @brief Gets the speed of sound.
	 *
	 * Gets the speed of sound at a given cell.
	 *
	 * @param i Cell.
	 * @return Speed of sound. [m / s]
	 */
	double GetAsonido(int i) const;

	/**
	 * @brief Gets the fluid pressure.
	 *
	 * Gets the fluid pressure at a given cell.
	 *
	 * @param i Cell.
	 * @return Fluid pressure. [m / s]
	 */
	double GetPresion(int i) const;

	/**
	 * @brief Gets the wall temperature at a given cell and node.
	 *
	 * Gets the wall temperature at a given cell and node.
	 *
	 * @param j Node.
	 * @param i Cell.
	 * @return Wall temperature.
	 */
	double GetTPTubo(int j, int i) const;

	/**
	 * @brief Sets the wall temperature at a given cell and node.
	 *
	 * Sets the wall temperature at a given cell and node.
	 *
	 * @param k Node.
	 * @param i Cell.
	 * @param valor Wall temperature.
	 */
	void PutTPTubo(int k, int i, double valor);

	/**
	 * @brief Gets the previous wall temperature at a given cell and node.
	 *
	 * Gets the previous wall temperature at a given cell and node.
	 *
	 * @param j Node.
	 * @param i Cell.
	 * @return Wall temperature.
	 */
	double GetTPTuboAnt(int j, int) const;

	/**
	 * @brief Gets the integrated gas velocity.
	 *
	 * Gets the integrated gas velocity at a given cell.
	 *
	 * @param i Cell.
	 * @return Integrated gas velocity. [m / s]
	 */
	double GetVelPro(int i) const;

	/**
	 * @brief Sets the integrated gas velocity.
	 *
	 * Sets the integrated gas velocity at a given cell.
	 *
	 * @param i Cell.
	 * @param valor Integrated gas velocity. [m / s]
	 */
	void PutVelPro(int i, double valor);

	/**
	 * @brief Gets the turbulence coefficient.
	 *
	 * Gets the turbulence coefficient at a given cell.
	 *
	 * @param i Cell.
	 * @return Turbulence coefficient.
	 */
	double GetCoefTurbulencia(int i) const;

	/**
	 * @brief Gets the initial temperature.
	 *
	 * Gets the initial temperature.
	 *
	 * @return Initial temperature.
	 */
	double getTemperaturaInicial() const;

	/**
	 * @brief Gets the initial temperature of the wall.
	 *
	 * Gets the initial temperature of the wall.
	 *
	 * @return Initial temperature of the wall.
	 */
	double getTempWallIni() const;

	/**
	 * @brief Gets the initial pressure.
	 *
	 * Gets the initial pressure.
	 *
	 * @return Initial pressure.
	 */
	double getPresionInicial() const;

	/**
	 * @brief Gets the mean speed.
	 *
	 * Gets the mean speed.
	 *
	 * @return Mean speed. [m / s]
	 */
	double getVelocidadMedia() const;

	/**
	 * @brief Gets the initial mass fraction of species i.
	 *
	 * Gets the initial mass fraction of species i.
	 *
	 * @param i Species id.
	 * @return Mass fraction.
	 */
	double GetFraccionMasicaInicial(int i) const;

	/*! Return the specie i mass fraction at boundary j */
	double GetFraccionMasicaCC(int j,						//!< Boundary index
							   int i											//!< Specie index
							  ) {
		return FFraccionMasicaCC[j][i];
	}
	;

	/*! Return the gas velocity at boundary i */
	double GetVelocidadCC(int i								//!< Boundary index
						 ) {
		return FVelocidadCC[i];
	}
	;

	/*! Return the gas density at boudary i */
	double GetDensidadCC(int i								//!< Boundary index
						) {
		return FDensidadCC[i];
	}
	;

	/*! Return the cross section at boundary i  */
	double GetAreaCC(int i									//!< Boundary index
					) {
		return FAreaCC[i];
	}
	;

	/**
	 * @brief Gets the specific heat capacities ratio at a given cell.
	 *
	 * @param i Cell.
	 * @return Specific heat capacities ratio.
	 */
	double GetGamma(int i) const;

	/**
	 * @brief Gets the gas constant of the mixture at a given cell.
	 *
	 * @param i Cell.
	 * @return Gas constant. [J / (kg * K)]
	 */
	double GetRMezcla(int i) const;

	/**
	 * @brief Gets the specific heat capacity at constant pressure at a given
	 * cell.
	 *
	 * @param i Cell.
	 * @return Specific heat capacity at constant pressure. [J / (kg * K)]
	 */
	double GetCpMezcla(int i) const;

	/**
	 * @brief Gets the specific heat capacity at constant volume at a given
	 * cell.
	 *
	 * @param i Cell.
	 * @return Specific heat capacity at constant volume. [J / (kg * K)]
	 */
	double GetCvMezcla(int i) const;

	nmFormulacionLeyes getFormulacionLeyes() {
		return FMod.FormulacionLeyes;
	}
	;
	/*! Return the valuve of the component i of the state vector at the cell j */
	double GetU0(int i,										//!< Equation index
				 int j											//!< Cell index
				) {
		return FU0[i][j];
	}
	;

	/*! Return the heat transfer coefficient at cell i */

	double Gethi(int i											//!< Cell index
				) {
		return Fhi[i];
	}
	;

	/*! Return the external heat transfer coefficient at cell i */

	double Gethe(int i											//!< Cell index
				) {
		return Fhe[i];
	}
	;

	/*! Return the thermal proporties in layer i */

	stCapa GetCapa(int i) {
		return FCapa[i];
	}
	;

	/*! Return the type of monolith channel connected to the duct end */

	int GetTipoCanal(int i) {
		return FTipoCanal[i];
	}
	;

	void PutConcentric(double valor) {
		valor == 0 ? FConcentrico = false : FConcentrico = true;
	}
	;

//---------------------------------------------------------------------------
//          FUNCIONES PUBLICAS
//---------------------------------------------------------------------------

	/*! Contructor of the pipe class */
	TTubo(int SpeciesNumber, //!< Number of different species considered in the simulation.
		  int j,										//!< Index of the pipe
		  double SimulationDuration,								//!< Duration of the simulation. If there is not engine.
		  TBloqueMotor **Engine,			//!< Pointer to the engine object
		  nmTipoCalculoEspecies SpeciesModel,	//!< Type of species calculation
		  nmCalculoGamma GammaCalculation,	//!< Type of specific heat calculation
		  bool ThereIsEGR						//!< EGR specie is considered?
		 );

	/*! Destructor of the pipe class*/
	~TTubo();

	/*!Comment  */
	void LeeDatosGeneralesTubo(const char*FileWAM, 					//!< Comment
							   fpos_t&filepos 						//!< Comment
							  );

	/*!Comment  */
	void LeeDatosGeometricosTubo(const char* FileWAM,          //!< Comment
								 fpos_t& filepos,          //!< Comment
								 double ene,              //!< Comment
								 int tipomallado,      //!< Comment
								 TBloqueMotor ** Engine            //!< Comment
								);

	/*!Comment  */
	void IniciaVariablesFundamentalesTubo();

	/*!Comment  */
	void IniciaVariablesTransmisionCalor(TCondicionContorno ** BC,  //!< Comment
										 TBloqueMotor ** Engine,     //!< Comment
										 double AmbientTemperature        //!< Comment
										);

	/*!Comment  */
	void EstabilidadMetodoCalculo();

	/*!Comment  */
	void CalculaVariablesFundamentales();

	/*!Comment  */
	void ActualizaValoresNuevos(TCondicionContorno ** BC         //!< Comment
							   );

	/*!Comment  */
	void ReduccionFlujoSubsonico();

	/*!Comment  */
	void ReduccionFlujoSubsonicoFCT();

	/*!Comment  */
	void ReadAverageResultsTubo(const char* FileWAM,                //!< Comment
								fpos_t& filepos,                //!< Comment
								bool HayMotor                //!< Comment
							   );

	/*!Comment  */
	void HeaderAverageResults(std::stringstream& medoutput,        //!< Comment
							  stEspecies* DatosEspecies     //!< Comment
							 ) const;

	/*!Comment  */
	void ImprimeResultadosMedios(std::stringstream& medoutput       //!< Comment
								) const;

	/*!Comment  */
	void ReadInstantaneousResultsTubo(const char* FileWAM,          //!< Comment
									  fpos_t& filepos,                //!< Comment
									  bool HayMotor                //!< Comment
									 );

	/*!Comment  */
	void HeaderInstantaneousResults(std::stringstream& insoutput,   //!< Comment
									stEspecies* DatosEspecies     //!< Comment
								   ) const;

	/*!Comment  */
	void ImprimeResultadosInstantaneos(std::stringstream& insoutput //!< Comment
									  ) const;

	/*!Comment  */
	void CalculaResultadosMedios(double Theta            //!< Comment
								);

	/*!Comment  */
	void CalculaResultadosInstantaneos();

	/*!Comment  */
	void SalidaGeneralTubos(stEspecies* DatosEspecies      //!< Comment
						   ) const;

	/*!Comment  */
	void CalculaTemperaturaPared(TBloqueMotor ** Engine,     //!< Comment
								 double Theta,      //!< Comment
								 double CrankAngle,     //!< Comment
								 TCondicionContorno ** BC         //!< Comment
								);

	void CalculaTemperaturaParedSinMotor(TCondicionContorno **BC);

	/*!Comment  */
	void AjustaPaso(double Intervalo                //!< Comment
				   );

	/*!Comment  */
	void CalculaCaracteristicasExtremos(TCondicionContorno ** BC,   //!< Comment
										double DeltaTiempo //!< Comment
									   );

	/*!Comment  */
	double Interpola_Entropia(nmPipeEnd TipoExtremoTubo,    //!< Comment
							  double DeltaTiempo         //!< Comment
							 );

	/*!Comment  */
	double Interpola_Caracteristica(double entropia,                //!< Comment
									int signo,                    //!< Comment
									int extremo,                  //!< Comment
									double DeltaTiempo               //!< Comment
								   );

	/*!Comment  */
	void ComunicacionTubo_CC(TCondicionContorno ** BC         //!< Comment
							);

	/*!Comment  */
	void ComunicacionDPF(TCondicionContorno **CC,  //!< Comment
						 TDeposito **Deposito                        //!< Comment
						);

	/*!Comment  */
	void InicializaCaracteristicas(TCondicionContorno ** BC         //!< Comment
								  );

	/*!Comment  */
	void CalculaCoeficientePeliculaExterior(TBloqueMotor ** Engine, //!< Comment
											double AmbientPressure,             //!< Comment
											double AmbientTemperature              //!< Comment
										   );

	/*!Comment  */
	void CalculaResistenciasdePared(TCondicionContorno ** BC        //!< Comment
								   );

	/*!Comment  */
	void CalculaCoeficientePeliculaInterior(TCondicionContorno ** BC //!< Comment
										   );

	/*!Comment  */
	void ActualizaPropiedadesGas();

	/*! Return the value of the of the specie i mass fraction at cell j */
	double GetFraccionMasica(int j,								//!< Cell index
							 int i											//!< Specie index
							) {
		return FFraccionMasicaEspecie[j][i];
	}
	;
};

//---------------------------------------------------------------------------
#endif



================================================
FILE: Source/Act/act_def.h
================================================
/*--------------------------------------------------------------------------------*\
==========================|
 \\   /\ /\   // O pen     | OpenWAM: The Open Source 1D Gas-Dynamic Code
 \\ |  X  | //  W ave     |
 \\ \/_\/ //   A ction   | CMT-Motores Termicos / Universidad Politecnica Valencia
 \\/   \//    M odel    |
 ----------------------------------------------------------------------------------
 License

 This file is part of OpenWAM.

 OpenWAM is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 OpenWAM is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with OpenWAM.  If not, see <http://www.gnu.org/licenses/>.


 \*--------------------------------------------------------------------------------*/

/* Indices de las Variables de entrada escalares "fijas", es decir, que no cambian de ejecucion en ejecucion */

#define ACT_PISTON_D                0
#define ACT_S                       1
#define ACT_CRANK_L                 2
#define ACT_CONNECTING_ROD_L        3
#define ACT_E                       4
#define ACT_PISTON_AXIS_D           5
#define ACT_PISTON_CROWN_H          6
#define ACT_DBOWL                   7
#define ACT_VBOWL                   8
#define ACT_M_CONNECTING_ROD        9
#define ACT_M_P_R_PA                10
#define ACT_C_ESTEEL                11
#define ACT_C_MECH_DEFOR            12
#define ACT_C_MBLBY                 13
#define ACT_GCRATIO                 14
#define ACT_N_HOLES                 15
#define ACT_NOZZLE_D                16
#define ACT_DC                      17
#define ACT_CU                      18
#define ACT_WC1A                    19
#define ACT_WC1B                    20
#define ACT_C_W2                    21
#define ACT_IVC                     22
#define ACT_EVO                     23
#define ACT_K                       24

/* Indices de las Variables de entrada escalares que pueden variar en cada ejecucion */

#define ACT_CBB                     0
#define ACT_ATMOSPHERE_PRESS        1
#define ACT_TEMPERATUREIVC          2
#define ACT_SPEED                   3
#define ACT_SOI                     4
#define ACT_EOI                     5
#define ACT_MAIRIVC                 6
#define ACT_YO2IVC                  7
#define ACT_INJ_FUEL_TEMP           8
#define ACT_TCYL_HEAD               9
#define ACT_TCYL                    10
#define ACT_TPIS                    11

/* Indices de las Variables de Salida escalares */

#define ACT_IMP_HP                  0
#define ACT_PMAX                    1
#define ACT_TMAX                    2
#define ACT_P_EXIT                  3
#define ACT_T_EXIT                  4
#define ACT_DP_DA                   5

/* Indices de las Variables de Salida vectoriales */

#define ACT_P_CYL                   0
#define ACT_T_CYL                   1
#define ACT_HRF                     2
#define ACT_ROHR                    3
#define ACT_H_COOLER                4




================================================
FILE: Source/Act/ACT_Sub_DLL.h
================================================
// ---------------------------------------------------------------------------
#define cero 1.e-6
#define NR 17
#define ANG_CHORRO 60.   // Angulo de chorro.
//#include <vcl.h>
//#include <windows.h>

// ---------------------------------------------------------------------------

#pragma hdrstop
// #include "simstruc.h"
#pragma hdrstop
#include<stdio.h>
#include<math.h>
#include<string.h>
#include<stdlib.h>
#include<malloc.h>
//#include<conio.h>

// Fichero OCULTO

struct sINtype {
	double KSOOTC1;
};

struct sOUTtype {
	double species_EVO[8];
	double *evol_Soot;
	double *evol_Soot_CIL;
	double *evol_Radiacion;
	double *HRF_PMX;
	double *evol_LOL;
};

struct stRadArray {
	double x;
	double RFlame;
	double R;
	int np;
	double dr;
	double Ilambda;
	double Itot;
	double Xsoot[NR];
	double Tau[NR];
	double PTau[NR];
	double T[NR];
};

struct stControlElementComposition {
	int inj_number;
	int num_i;
	double mtotal;
	double mfuel;
	double mfuel_real;
	double mO2;
	double mO2_real;
	double mO;
	double mCH;
	double mCO2;
	double mH2O;
	double TSD;
	double Tadib;
	double dNOx;
	double mNOx;
	double mSOOT_B;
	double mSOOT_A;
	double mSOOT_C;
	double X;
	double FI;
};

/** ************     FUNCTIONS DECLARATION       ************** */

void FUNCTION_FOR_INTERPOLATION(double*interpolated, double*time_interpolated, double*CAD_to_interpolate,
								double*vector_to_interpolate, int size_interpolated, int size_to_interpolate, double speed);

void CALCULUS_OF_VIRTUAL_VELOCITY(double*inj_velocity, double*virtual_velocity, double*dmf, double*time_vector,

								  double rofuel, double dc, double n_holes, double nozzle_d, double D, int size, double PI, double speed, double*EOI_IM,
								  double inj_num, double*SOI_IM, double Piston_D, double DBowl, double CTM, double*CAD, double Kswirl);

void CALCULUS_OF_ACCUMULATED_INJ_RATE(double*acu_dmf, double*dmf, double*time_vector, int size);

void CALCULUS_OF_REACTION_STOICHIOMETRY(double*O2_mass_fuelunit, double*N2_mass_fuelunit, double*CO2_mass_fuelunit,
										double*H2O_mass_fuelunit, double HC);

void STOICHIOMETRY_CONSTANTS(double HC, double*Kst1, double*Kst2, double*Kst3, double*Kst4, double*Kst5, double*Kst6);

void CALCULUS_OF_NUMBER_ELEMENTS(int*num_i_IM, double*time_vector, int size, double speed, double*SOI_IM, double*EOI_IM,
								 int inj_num);

void CALCULUS_OF_POI(double**POI_IM, double**mfuel_i_IM, double**mfuel_ij_IM, double*acu_dmf, double*time_vector,
					 int size, double speed, int*num_i_IM, int num_j, double*SOI_IM, double*EOI_IM, int inj_num,
					 stControlElementComposition * *elementcontrol);

double VOLUME(double CAD, double VTDC, double PI, double Piston_D, double Crank_L, double Connecting_Rod_L, double E);

void CALCULATE_CYCLE(double*roair, double*CAD, double delta_t, double*V_cyl, double VTDC, int counter, double speed,
					 double*p_cyl, double*HRF, double*acu_dmf, double*Mbb, double*acu_Mbb, double AFe, double f, double mfuel, double mEGR,
					 double mairIVC, double*T_cyl, double HP, double*Yair, double*Yfuel, double*Yburned, double*U, double*CV,
					 double*H_cooler, double*H, double TEB, double inj_fuel_temp, double PRECITERACIONES, double*defor, double*Rmixture,
					 double Atmosphere_press, double*Gamma, double PI, double Runiv, double Piston_D, double S, double Crank_L,
					 double Connecting_Rod_L, double E, double Piston_Axis_D, double Piston_Crown_H, double DBowl, double VBowl,
					 double M_Connecting_Rod, double M_P_R_PA, double MW_air, double MW_fuel, double MW_burned, double C_ESteel,
					 double C_Mech_Defor, double CTM, double WC1A, double WC1B, double C2, double C_MBLBY, double Cbb, double TPIS,
					 double TCYL_HEAD, double TCYL, double*Qcylhead, double*Qcyl, double*Qpis);

void DEFORMATIONS(double*V_cyl, double*DEFOR, double p_cyl, double CAD, double delta_CAD, double speed, double PI,
				  double Piston_D, double S, double Connecting_Rod_L, double E, double Piston_Axis_D, double Piston_Crown_H,
				  double M_Connecting_Rod, double M_P_R_PA, double C_ESteel, double C_Mech_Defor);

void MASIC_RATIO(double*Yair, double*Yfuel, double*Yburned, double*Rmixture, double HRF, double acu_mf, double acu_Mbb,
				 double AFe, double f, double mfuel, double mEGR, double mairIVC, double Runiv, double MW_air, double MW_fuel,
				 double MW_burned);

void PROPERTIES(double*u, double*CV, double T_cyl, double T_cyl_pre, double Yair, double Yfuel, double Yburned);

void PROPERTIES_FUEL(double*uf, double T_cyl);

double HEAT_COOLER(double p_cyl, double pressureIVC, double T_cyl, double temperatureIVC, double average_Volume,
				   double volumeIVC, double delta_CAD, double speed, double VTDC, double*H, double PI, double Piston_D, double S,
				   double DBowl, double VBowl, double CTM, double WC1A, double WC1B, double C2, double TPIS, double TCYL_HEAD, double TCYL,
				   double CAD, double*Qcylhead, double*Qcyl, double*Qpis, int counter);

double CALCULATE_C1(double cm, double CTM, double WC1A, double WC1B, double Piston_D, double DBowl, double speed,
					double CAD, double PI);

double BLOW_BY(double p_cyl, double T_cyl, double Rmixture, double delta_CAD, double speed, double Gamma,
			   double Atmosphere_press, double Piston_D, double C_MBLBY, double Cbb);

void CALCULATE_AREAS(double*Piston_area, double*Cylinder_head_area, double PI, double Piston_D, double DBowl,
					 double VBowl);

void CALCULUS_OF_MEAN_VARIABLES(double*p_cyl, double*T_cyl, double*dp_da_cyl, double*CAD, double*pmax, double*Tmax,
								double*dp_da_max, double*p_exit, double*T_exit, int size);

void CALCULUS_OF_IMP_HP(double*complete_p_cyl, double*complete_CAD, double*p_cyl, double*V_cyl, double*complete_V_cyl,
						double*complete_deform, double*WI_HP, double*IMP_HP, int complete_size, int complete_prev_size, double delta_t,
						double speed, int size, double IVC, double EVO, double VTDC, double Cylinder_capacity, double PI, double Piston_D,
						double S, double Crank_L, double Connecting_Rod_L, double E, double Piston_Axis_D, double Piston_Crown_H,
						double M_Connecting_Rod, double M_P_R_PA, double C_ESteel, double C_Mech_Defor, double inlet_pres, double exhaust_pres);

void FUNCTION_NOX(double*YNOeq_value, double*KdYNO_value, double**YNOeq, double**KdYNO, double temperature, double mO2,
				  double mtotal);

void FUNCTION_SOOT_C(double*soot_pre, double element_FI);

double min(double a, double b);

double YSoot_to_FSN(double YSoot);

void ACT(double*engine_parameters, double*engine_model_constants, double*test_variables, double*injection_rate,
		 double*CAD_injection_rate, int size_inlet_inj, int NIN, double*SOI, double*EOI, int CAI, double*CAD_exit,
		 double*HRF_exit, double*ROHR_exit, double*p_cyl_exit, double*dp_da_cyl_exit, double*T_cyl_exit, double*H_cooler_exit,
		 double*mean_var_exit, double*heat_transfer, double*injection_rate_exit, double*accum_injection_rate_exit,
		 sINtype dataIN, sOUTtype * dataOUT);

#pragma argsused



================================================
FILE: Source/Act/CMakeLists.txt
================================================
add_library(
  Act
  ACT_Sub_DLL.cpp
  INJECTION_RATE.cpp)



================================================
FILE: Source/Act/INJECTION_RATE.cpp
================================================
#pragma hdrstop
// #include "simstruc.h"
#pragma hdrstop
#include<cstdio>
#include<cmath>
#include<string.h>
#include<stdlib.h>
#include<malloc.h>
// #include<conio.h>

using namespace std;

/** ************     FUNCTIONS DECLARATION       ************** */

extern "C" void CALCULUS_OF_INJECTION_RATE(int INITIAL, double*SOP, double*MFI, double*SOI, double*EOI, double speed,
		int CAI, double PCR, double*A, double*B, double*C, double*D, double*injection_rate, double*CAD_injection_rate);

/** ************     MAIN FUNCTION       ************* */

#pragma argsused
// int main(int argc,char **argv)
// {
//
// int counter,test_number,z,p,size_inlet_inj;
// int aux = 0;
// int CAI = 0;                                 /* vectors point number according to crank angle degree  */
// FILE *fich;
//
// char title[3000];
//
//
//
// int *INITIAL;
// double *A;
// double *B;
// double *C;
// double *D;
// double *PCR;
// double *speed;
// double **SOP;
// double **SOI;
// double **EOI;
// double **MFI;
// double PMI_hp = 0.;
//
// double **test_variables;
//
// double **injection_rate;
// double **CAD_injection_rate;
//
//
//
// CAI=1801;
// size_inlet_inj=CAI;
// test_number=1;
// z=0;
//
////instrucction to dimensionate main vectors
//
//
// PCR=(double *)malloc(test_number*sizeof(double ));
// speed=(double *)malloc(test_number*sizeof(double ));
// INITIAL=(int *)malloc(test_number*sizeof(int ));
//
// A=(double *)malloc(2*sizeof(double ));
// B=(double *)malloc(2*sizeof(double ));
// C=(double *)malloc(2*sizeof(double ));
// D=(double *)malloc(2*sizeof(double ));
//
// SOP=(double **)malloc(test_number*sizeof(double ));
// for (z=0;z<test_number;z++){
// SOP[z]=(double *)malloc(8*sizeof(double ));
// }
//
// SOI=(double **)malloc(test_number*sizeof(double ));
// for (z=0;z<test_number;z++){
// SOI[z]=(double *)malloc(8*sizeof(double ));
// }
// EOI=(double **)malloc(test_number*sizeof(double ));
// for (z=0;z<test_number;z++){
// EOI[z]=(double *)malloc(8*sizeof(double ));
// }
// MFI=(double **)malloc(test_number*sizeof(double ));
// for (z=0;z<test_number;z++){
// MFI[z]=(double *)malloc(8*sizeof(double ));
// }
//
// test_variables=(double **)malloc(test_number*sizeof(double ));
// for (z=0;z<test_number;z++){
// test_variables[z]=(double *)malloc(18*sizeof(double ));
// }
//
//
//
// //the injecition rate law is created with a function
//
// if((fich=fopen("injection_system_parameters.dat","r"))==NULL){
// printf("The file of average variables could not be open.\n");
// }
//
// fscanf(fich, "%s",title);
// fscanf(fich, "%lf,%lf,%lf,%lf,%lf,%lf,%lf,%lf",&A[0],&A[1],&B[0],&B[1],&C[0],&C[1],&D[0],&D[1]);
// fclose(fich);
//
//
//
// INITIAL[0]=0;
//
// if((fich=fopen("injection_parameters.dat","r"))==NULL){
// printf("The file of average variables could not be open.\n");
// }
//
// fscanf(fich, "%s",title);
// for (p=0;p<8;p++){
// fscanf(fich, "%d,%lf,%lf,%lf",aux,&SOP[0][p],&MFI[0][p],&PMI_hp);
//
// if(MFI[0][p]>0){
// INITIAL[0]=INITIAL[0]+1;
// }
//
// }
// fclose(fich);
//
//
// if((fich=fopen("test_variables.dat","r"))==NULL){
// printf("The file of average variables could not be open.\n");
// return 0;
// }
// fscanf(fich, "%s",title);
//
// for(p=0;p<18;p++){
// fscanf(fich, "%lf,",&test_variables[0][p]);
// }
//
// fclose(fich);
//
// speed[0]=test_variables[0][0];
// PCR[0]=test_variables[0][5];
//
//
// injection_rate=(double **)malloc(test_number*sizeof(double ));
// for (z=0;z<test_number;z++){
// injection_rate[z]=(double *)malloc(CAI*sizeof(double ));
// }
//
// CAD_injection_rate=(double **)malloc(test_number*sizeof(double ));
// for (z=0;z<test_number;z++){
// CAD_injection_rate[z]=(double *)malloc(CAI*sizeof(double ));
// }
//
// //initializes injection rate angle
// for (z=0;z<test_number;z++){
// CAD_injection_rate[z][0]=-180;
// for(int counter=1;counter<CAI;counter++){
// CAD_injection_rate[z][counter]=CAD_injection_rate[z][counter-1]+((360./(CAI-1)));
// }
// }
//
// for (z=0;z<test_number;z++){
//
// CALCULUS_OF_INJECTION_RATE(INITIAL[z],SOP[z],MFI[z],SOI[z],EOI[z],speed[z],CAI,
// PCR[z],A,B,C,D,injection_rate[z],CAD_injection_rate[z]);
//
// }
//
//
//
// if((fich=fopen("injection_rate.dat","w"))==NULL){
// printf("The element file results could not be opened");
// exit(1);
// }
// strcpy(title,"CAD,IR");
//
// fprintf(fich, "%s", title);
// for(p=0;p<CAI;p++){
// fprintf(fich, "\n%lf,",CAD_injection_rate[0][p]);
// for(z=0;z<test_number;z++){
// fprintf(fich, "%lf",injection_rate[z][p]);
// }
// }
// fclose(fich);
//
// if((fich=fopen("injection_rate_parameters.dat","w"))==NULL){
// printf("The element file results could not be opened");
// exit(1);
// }
// strcpy(title,"INITIAL,SOI1,EOI1,SOI2,EOI2,SOI3,EOI3,SOI4,EOI4,SOI5,EOI5,SOI6,EOI6,SOI7,EOI7,SOI8,EOI8");
//
// fprintf(fich, "%s", title);
//
// fprintf(fich, "\n%d",INITIAL[0]);
// for(p=0;p<8;p++){
// fprintf(fich, ",%lf,%lf",SOI[0][p],EOI[0][p]);
// }
//
// fclose(fich);
//
////memory liberation
// free(PCR);
// free(INITIAL);
// free(A);
// free(B);
// free(C);
// free(D);
//
//
// for(z=0;z<test_number;z++)free(SOP[z]);
// free(SOP);
// for(z=0;z<test_number;z++)free(SOI[z]);
// free(SOI);
// for(z=0;z<test_number;z++)free(EOI[z]);
// free(EOI);
// for(z=0;z<test_number;z++)free(MFI[z]);
// free(MFI);
//
// for(z=0;z<test_number;z++)free(test_variables[z]);
// free(test_variables);
//
// for (z=0;z<test_number;z++)free(injection_rate[z]);
// free(injection_rate);
// for (z=0;z<test_number;z++)free(CAD_injection_rate[z]);
// free(CAD_injection_rate);
//
//
// }

inline void CALCULUS_OF_INJECTION_RATE(int INITIAL, double *SOP, double *MFI, double *SOI, double *EOI, double speed,
									   int CAI, double PCR, double *A, double *B, double *C, double *D, double *injection_rate, double *CAD_injection_rate)

{

	int k = 0;
	// initialize injection rate
	injection_rate[0] = 0.;
	for(k = 1; k < CAI; k++) {
		injection_rate[k] = 0.;
	}

	double a = (A[1] * PCR + A[0]) * 1e3;
	double b = (B[1] * PCR + B[0]) * 1e3;
	double c = (C[1] * PCR + C[0]) * 1e3;

	// definition of injection rate for each injection

	double mftopemini = 1. / 2. * ((b / a) + (b / -c)) * b;
	double time = 0.;

	for(int j = 0; j < INITIAL; j++) {

		SOI[j] = SOP[j] + (D[1] * PCR + D[0]) * (6 * speed);

		// calculates total fuel mass injected

		if(MFI[j] >= mftopemini) {
			double DLM = (MFI[j] - mftopemini) / b;
			for(int k = 0; k < CAI; k++) {
				// time between SOI and actual point
				time = (CAD_injection_rate[k] - SOI[j]) / (6 * speed);
				// calculates injection rate
				if(time > 0. && time <= b / a)
					injection_rate[k] = time * a;
				else if(time > b / a && time <= b / a + DLM)
					injection_rate[k] = b;
				else if(time > b / a + DLM && time <= b / a + DLM + b / -c)
					injection_rate[k] = b + ((time - b / a - DLM) * c);
			}
			// calculates end of injection
			EOI[j] = SOI[j] + (b / a + DLM + b / -c) * 6 * speed;
		} else {
			double levmaxi = sqrt((2. * MFI[j]) / (1. / a + 1. / -c));
			double DTL = levmaxi / a;
			double DTB = levmaxi / -c;
			for(int k = 0; k < CAI; k++) {
				// time between SOI and actual point
				time = (CAD_injection_rate[k] - SOI[j]) / (6 * speed);
				if(time > 0. && time <= DTL)
					injection_rate[k] = time * a;
				else if(time > DTL && time <= DTL + DTB)
					injection_rate[k] = levmaxi + (time - DTL) * c;
			}
			// calculates end of injection
			EOI[j] = SOI[j] + (DTL + DTB) * 6 * speed;
		}
	}

	// converts mg/s to g/s
	for(int k = 0; k < CAI; k++) {
		injection_rate[k] /= 1000.;
	}

}



================================================
FILE: Source/Boundaries/BoundaryFunctions.cpp
================================================
/*--------------------------------------------------------------------------------*\
==========================|
 \\   /\ /\   // O pen     | OpenWAM: The Open Source 1D Gas-Dynamic Code
 \\ |  X  | //  W ave     |
 \\ \/_\/ //   A ction   | CMT-Motores Termicos / Universidad Politecnica Valencia
 \\/   \//    M odel    |
 ----------------------------------------------------------------------------------
 License

 This file is part of OpenWAM.

 OpenWAM is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 OpenWAM is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with OpenWAM.  If not, see <http://www.gnu.org/licenses/>.


 \*--------------------------------------------------------------------------------*/

//---------------------------------------------------------------------------
#pragma hdrstop

#include "BoundaryFunctions.h"

//---------------------------------------------------------------------------

#pragma package(smart_init)



================================================
FILE: Source/Boundaries/BoundaryFunctions.h
================================================
/* --------------------------------------------------------------------------------*\
==========================|
 \\   /\ /\   // O pen     | OpenWAM: The Open Source 1D Gas-Dynamic Code
 \\ |  X  | //  W ave     |
 \\ \/_\/ //   A ction   | CMT-Motores Termicos / Universidad Politecnica Valencia
 \\/   \//    M odel    |
 ----------------------------------------------------------------------------------
 License

 This file is part of OpenWAM.

 OpenWAM is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 OpenWAM is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with OpenWAM.  If not, see <http://www.gnu.org/licenses/>.


 \*-------------------------------------------------------------------------------- */

// ---------------------------------------------------------------------------
#ifndef BoundaryFunctionsH
#define BoundaryFunctionsH

//#include "roots.h"
// #include "Math_wam.h"
#include "Globales.h"
// ---------------------------------------------------------------------------

struct stFESub {
	double AA;
	double Ad;
	double Gam;
	double K;
	double BC;
	double Ga3;

	double U2;
	double U2_2;
	double AdAA;
	double invAdAA;

	stFESub(const double iAA, const double iAd, const double ig, const double iK, const double iCC) :
		AA(iAA), Ad(iAd), Gam(ig), K(iK), BC(iCC) {
		Ga3 = (Gam - 1) / 2;
		AdAA = Ad * AA;
		invAdAA = 1 / AdAA;
	}
	;

	double operator()(const double A2) {
		double xx = A2 * invAdAA;
		double yy = pow(xx, 2 / Ga3);
		yy = pow2(K) * yy - 1.;
		U2_2 = 0;
		if(xx > 1)
			U2_2 = AdAA * sqrt((pow2(xx) - 1.) / (yy * Ga3)); // Valor absoluto
		U2 = (BC - A2) / Ga3;
		return U2_2 - U2;
	}
};

struct stFESup {
	double Gam;
	double K;
	double Ga3;
	double Ga8;
	double Ga9;

	stFESup(const double ig, const double iK) :
		Gam(ig), K(iK) {
		Ga3 = (Gam - 1) / 2;
		Ga8 = (Gam + 1) / 2;
		Ga9 = (Gam - 1) / Ga8;
	}
	;

	double operator()(const double M) {

		double yy = Ga8 * pow(K * M, Ga9);
		double xx = Ga3 * pow2(M);
		return xx - yy + 1.;
	}
};

struct stFSSub {
	double AA;
	double Ad;
	double Gam;
	double K;
	double BC;
	double Ga3;
	double Ac;

	double U2;
	double invAdAA;
	double pow2Ac;

	stFSSub(const double iAA, const double iAd, const double ig, const double iK, const double iCC, const double iAc) :
		AA(iAA), Ad(iAd), Ac(iAc), Gam(ig), K(iK), BC(iCC) {
		Ga3 = (Gam - 1) / 2;
		invAdAA = 1 / (AA * Ad);
		pow2Ac = pow2(Ac);
	}
	;

	double operator()(const double A2) {
		U2 = 0;
		if(pow2Ac > pow2(A2)) {
			U2 = sqrt((pow2Ac - pow2(A2)) / Ga3);
		}
		double A1 = Ac * (BC + Ga3 * U2) * invAdAA;
		double U1 = K * U2 * pow2(A1 / A2);
		return pow2(A1) + Ga3 * pow2(U1) - pow2Ac;
	}
};

struct stFSSup {
	double AA;
	double Fcc;
	double Gam;
	double K;
	double BC;
	double Ga3;
	double Ac;

	double A2;
	double invAA;
	double invFcc;

	stFSSup(const double iAA, const double iFcc, const double ig, const double iK, const double iCC, const double iAc) :
		AA(iAA), Ac(iAc), Gam(ig), K(iK), BC(iCC), Fcc(iFcc) {
		Ga3 = (Gam - 1) / 2;
		invAA = 1 / AA;
		invFcc = 1 / Fcc;

	}
	;

	double operator()(const double U2) {

		double dif = pow2(Ac) - Ga3 * pow2(U2);
		if(dif > 0) {
			A2 = sqrt(dif);
		} else {
			A2 = 0;
		}
		//A2 = sqrt(pow2(Ac) - Ga3 * pow2(U2));
		double A2_2 = sqrt(U2 * pow((BC + Ga3 * U2) * invAA, Gam / Ga3) * invFcc);

		return A2 - A2_2;
	}
};

struct stRecover {

	double AA;
	double Ad;
	double Gam;
	double CR;
	double BC;
	double Ga3;

	double A2_2;
	double U2;
	double UThroat;
	double A1;
	double invAdAA;

	stRecover(const double iAA, const double iAd, const double ig, const double iCR, const double iCC) :
		AA(iAA), Ad(iAd), Gam(ig), CR(iCR), BC(iCC) {
		Ga3 = (Gam - 1) / 2;
		invAdAA = 1 / (Ad * AA);
	}
	;

	double operator()(double A2) {
		U2 = (BC - A2) / Ga3;
		double Ga3U22 = Ga3 * pow2(U2);
		double Adep1 = sqrt(pow2(A2) + Ga3U22);
		A1 = A2 * Adep1 * invAdAA;
		UThroat = U2 * CR * pow2(A1 / A2);
		double Adep2 = sqrt(pow2(A1) + Ga3 * pow2(UThroat));
		A2_2 = sqrt(pow2(Adep2) - Ga3U22);
		return A2 - A2_2;
	}
};
/* NUEVO- PROGRAMACION DE LAS EXPRESIONES NECESARIAS PARA
 EL METODO DE BRENT:
 - Union Tubos: Ensanchamiento -	Estrechamiento
 - Compressor Volumetrico
 - Perdida de presion adiabatica
 */

/* Wider in cross section */
struct stExpansion {

	/* !Definicion de las VARIABLES LOCALES */
	/*Variables locales que almacenaran la inforamcion pasada por funcion */

	double CCS; // Variable local asociada a la caracteristica conocida en 1 (salida del tubo) y que se pasa por funcion//
	double CCE; // Variable l.a. a la caracteristica conocida en 2, entrada al tubo//
	double Gam; // Variable l.a. al Gamma pasado por funcion//
	double rel_area; // Variable l.a. a la relacion de area pasada por funcion//
	double rel_entropia; // Variable l.a. a la relacion de entropia pasada por funcion//

	/* Variables locales internas, si no se quiere acceder despues a la
	 informacion que contienen, es preferible definirlas directamente dentro del
	 operador */

	double U1; // V.L para la velocidad del fluido en 1 (SALIENTE del tubo//
	double U2; // V.L para la velocidad del fluido en 2 (ENTRANTE al deposito//
	double A2; // V.L para la velocidad del sonido en 2//
	double xx3; // V.L para la velocidad del sonido, hara falta en el calculo de las caracteristicas//
	double Ga2; // Es necesario definirlo aqui, ya que se utiliza en el operador//
	double Ga3; // idem que Ga2//

	/* CONSTRUCTOR de la funcion, aqui se recibe por orden la informacion pasada por
	 funcion y se almacena en las variables locales */

	stExpansion(const double iCCS, const double iCCE, const double R_E, const double R_A, const double iGam) :
		CCS(iCCS), CCE(iCCE), rel_entropia(R_E), rel_area(R_A), Gam(iGam) {
		Ga3 = (Gam - 1) / 2;
		/* Definicion de aquellas variables internas que se usaran en el operador, pero que no se requiere su acceso, aqui o dentro del operador */
		Ga2 = Gam + 1;
	}

	double operator()(const double A1) { // A1 es la velocidad del sonido en 1 es LA VARIABLE DE LA FUNCION//

		U1 = (CCS - A1) / Ga3; // Calculo de la velocidad del fluido en 1 mediante la ecuacion 4.291//
		double xx1 = pow2(A1) + Ga3 * pow2(U1);
		double xx2 = rel_area * pow2(A1) + Gam * pow2(U1);
		if(fabs(U1 - A1) < 1e-15) {
			if(Ga2 / (Gam + rel_area) >= 1) {
				U2 = (xx2 / (Ga2 * U1));
			} else {
				U2 = (xx2 / (Ga2 * U1)) * (1 - sqrt(1 - pow2(Ga2 / (Gam + rel_area))));
			}
		} else {
			if((xx1 * 2. * Ga2 * (pow2(U1) / pow2(xx2))) >= 1) {
				U2 = xx2 / Ga2;
			} else {
				U2 = xx2 * (1 - sqrt(1. - (xx1 * 2. * Ga2 * (pow2(U1) / pow2(xx2))))) / Ga2;
			}

			if(U1 == 0) {
				U2 = 0;
			} else {
				U2 = U2 / U1;
			}
		}
		A2 = sqrt(xx1 - Ga3 * pow2(U2));
		xx3 = CCE + Ga3 * U2; // Velocity del sonido corregida, hara falta en el calculo de las caracteristicas//
		double xx = pow(rel_entropia * xx3, Gam);
		double xtx = (pow2(A2) + Gam * pow2(U2)) / (((Gam * pow2(U1)) / rel_area + pow2(A1)) * pow2(A2));
		xtx = pow(xtx, Ga3);
		double A1p = xx * xtx;

		return A1 - A1p;
	}
};
/* ! Reduction in cross section */

struct stContraction {

	/* Definicion de variables locales */
	/* Variables locales para almacenar la informacion pasada por funcion */

	double CCS; // Variable local asociada a la caracteristica incidente conocida en 1, pasada por funcion//
	double CCE; // Variable l.a a la caracteristica conocida en 2 inicial, pasada por funcion//
	double rel_entropia; // Variable l.a a la relacion de entropia pasada por funcion//
	double rel_area; // Variable l.a a la relacion de area, pasada por funcion//
	double Gam; // Variable l.a a gamma, pasado por funcion//

	/* Variables locales internas, que permitiran el acceso. Si no se requiere acceso
	 es mejor definirlas directamente dentro del operador */

	double A1; // Variable local para la velocidad del sonido en 1//
	double A2; // Variable local para la velocidad del sonido en 2//
	double U2; // Variable local para la velocidad del flujo en 2//
	double Ga1;
	double Ga3;

	/* CONSTRUCTOR: Se recibe la informacion por funcion en variables ficticias y se
	 almacena en las variables locales */

	stContraction(const double iCCS, const double iCCE, const double R_E, const double R_A, const double iGam) :
		CCS(iCCS), CCE(iCCE), rel_entropia(R_E), rel_area(R_A), Gam(iGam) {
		Ga3 = (Gam - 1) / 2;
		Ga1 = (Gam - 1);
	}

	double operator()(const double U1) { // U1 es la velocidad del fluido en 1, es la variable a iterar de la funcion//

		A1 = CCS - Ga3 * U1; // Calculo de A1 por la ecuacion 4.315//
		double xx1 = rel_entropia * 4. * CCE / Ga1; // Variable auxiliar para el calculo de A2//
		double xx2 = pow2(rel_entropia) / Ga3 + 1.; // Variable auxiliar para el calculo de A2//
		double xx3 = pow2(CCE) / Ga3 - Ga3 * pow2(U1) - pow2(A1);
		// Variable auxiliar para el calculo de A2//
		double b = pow2(xx1) - xx2 * 4. * xx3;
		if(b < 0) {  /* Adaptacion del metodo para este caso problematico */
			A2 = xx1 / (2 * xx2);
		} else {
			A2 = (xx1 + sqrt(b)) / (2. * xx2); // Calculo de A2 segun la ec. 4.316, si el //
		}
		/* Si el flujo es supersonico en la seccion 1 (diametro mayor) peta el metodo de Brent peta al calcular el valor en el extremo
		 derecho, debido a que sale una raiz negativa. Probar entonces una condicion que bloquee en este caso el calculo de la raiz
		 (pero solo para el calculo de la funcion en el extremo). Por ejemplo A2=xx1/2*xx2. YA VEREMOS QUE PASA, SI CONVERGE O SIGUE PETANDO
		 ENTONCES SERIA FLUJO SUPERSONICO */

		U2 = (A2 * rel_entropia - CCE) / Ga3; // Calculo de U2 segun ec.4.317//
		double U1p = A1 / A2; // Variable auxiliar para el calculo de U1p//
		double xx = 1. / Ga3; // Variable auxiliar para el calculo de U1p//
		U1p = rel_area * U2 / pow(U1p, xx); // Nuevo valor de la velocidad del flujo U1, segun la ec.4.318//

		return U1 - U1p;
	}
};

/* Adiabatic loss pressure */

struct stPerdPresAd {

	/* Definir las variables locales donde se almacenara la informacion que se pase
	 desde el programa y que son necesarias para el calculo de la condicion de contorno.
	 Son variables de tipo double */

	// VARIABLES ALMACENAMIENTO DE VARIABLES QUE SE PASARAN//
	double CC1; // Variable local asociada a la caracteristica incidente del extremo 1 pasada por funcion//
	double CC2; // Variable l.a. a la caracteristica incidente del extremo 2 pasada por funcion//
	double FK; // Variable l.a. al parametro K pasado por funcion//
	double Gam; // Variable l.a. a Gamma pasado por funcion//
	double FRE; // Variable l.a. a la relacion de entropia que se pasa por funcion//

	// VARIABLES INTERNAS//
	double U1; // Variable local para almacenar la velocidad del fluido en 1//
	double U2; // Variable local para almacenar la velocidad del fluido en 2//
	double A2; // Variable local para almacenar la velocidad del sonido en 2//
	double A1p; // Variable local para almacenar el valor calculado de A1 segun 4.256//
	double xx3;
	double Ga3;
	double Ga5;

	/* Constructor de la funcion. Aqui se RECIBEN las variables necesarias para el calculo
	 y que han sido enviadas desde el programa, el nombre de cabecera es ficticio, la
	 informacion se almacena por posicion. En el lado derecho se asocia a cada variable
	 local el valor de la variable pasada por funcion */

	stPerdPresAd(const double iCC1, const double iCC2, const double iFK, const double iGam, const double iFRE) :
		CC1(iCC1), CC2(iCC2), FK(iFK), Gam(iGam), FRE(iFRE) {
		Ga3 = (Gam - 1) / 2;
		Ga5 = (Gam - 1) / 2 / Gam;
	}

	double operator()(const double A1) { // A1 es la variable incognita de la funcion, es decir sobre la que se itera//

		U1 = (CC1 - A1) / Ga3; // ecuacion 4.246//
		double a = Ga3;
		double b1 = -FK * pow2(U1) / pow2(A1) + 1.;
		double b = pow2(A1) * b1;
		double c = -(pow2(A1) + Ga3 * pow2(U1)) * pow2(U1);
		double u2u1 = (sqrt(pow2(b) - 4. * a * c) - b) / (2. * a); // ec. 252//
		if(U1 == 0.) {
			U2 = 0.; // ec.253//
		} else { // ec.254//
			U2 = u2u1 / U1;
		}

		A2 = sqrt(pow2(A1) + Ga3 * (pow2(U1) - pow2(U2))); // ec.255//

		xx3 = CC2 + Ga3 * U2;
		A1p = xx3 * FRE * pow(b1, -Ga5); // ec.4.256, CUIDADO QUE HAY UN SIGNO MENOS EN EL EXPONENTE//

		return A1p - A1;
	}
};

struct stPerdPresAdL {

	double CC1; // Variable local asociada a la caracteristica incidente del extremo 1 pasada por funcion//
	double CC2; // Variable l.a. a la caracteristica incidente del extremo 2 pasada por funcion//
	double FK; // Variable l.a. al parametro K pasado por funcion//
	double Gam; // Variable l.a. a Gamma pasado por funcion//
	double FRE; // Variable l.a. a la relacion de entropia que se pasa por funcion//
	double ARef; // Variable l.a. a la velocidad del sonido de referencia //
	double ei;
	double ed;

	double U1; // Variable local para almacenar la velocidad del fluido en 1//
	double U2; // Variable local para almacenar la velocidad del fluido en 2//
	double A2; // Variable local para almacenar la velocidad del sonido en 2//
	double A1p; // Variable local para almacenar el valor calculado de A1 segun 4.256//
	double xx3;
	double Ga3;
	double Ga5;

	stPerdPresAdL(const double iCC1, const double iCC2, const double iFK, const double iGam, const double iFRE,
				  const double iARef) :
		CC1(iCC1), CC2(iCC2), FK(iFK), Gam(iGam), FRE(iFRE), ARef(iARef) {
		Ga3 = (Gam - 1) / 2;
		Ga5 = (Gam - 1) / 2 / Gam;
	}

	double operator()(const double A1) {

		U1 = (CC1 - A1) / Ga3; // Calculo de la velocidad  saliente.//
		double b1 = -FK * fabs(U1) / pow2(A1) + 1.;
		b1 += 1e-14; // Resolucion ecuacion de 2 grado y calculo de la velocidad entrante.OJO que he cambiado la formula.Pedro.//
		// Resolucion ecuacion de 2 grado y calculo de la velocidad entrante.//
		double a = Ga3;
		double b = b1 * pow2(A1);
		double c = -(pow2(A1) + Ga3 * pow2(U1)) * pow2(U1);
		double u2u1 = QuadraticEqP(a, b, c);
		if(U1 == 0.) {
			U2 = 0.;
		} else {
			U2 = u2u1 / U1;
		}
		A2 = sqrt(pow2(A1) + Ga3 * (pow2(U1) - pow2(U2)));
		// Calculo de la velocidad del sonido entrante.

		xx3 = CC2 + U2 * Ga3;

		A1p = xx3 * FRE / pow(b1, Ga5);

		return A1p - A1;
	}
};

/* ! Volumetric Compressor */

struct stComprVol {

	/* Definicion de las variables locales (pueden tomar cualquier nombre)
	 y que almacenaran la informacion de las variables pasadas a la funcion
	 desde el programa, LA INFORMACION SE ASOCIARA EN EL CONSTRUCTOR. AQUI
	 SOLO SE ESTAN DEFINIENDO */

	/* PASO POR EL CONSTRUCTOR __cons::ARef y PRef para evitar incluir la libreria globales */

	double AA; // Variable local asociada al nivel de entropia inicial pasado por la funcion//
	double BC; // Variable l.a a la caracteristica incidente inicial pasada por la funcion //
	double Gam; // Variable l.a al gamma pasado por la funcion//
	double A; // Variable l.a a la velocidad del sonido pasada por la funcion//
	double Gasto_calculado; // Variable l.a al massflow calculado por (4.113) y pasado por la funcion//
	double F; // Variable l.a a la seccion del tubo y pasado por funcion//
	double PRef; // Variable l.a a la presion de referencia y que se ha pasado por funcion y asi evitar incluir la libreria globales//
	double ARef; // Variable l.a a la velocidad del sonido de referencia con idem justificacion que PRef//

	double Ga3; // Variable local//
	double Ga4; // Variable local//
	double entropia; // Variable local para la entropia//
	// double Gasto_supuesto;    //Variable local para el massflow supueso//
	double CD; // Variable local//
	double U;

	/* CONSTRUCTOR: Aqui se RECIBEN las VARIABLES PASADAS con un nombre ficticio
	 parecido al de la definicio de las variables locales (por ejemplo precedido de i)
	 EN EL LADO IZQUIERDO (variables recibidas) : EN EL LADO DERECHO (informacion almacenada)
	 y que son necesarias para el calculo del operador (tipo de variable y nombre ficticio) y a continuacion
	 SE ASOCIAN a las variables locales que almacenaran la informacion pasada */

	stComprVol(const double iAA, const double iCC, const double iGam, const double iA, const double iGS, const double iF,
			   const double iPRef, const double iARef) :
		AA(iAA), BC(iCC), Gam(iGam), A(iA), Gasto_calculado(iGS), F(iF), PRef(iPRef), ARef(iARef) {
		Ga3 = (Gam - 1) / 2;
		Ga4 = 2 * Gam / (Gam - 1);
		CD = 1;
	}
	;

	double operator()(const double Vel) {
		double entropia = A * AA / (BC + Ga3 * Vel);
		U = Gasto_calculado * pow(entropia, Ga4) / (CD * Gam * F * __units::BarToPa(PRef) / ARef * pow(A, 1 / Ga3));

		return U - Vel;
	}

};

struct stNewCompressorConditions {
	double Mass;
	double A01;
	double AA1;
	double Section;
	double Lambda;
	double Gam;
	double Ga3;
	double Eff;

	stNewCompressorConditions(const double iMass, const double iCC, const double T01, const double P01, const double iEff,
							  const double iGam, const double R, const double Sec) :
		Mass(iMass), Lambda(iCC), Gam(iGam), Section(Sec), Eff(iEff) {
		A01 = sqrt(Gam * R * T01);
		AA1 = A01 * pow(P01, (1 - Gam) / 2 / Gam);
		Ga3 = (Gam - 1) / 2;
	}

	double operator()(const double Match) {

		double A2 = Lambda / (1 - Ga3 * Match);
		double k = pow2(A2) * (1 + Ga3 * Match * Match) / (A01 * A01) - 1;
		double AA2 = AA1 * sqrt(1 + k) / (k * Eff + 1);
		double Match2 = Mass / (Gam * pow(A2 / pow(AA2, Gam), 1 / Ga3) * A2 * Section);
		return Match - Match2;

	}
};

struct stCharOrigin {
	double W00;
	double W10;
	double W20;
	double W01;
	double W11;
	double W21;
	double G0;
	double G1;
	double dtdx;
	int signo;

	stCharOrigin(const double iW00, const double iW10, const double iW20, const double iW01, const double iW11,
				 const double iW21, const double iG0, const double iG1, const double idtdx, int isigno) :
		W00(iW00), W10(iW10), W20(iW20), W01(iW01), W11(iW11), W21(iW21), G0(iG0), G1(iG1), dtdx(idtdx), signo(isigno) {
	}

	double operator()(const double x) {
		double W0p = Interpola(W00, W01, 1., x);
		double W1p = Interpola(W10, W11, 1., x);
		double W2p = Interpola(W20, W21, 1., x);
		double Gp = Interpola(G0, G1, 1., x);
		double Up = W1p / W0p;
		double Ap = sqrt(Gp * (Gp - 1) * (W2p / W0p - pow2(Up) / 2.));
		return x + signo * (Up - signo * Ap) * dtdx;
	}
};

struct stPathOrigin {
	double W00;
	double W10;
	double W01;
	double W11;
	double dtdx;
	int signo;

	stPathOrigin(const double iW00, const double iW10, const double iW01, const double iW11, const double idtdx,
				 int isigno) :
		W00(iW00), W10(iW10), W01(iW01), W11(iW11), dtdx(idtdx), signo(isigno) {
	}

	double operator()(const double x) {
		double W0p = Interpola(W00, W01, 1., x);
		double W1p = Interpola(W10, W11, 1., x);
		double Up = W1p / W0p;
		return x + signo * Up * dtdx;
	}
};

#endif




================================================
FILE: Source/Boundaries/CMakeLists.txt
================================================
add_library(
  Boundaries
  BoundaryFunctions.cpp
  TCCCilindro.cpp
  TCCCompresor.cpp
  TCCCompresorVolumetrico.cpp
  TCCDeposito.cpp
  TCCDescargaExtremoAbierto.cpp
  TCCEntradaCompresor.cpp
  TCCExternalConnection.cpp
  TCCExternalConnectionVol.cpp
  TCCExtremoAnecoico.cpp
  TCCExtremoCerrado.cpp
  TCCExtremoInyeccion.cpp
  TCCPerdidadePresion.cpp
  TCCPreVble.cpp
  TCCPulso.cpp
  TCCRamificacion.cpp
  TCCUnionEntreDepositos.cpp
  TCCUnionEntreTubos.cpp
#   TCCValvula.cpp
  TCFDConnection.cpp
  TCondicionContorno.cpp
  TEntradaPulso.cpp)



================================================
FILE: Source/Boundaries/TCCCilindro.cpp
================================================
/* --------------------------------------------------------------------------------*\
==========================|
 \\   /\ /\   // O pen     | OpenWAM: The Open Source 1D Gas-Dynamic Code
 \\ |  X  | //  W ave     |
 \\ \/_\/ //   A ction   | CMT-Motores Termicos / Universidad Politecnica Valencia
 \\/   \//    M odel    |
 ----------------------------------------------------------------------------------
 License

 This file is part of OpenWAM.

 OpenWAM is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 OpenWAM is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with OpenWAM.  If not, see <http://www.gnu.org/licenses/>.


 \*-------------------------------------------------------------------------------- */

// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------
// En la Tesis de Jose Miguel Corberan, paginas 104-139
// Resumido en el articulo "Solucion a la condicion de contorno de la union
// cilindro-conducto de los MCIA" (Esta en el COMETT PROGRAMME 1995)
// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------
#pragma hdrstop

#include "TCCCilindro.h"
//#include <cmath>
#ifdef __BORLANDC__
#include <vcl.h>
#endif
#include "TTubo.h"

#include "TValvula4T.h"
#include "TLamina.h"
#include "TLumbrera.h"

#include "TBloqueMotor.h"
#include "TCilindro4T.h"
#include "Globales.h"

// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------

TCCCilindro::TCCCilindro(nmTypeBC TipoCC, int numCC, nmTipoCalculoEspecies SpeciesModel, int numeroespecies,
						 nmCalculoGamma GammaCalculation, bool ThereIsEGR) :
	TCondicionContorno(TipoCC, numCC, SpeciesModel, numeroespecies, GammaCalculation, ThereIsEGR) {

	if(TipoCC == nmIntakeValve)
		FTipoValv = nmValvAdmision;
	else if(TipoCC == nmExhaustValve)
		FTipoValv = nmValvEscape;
	else
		printf("ERROR en tipo de valvula TCCCilindro en la condicion de contorno: %d\n", FNumeroCC);

	FTuboExtremo = NULL;
	FValvula = NULL;

	FGasto = 0.;
	FVelocity = 0.;
	FSonido = 1.;
	FMomento = 0.;
	FVelocidadGarganta = 0.;
	FMachGarganta = 1.;
	FGastoGarganta = 0.;
	FRelacionPresionGarganta = 1.;

	FTime0 = 0.;
	FTime1 = 0.;
	FAnguloAnterior = 0.;
	FAnguloActual = 0.;

}

// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------

TCCCilindro::~TCCCilindro() {

	delete[] FTuboExtremo;

	if(FValvula != NULL)
		delete FValvula;

	FValvula = NULL;

}

// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------

void TCCCilindro::AsignaTipoValvula(TTipoValvula **Origen, int Valv, int i) {
	try {

		switch(Origen[Valv - 1]->getTypeOfValve()) {
		case nmValvula4T:
			FValvula = new TValvula4T(dynamic_cast<TValvula4T*>(Origen[Valv - 1]), i);
			break;
		case nmLamina:
			FValvula = new TLamina(dynamic_cast<TLamina*>(Origen[Valv - 1]), i);
			break;
		case nmLumbrera2T:
			FValvula = new TLumbrera(dynamic_cast<TLumbrera*>(Origen[Valv - 1]), i);
			break;
		}

		// FValvula->putDiametroTubo(FTuboExtremo[0].Pipe->GetDiametro(FNodoFin));

		FValvula->PutPipe(FTuboExtremo[0].Pipe, FNodoFin);

		FSeccionValvula = __geom::Circle_area(FValvula->getDiametro());
		FSeccionTubo = __geom::Circle_area(FTuboExtremo[0].Pipe->GetDiametro(FNodoFin));

	} catch(exception & N) {
		std::cout << "ERROR: TCCCilindro::AsignaTipoValvula en la condicion de contorno: " << FNumeroCC << std::endl;
		std::cout << "Tipo de error: " << N.what() << std::endl;
		throw Exception(N.what());
	}
}

// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------

void TCCCilindro::ReadBoundaryData(const char *FileWAM, fpos_t &filepos, int NumberOfPipes, TTubo **Pipe, int nDPF,
								   TDPF **DPF) {
	try {
		int i = 0;
		int numid = 0; // Variable necesaria para WAMer.

		FTuboExtremo = new stTuboExtremo[1];
		FTuboExtremo[0].Pipe = NULL;

		FPref = 1;

		while(FNumeroTubosCC < 1 && i < NumberOfPipes) {
			if(Pipe[i]->getNodoIzq() == FNumeroCC) {
				FTuboExtremo[FNumeroTubosCC].Pipe = Pipe[i];
				FTuboExtremo[FNumeroTubosCC].TipoExtremo = nmLeft;
				FNodoFin = 0;
				FIndiceCC = 0;
				FCC = &(FTuboExtremo[FNumeroTubosCC].Beta);
				FCD = &(FTuboExtremo[FNumeroTubosCC].Landa);
				FNumeroTubosCC++;
			}
			if(Pipe[i]->getNodoDer() == FNumeroCC) {
				FTuboExtremo[FNumeroTubosCC].Pipe = Pipe[i];
				FTuboExtremo[FNumeroTubosCC].TipoExtremo = nmRight;
				FNodoFin = Pipe[i]->getNin() - 1;
				FIndiceCC = 1;
				FCC = &(FTuboExtremo[FNumeroTubosCC].Landa);
				FCD = &(FTuboExtremo[FNumeroTubosCC].Beta);
				FNumeroTubosCC++;
			}
			i++;
		}
		FILE *fich = fopen(FileWAM, "r");
		fsetpos(fich, &filepos);

		fscanf(fich, "%d ",
			   &numid); // Esto es un dato que necesita el WAMer. Los usuarios de WAM hacemos la vista gorda hasta que se arregle.
		fscanf(fich, "%d ", &FNumeroCilindro);

		fgetpos(fich, &filepos);
		fclose(fich);

		// Inicializacion del transporte de especies quimicas
		FFraccionMasicaEspecie = new double[FNumeroEspecies - FIntEGR];
		for(int i = 0; i < FNumeroEspecies - FIntEGR; i++) {
			FFraccionMasicaEspecie[i] = FTuboExtremo[0].Pipe->GetFraccionMasicaInicial(i);
		}

	}

	catch(exception & N) {
		std::cout << "ERROR: TCCCilindro::LeeCCCilindro en la condicion de contorno: " << FNumeroCC << std::endl;
		std::cout << "Tipo de error: " << N.what() << std::endl;
		throw Exception(N.what());
	}
}

// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------

void TCCCilindro::AsignaCilindro(TBloqueMotor *EngineBlock) {
	try {

		FMotor = EngineBlock;
		FCilindro = EngineBlock->GetCilindro(FNumeroCilindro - 1);
		FAnguloActual = FCilindro->getAnguloActual();
		FValvula->PutCylider(FCilindro);

	} catch(exception & N) {
		std::cout << "ERROR: TCCCilindro::AsignaCilindro en la condicion de contorno: " << FNumeroCC << std::endl;
		std::cout << "Tipo de error: " << N.what() << std::endl;
		throw Exception(N.what());
	}
}

// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------

void TCCCilindro::CalculaCondicionContorno(double Time) {
	try {
		double rel_CCon_Entropia, coef, FraccionMasicaAcum = 0.;

		FTime0 = FTime1;
		FTime1 = Time;

		FGamma = FTuboExtremo[0].Pipe->GetGamma(FNodoFin);
		FGamma1 = __Gamma::G1(FGamma);
		FGamma2 = __Gamma::G2(FGamma);
		FGamma3 = __Gamma::G3(FGamma);
		FGamma4 = __Gamma::G4(FGamma);
		FGamma5 = __Gamma::G5(FGamma);
		FGamma6 = __Gamma::G6(FGamma);

		// FSeccionValvula = Pi * pow(FValvula->getDiametro(),2.)/ 4.;
		// FSeccionTubo=Pi*pow(FTuboExtremo[0].Pipe->GetDiametro(FNodoFin),2.)/4.;

		FAd = pow(FCilindro->getPressure() / FPref, 1. / FGamma4);
		rel_CCon_Entropia = *FCC / FTuboExtremo[0].Entropia;
		if(rel_CCon_Entropia / FAd > 1.000005) {   // Flujo entrante al cilindro
			FSentidoFlujo = nmEntrante;
			FValvula->GetCDin(FTime1);
			FCDEntrada = FValvula->getCDTubVol();
			if(FCDEntrada > 0.0001) {  /* Abierto */
				FSeccionEficaz = FCDEntrada * FSeccionValvula;
				FlujoEntranteCilindro();
				/* CALCULO DEL MOMENTO ANGULAR ENTRANTE L */
				if(FGasto < -1e-5) {
					FCTorbellino = FValvula->getCTorb();
					if(FTipoValv == nmValvEscape) {
						coef = FCTorbellino / 4.;
					} else {
						coef = FCTorbellino;
					}
					FMomento = coef * pow2(__cons::ARef * FGasto) / (200000 * FMotor->getGeometria().Carrera * FGamma *
							   FCilindro->getPressure()) * (pow2(*FCC + *FCD) / 4. + FGamma3 * pow2(
									   ((*FCD - *FCC) / FGamma1)));
				}
				// Transporte de especies quimicas.
				for(int j = 0; j < FNumeroEspecies - 2; j++) {
					FFraccionMasicaEspecie[j] = FTuboExtremo[0].Pipe->GetFraccionMasicaCC(FIndiceCC, j);
					FraccionMasicaAcum += FFraccionMasicaEspecie[j];
				}
				FFraccionMasicaEspecie[FNumeroEspecies - 2] = 1. - FraccionMasicaAcum;
				if(FHayEGR)
					FFraccionMasicaEspecie[FNumeroEspecies - 1] = FTuboExtremo[0].Pipe->GetFraccionMasicaCC(FIndiceCC, FNumeroEspecies - 1);
			} else { /* Cerrado */
				FMomento = 0.;
				FGasto = 0.;
				*FCD = *FCC;
				FVelocity = 0.;
				FSonido = *FCD;
				FVelocidadGarganta = 0.;
				FMachGarganta = 0.;
				FGastoGarganta = 0.;
				FRelacionPresionGarganta = 0.;
				FSeccionEficaz = 0.;
				// La composicion se mantiene, al estar el cilindro cerrado.
			}
		} else if(rel_CCon_Entropia / FAd < .999995) {   // Flujo saliente del cilindro
			FSentidoFlujo = nmSaliente;
			FValvula->GetCDout(FTime1);
			FCDSalida = FValvula->getCDVolTub();
			if(FCDSalida > 0.0001) {  /* Abierto */
				FSeccionEficaz = FCDSalida * FSeccionValvula;
				FlujoSalienteCilindro();
				/* CALCULO DEL MOMENTO ANGULAR SALIENTE */
				if(FGasto > 1e-5) {
					FMomento = -FCilindro->getMomentoAngular() * FGasto / FCilindro->getMasa();
				}

				// Transporte de especies quimicas.
				for(int j = 0; j < FNumeroEspecies - 2; j++) {
					FFraccionMasicaEspecie[j] = FCilindro->GetComposicionSaliente(j);
					FraccionMasicaAcum += FFraccionMasicaEspecie[j];
				}
				FFraccionMasicaEspecie[FNumeroEspecies - 2] = 1. - FraccionMasicaAcum;
				if(FHayEGR)
					FFraccionMasicaEspecie[FNumeroEspecies - 1] = FCilindro->GetComposicionSaliente(FNumeroEspecies - 1);
			} else { /* Cerrado */
				FMomento = 0.;
				FGasto = 0.;
				*FCD = *FCC;
				FVelocity = 0.;
				FSonido = *FCD;
				FVelocidadGarganta = 0.;
				FMachGarganta = 0.;
				FGastoGarganta = 0.;
				FRelacionPresionGarganta = 0.;
				FSeccionEficaz = 0.;
				// La composicion se mantiene, al estar el cilindro cerrado.
			}
		} else { // Flujo Parado
			FSentidoFlujo = nmParado;
			*FCD = *FCC;
			FGasto = 0.;
			FVelocity = 0.;
			FSonido = *FCD;
			FVelocidadGarganta = 0.;
			FMachGarganta = 0.;
			FGastoGarganta = 0.;
			FRelacionPresionGarganta = 0.;
			FSeccionEficaz = 0.;
			// La composicion se mantiene, al estar el flujo parado.
		}
		FValvula->AcumulaCDMedio(Time);
	} catch(exception & N) {
		std::cout << "ERROR: TCCCilindro::CalculaCondicionContorno en la condicion de contorno: " << FNumeroCC << std::endl;
		std::cout << "Tipo de error: " << N.what() << std::endl;
		throw Exception(N.what());
	}
}

// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------

void TCCCilindro::FlujoEntranteCilindro() {
	try {
		double vel_son_garganta = 0., velocidad_garganta = 0., Mach = 0., xaa2 = 0., ycal = 0., d1 = 0.;

		Fk = FSeccionTubo / FSeccionEficaz;
		if(Fk < 1)
			Fk = 1;
		vel_son_garganta = FTuboExtremo[0].Entropia * FAd; // Velocity del sonido en la garganta. Adimensional.

		// Calculo de la velocidad en la garganta.Caso de salto subcritico.
		FCaso = nmFlujoEntranteSaltoSubcritico;
		if(Fk == 1) {
			FSonido = FTuboExtremo[0].Entropia * FAd;
			FVelocity = (*FCC - FSonido) / FGamma3;
		} else
			Resolucion(vel_son_garganta, *FCC, FCaso, &FVelocity, &FSonido);

		// Ecuacion de la energia
		velocidad_garganta = sqrt(2. * FGamma6 * (pow2(FSonido) + FGamma3 * pow2(FVelocity) - pow2(vel_son_garganta)));
		// Se ha calculado la velocidad en la garganta en valor absoluto.

		// Calculo de la velocidad en la garganta en el caso de salto supercritico
		if(velocidad_garganta > vel_son_garganta) {
			FCaso = nmFlujoEntranteSaltoSupercritico;
			Resolucion(0.0, 1.0, FCaso, &ycal, &Mach);
			FVelocity = *FCC / (1 / Mach + FGamma3);
			FSonido = FVelocity / Mach;

			d1 = Fk * FVelocity * pow(FSonido, 1. / FGamma3);
			vel_son_garganta = pow(d1, FGamma1 / FGamma2);
			velocidad_garganta = vel_son_garganta;
		}
		double Ga3U = FGamma3 * FVelocity;
		// Fin caso de salto supercritico

		xaa2 = pow(FTuboExtremo[0].Entropia, FGamma4);
		FGasto = __units::BarToPa(-FGamma * FSeccionTubo * pow(FSonido,
								  2 * FGamma6) * FVelocity) / (__cons::ARef * xaa2); // Massflow entrante al cilindro negativo
		*FCD = FSonido - Ga3U;
		*FCC = FSonido + Ga3U;
		FRelacionPresionGarganta = pow(FSonido / (FTuboExtremo[0].Entropia * FAd), FGamma4);
		FGastoGarganta = FGasto / (FCDEntrada * FSeccionValvula);
		FMachGarganta = -velocidad_garganta / vel_son_garganta; // Negativo por ser flujo entrante
		FVelocidadGarganta = velocidad_garganta;
	}

	catch(exception & N) {
		std::cout << "ERROR: TCCCilindro::FlujoEntranteCilindro en la condicion de contorno: " << FNumeroCC << std::endl;
		std::cout << "Tipo de error: " << N.what() << std::endl;
		throw Exception(N.what());
	}
}

// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------

void TCCCilindro::FlujoSalienteCilindro() {
	try {

		double a1 = 0., xx = 0., yy = 0., d1 = 0., Ga3U = 0.;
		double a2cr = 0., val1 = 0., val2 = 0., u2cr = 0., ycal = 0., error = 0., valde = 0., miembro2 = 0.;
		// Variables para resolver la onda de choque.
		double relacion_velocidades_son, Mach_tras_ondachoque, Mach, temp_antes_ondachoque, temp_tras_ondachoque;
		double root_a = 0.;

		Fk = FSeccionTubo / FSeccionEficaz;
		if(Fk < 1)
			Fk = 1.0;

		double sqrtGa2 = sqrt(2. / FGamma2);

		/* Calculo del valor de la velocidad del sonido en el extremo del tubo para
		 el cual el salto es critico. */
		u2cr = FCilindro->getSpeedsound() / __cons::ARef * sqrtGa2 * (sqrt(pow2(Fk) + FGamma1 * FGamma2) - Fk) / FGamma1;
		a2cr = sqrt(pow2(FCilindro->getSpeedsound() / __cons::ARef) - FGamma3 * pow2(u2cr));
		// Ecuacion de la energia. Garganta-Cylinder.

		/* A partir  de a2cr se determina el error en el calculo de A2 al suponer salto
		 subcritico. Si es negativo, el salto es supercritico. Si es positivo, el salto
		 es subcritico. */
		// FSSubcritico(a2cr,&error,&miembro2);
		stFSSub FSA2(FTuboExtremo[0].Entropia, FAd, FGamma, Fk, *FCC, FCilindro->getSpeedsound() / __cons::ARef);

		error = FSA2(a2cr);

		if(error < 0.) {   // Salto de presiones supercritico.

			/* Determinacion del intervalo de iteracion. Para ello se supone que
			 en el extremo del tubo se dan las condiciones criticas. Explicado en
			 los apuntes de Pedro. */
			a1 = sqrtGa2 * FCilindro->getSpeedsound() / __cons::ARef;
			FVelocidadGarganta = a1;
			xx = pow(FAd / (FCilindro->getSpeedsound() / __cons::ARef), FGamma4);
			yy = pow(a1, 2. / FGamma1);
			Fcc = FVelocidadGarganta * yy * xx / Fk;
			// FSSupercritico(FVelocidadGarganta,&val1,&val2);

			stFSSup FU2(FTuboExtremo[0].Entropia, Fcc, FGamma, Fk, *FCC, FCilindro->getSpeedsound() / __cons::ARef);
			val1 = FU2(FVelocidadGarganta);

			if(val1 < 0.)
				valde = FVelocidadGarganta;
			else
				valde = (FCilindro->getSpeedsound() / __cons::ARef) / sqrt(FGamma3);

			/* Una vez conocido el intervalo de iteracion, se pasa a la resolucion
			 del caso flujo saliente salto supercritico. */
			FCaso = nmFlujoSalienteSaltoSupercritico;
			Resolucion(0.0, valde, FCaso, &FVelocity, &FSonido);
			Ga3U = FVelocity * FGamma3;
			// Calcula del massflow. Como es saliente del cilindro, siempre es positivo.
			xx = pow(sqrtGa2, (FGamma2 / FGamma1));
			yy = pow(FAd, FGamma4);
			FGasto = __units::BarToPa(FCDSalida * FSeccionValvula * FGamma * xx * yy) / (FCilindro->getSpeedsound());

			/* Reduccion a flujo subsonico mediante onda de choque plana en el caso
			 de que se hayan obtenido condiciones supersonicas en el extremo del
			 tubo. Explicado en la tesis Corberan (pagina de la 47 a la 52
			 (punto 2.5) y de la 122 a la 129 (lo importante a partir de la 127) */
			Mach = FVelocity / FSonido;
			xx = *FCC + Ga3U;
			FTuboExtremo[0].Entropia = FTuboExtremo[0].Entropia * FSonido / xx;
			// Ecuacion de la caracteristica incidente.
			if(Mach > 1.) {

				/* Las ecuaciones siguientes corresponden a la resolucion de la onda
				 de choque plana. Se pueden encontrar en el punto 2.5 de la tesis
				 de Corberan. */
				xx = FGamma4 * pow2(Mach) - 1.;
				Mach_tras_ondachoque = sqrt((pow2(Mach) + 2. / FGamma1) / xx);
				temp_tras_ondachoque = FGamma3 * pow2(Mach) + 1.;
				temp_antes_ondachoque = FGamma3 * pow2(Mach_tras_ondachoque) + 1.;
				relacion_velocidades_son = sqrt(temp_tras_ondachoque / temp_antes_ondachoque);
				FSonido = FSonido * relacion_velocidades_son;
				FVelocity = FSonido * Mach_tras_ondachoque;
				Ga3U = FVelocity * FGamma3;
				d1 = xx * FGamma1 / FGamma2;
				FTuboExtremo[0].Entropia = FTuboExtremo[0].Entropia * relacion_velocidades_son / pow(d1, FGamma5);
			}
		} else { // Salto de presiones subcritico.

			// Resolucion del caso de flujo saliente salto subcritico.
			FCaso = nmFlujoSalienteSaltoSubcritico;
			Resolucion(a2cr, FCilindro->getSpeedsound() / __cons::ARef, FCaso, &ycal, &FSonido);
			// Aplicando la Ecuacion de la Energia entre el cilindro y la garganta:
			root_a = pow2(FCilindro->getSpeedsound() / __cons::ARef) - pow2(FSonido);
			if(root_a > 0) {
				FVelocity = sqrt((pow2(FCilindro->getSpeedsound() / __cons::ARef) - pow2(FSonido)) / FGamma3);
			} else if(root_a > -1e12) {
				FVelocity = 0;
			} else {
				FVelocity = 0.;
				printf("ERROR: Calculating outflow in boundary %d", FNumeroCC);
			}
			Ga3U = FVelocity * FGamma3;
			// Calculo del massflow. Como es saliente del cilindro, siempre es positivo.
			xx = *FCC + Ga3U;
			a1 = FCilindro->getSpeedsound() / __cons::ARef * xx / (FTuboExtremo[0].Entropia * FAd);
			FVelocidadGarganta = Fk * pow2(a1) * FVelocity / pow2(FSonido);
			FGasto = __units::BarToPa(FCDSalida * FSeccionValvula * FGamma * pow(FAd / (FCilindro->getSpeedsound() / __cons::ARef),
									  FGamma4) * FVelocidadGarganta * pow(a1, 2. / FGamma1)) / __cons::ARef;

			FTuboExtremo[0].Entropia = FTuboExtremo[0].Entropia * FSonido / xx;
			// Ecuacion de la caracteristica incidente.
		}
		*FCD = FSonido + Ga3U;
		*FCC = FSonido - Ga3U;
		d1 = FSonido / (FTuboExtremo[0].Entropia * FAd);
		FRelacionPresionGarganta = pow(d1, FGamma4);
		FMachGarganta = FVelocidadGarganta / a1;
		// FMachGarganta = FVelocidadGarganta/a1; // Positivo por ser flujo saliente
		FGastoGarganta = FGasto / (FCDSalida * FSeccionValvula);
	}

	catch(exception & N) {
		std::cout << "ERROR: TCCCilindro::FlujoSalienteCilindro en la condicion de contorno: " << FNumeroCC << std::endl;
		std::cout << "Tipo de error: " << N.what() << std::endl;
		throw Exception(N.what());
	}
}

// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------

void TCCCilindro::Resolucion(double ext1, double ext2, nmCaso Caso, double *u2t, double *a2t) {
	try {
		if(Caso == nmFlujoEntranteSaltoSubcritico) {
			stFESub FEA2(FTuboExtremo[0].Entropia, FAd, FGamma, Fk, *FCC);
			*a2t = FindRoot(FEA2, ext1, ext2);
			*u2t = FEA2.U2;
		} else if(Caso == nmFlujoEntranteSaltoSupercritico) {
			stFESup FMatch(FGamma, Fk);
			*a2t = FindRoot(FMatch, ext1, ext2);
			*u2t = 0.;
		} else if(Caso == nmFlujoSalienteSaltoSubcritico) {
			stFSSub FSA2(FTuboExtremo[0].Entropia, FAd, FGamma, Fk, *FCC, FCilindro->getSpeedsound() / __cons::ARef);
			*a2t = FindRoot(FSA2, ext1, ext2);
			*u2t = FSA2.U2;
		} else if(Caso == nmFlujoSalienteSaltoSupercritico) {
			stFSSup FU2(FTuboExtremo[0].Entropia, Fcc, FGamma, Fk, *FCC, FCilindro->getSpeedsound() / __cons::ARef);
			*u2t = FindRoot(FU2, ext1, ext2);
			*a2t = FU2.A2;
		} else {
			printf("Error en la definicion del flujo TCCDeposito::Resolucion en la condicion de contorno: %d\n", FNumeroCC);
			throw Exception("");
		}
	}

	catch(exception & N) {
		std::cout << "ERROR: TCCCilindro::Resolucion en la condicion de contorno: " << FNumeroCC << std::endl;
		std::cout << "Tipo de error: " << N.what() << std::endl;
		throw Exception(N.what());
	}
}

// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------

// void TCCCilindro::FESubcritico(double vel_son_supuesta,double *u2_1,double *u2_2)
// {
// try
// {
//
// double xx,yy,u2;
//
///* Resolucion de la ecuacion (20) del articulo "Solucion a la condicion de
// contorno de la union cilindro-conducto de los MCIA". Ecuacion 4.30 en la
// tesis de Corberan */
//
// xx=vel_son_supuesta/(FTuboExtremo[0].Entropia*FAd);
// yy=pow(xx,4.*FGamma6);
// yy=pow(Fk,2.)*yy-1.;
// *u2_2=FTuboExtremo[0].Entropia*FAd*sqrt(2.*FGamma6*(pow(xx,2.)-1.)/yy); // Valor absoluto
//
///* Resolucion de la ecuacion de la caracteristica incidente. */
//
// *u2_1=(*FCC-vel_son_supuesta)/FGamma3;  // En valor absoluto
//
// }
// catch(Exception &N)
// {
// std::cout << "ERROR: TCCCilindro::FESubcritico en la condicion de contorno: " << FNumeroCC << std::endl;
// std::cout << "Tipo de error: " << N.what() << std::endl;
// throw Exception(N.what());
// }
// }
//
////---------------------------------------------------------------------------
////---------------------------------------------------------------------------
//
// void TCCCilindro::FESupercritico(double mach_supuesto,double *miembro1,
// double *miembro2)
// {
// try
// {
//
// double xx,yy;
//
///* Resolucion de la ecuacion (21) del articulo "Solucion a la condicion de
// contorno de la union cilindro-conducto de los MCIA". Ecuacion (4.31) de
// la tesis de Corberan */
//
// yy=(FGamma2/2.)*pow(Fk*mach_supuesto,2.*FGamma1/FGamma2);
// xx=FGamma3*pow(mach_supuesto,2);
// *miembro1=xx-yy+1.;     // Miembro 1 de la ecuacion (21)
// *miembro2=0;            // Miembro 2 de la ecuacion (21)
//
// }
// catch(Exception &N)
// {
// std::cout << "ERROR: TCCCilindro::FESupercritico en la condicion de contorno: " << FNumeroCC << std::endl;
// std::cout << "Tipo de error: " << N.what() << std::endl;
// throw Exception(N.what());
// }
// }
//
////---------------------------------------------------------------------------
////---------------------------------------------------------------------------
//
// void TCCCilindro::FSSubcritico(double vel_son_supuesta,double *error,double *miembro2)
// {
// try
// {
// double a1,u1,u2;
//
// *miembro2=0;
//
///* Resolucion del algoritmo de calculo propuesto en la pagina 113 de la tesis
// de Corberan. */
//
// u2 = sqrt((pow(FCilindro->getSpeedsound()/__cons::ARef,2)-pow(vel_son_supuesta,2))/FGamma3);
// a1 = FCilindro->getSpeedsound()/__cons::ARef*(*FCC+FGamma3*u2)/(FTuboExtremo[0].Entropia*FAd);
// u1 = Fk*u2*pow(a1,2)/pow(vel_son_supuesta,2);
// *error=pow(a1,2)+FGamma3*pow(u1,2)-pow(FCilindro->getSpeedsound()/__cons::ARef,2);
//
// }
// catch(Exception &N)
// {
// std::cout << "ERROR: TCCCilindro::FSSubcritico en la condicion de contorno: " << FNumeroCC << std::endl;
// std::cout << "Tipo de error: " << N.what() << std::endl;
// throw Exception(N.what());
// }
// }
//
////---------------------------------------------------------------------------
////---------------------------------------------------------------------------
//
// void TCCCilindro::FSSupercritico(double vel_supuesta,double *a2_1,double *a2_2)
// {
// try
// {
//
//// Resolucion de la ecuacion de la energia entre el cilindro y el extremo del tubo.
// *a2_1 = sqrt(pow(FCilindro->getSpeedsound()/__cons::ARef,2)-FGamma3*pow(vel_supuesta,2));
//
//// Resolucion de la ecuacion 4.20 de la tesis de Corberan.
// *a2_2 = sqrt(vel_supuesta*pow((*FCC+FGamma3*vel_supuesta)/
// FTuboExtremo[0].Entropia,FGamma4)/Fcc);
//
// }
// catch(Exception &N)
// {
// std::cout << "ERROR: TCCCilindro::FSSupercritico en la condicion de contorno: " << FNumeroCC << std::endl;
// std::cout << "Tipo de error: " << N.what() << std::endl;
// throw Exception(N.what());
// }
// }

// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------

void TCCCilindro::ActualizaAnguloValvula(double TiempoActual, double Regimen) {
	try {

		FTime0 = FTime1;
		FTime1 = TiempoActual;
		FDeltaT = FTime1 - FTime0;
		FDeltaAngulo = 360. * Regimen / 60. * FDeltaT;
		FAnguloAnterior = FAnguloActual;
		FAnguloActual = FAnguloAnterior + FDeltaAngulo;
		if(FAnguloActual > 720.) {
			FAnguloActual -= 720.;
		}

	} catch(exception & N) {
		std::cout << "ERROR: TCCCilindro::ActualizaAnguloValvula en la condicion de contorno: " << FNumeroCC << std::endl;
		std::cout << "Tipo de error: " << N.what() << std::endl;
		throw Exception(N.what());
	}
}

#pragma package(smart_init)



================================================
FILE: Source/Boundaries/TCCCilindro.h
================================================
/* --------------------------------------------------------------------------------*\
==========================|
 \\   /\ /\   // O pen     | OpenWAM: The Open Source 1D Gas-Dynamic Code
 \\ |  X  | //  W ave     |
 \\ \/_\/ //   A ction   | CMT-Motores Termicos / Universidad Politecnica Valencia
 \\/   \//    M odel    |
 ----------------------------------------------------------------------------------
 License

 This file is part of OpenWAM.

 OpenWAM is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 OpenWAM is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with OpenWAM.  If not, see <http://www.gnu.org/licenses/>.


 \*-------------------------------------------------------------------------------- */

// ---------------------------------------------------------------------------
#ifndef TCCCilindroH
#define TCCCilindroH

#include "TCondicionContorno.h"

#include <cstdio>
#include <iostream>

// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------

class TBloqueMotor;
class TCilindro;

/**
 * @brief Foo
 */
class TCCCilindro: public TCondicionContorno {
  private:

	TTipoValvula *FValvula;
	TCilindro *FCilindro;
	TBloqueMotor *FMotor;
	int FNumeroCilindro;

	double FPref; // Pressure de referencia

	double FCDEntrada; // Coeficiente de descarga a la entrada
	double FCDSalida; // Coeficiente de descarga a la salida
	double FCTorbellino; // Coeficiente de torbellino

	double FSeccionEficaz; // Seccion eficaz de la valvula
	double FGasto; // Massflow en el extremo del tubo.
	double FMomento;
	double FVelocity; // Velocity en el extremo del tubo
	double FSonido; // Velocity del sonido en el extremo del tubo
	double FVelocidadGarganta; // Velocity en la garganta
	double FMachGarganta; // Numero de Mach en la garganta.
	double FGastoGarganta; // Massflow en la garganta.
	double FRelacionPresionGarganta;
	double FAd;

	double FSeccionValvula; // Seccion en la garganta
	double FSeccionTubo; // Seccion en el extremo del tubo

	double FCarrera;
	double Fk; // Relacion entre la seccion del tubo en el extremo y la seccion eficaz de la valvula.
	double Fcc; // Variable auxiliar utilizada para el calculo de el caso saliente supercritico.

	nmTipoValv FTipoValv;
	nmCaso FCaso;

	int FNodoFin; // Nodo del tubo en el extremo del tubo.
	int FIndiceCC; // Posicion del vector para tomar datos del tubo para la BC (0 Nodo izquierdo; 1 Nodo derecho)
	double *FCC; // Caracteristica conocida del tubo.
	double *FCD; // Caracteristica desconocida del tubo.

	nmSentidoFlujo FSentidoFlujo;

	double FGamma1;
	double FGamma2;
	double FGamma3;
	double FGamma4;
	double FGamma5;
	double FGamma6;

	// FUNCIONES

	void FlujoEntranteCilindro();

	void FlujoSalienteCilindro();

	void Resolucion(double ext1, double ext2, nmCaso Caso, double *u2t, double *a2t);

	// void FESubcritico(double vel_son_supuesta,double *u2_1,double *u2_2);
	//
	// void FESupercritico(double mach_supuesto,double *miembro1,double *xx2);
	//
	// void FSSubcritico(double vel_son_supuesta,double *error,double *miembro2);
	//
	// void FSSupercritico(double vel_supuesta,double *a2_1,double *a2_2);

  public:

	/**
	 * @brief Naniano
	 *
	 * @return Algo
	 */
	double getSeccionEficaz() {
		return FSeccionEficaz;
	}
	;

	double getMassflow() {
		return FGasto;
	}
	;

	double getMomento() {
		return FMomento;
	}
	;

	double getVelocity() {
		return FVelocity;
	}
	;

	double getSpeedsound() {
		return FSonido;
	}
	;

	double getMach() {
		return FMachGarganta;
	}
	;

	double getVelocidadGarganta() {
		return FVelocidadGarganta;
	}
	;

	double getMachGarganta() {
		return FMachGarganta;
	}
	;

	double getGastoGarganta() {
		return FGastoGarganta;
	}
	;

	double getRelacionPresionGarganta() {
		return FRelacionPresionGarganta;
	}
	;

	int getNumeroCilindro() {
		return FNumeroCilindro;
	}
	;

	TTipoValvula* getValvula() {
		return FValvula;
	}
	;

	nmSentidoFlujo getSentidoFlujo() {
		return FSentidoFlujo;
	}
	;

	TCCCilindro(nmTypeBC TipoCC, int numCC, nmTipoCalculoEspecies SpeciesModel, int numeroespecies,
				nmCalculoGamma GammaCalculation, bool ThereIsEGR);

	~TCCCilindro();

	void ReadBoundaryData(const char *FileWAM, fpos_t &filepos, int NumberOfPipes, TTubo **Pipe, int nDPF, TDPF **DPF);

	void CalculaCondicionContorno(double Time);

	void AsignaTipoValvula(TTipoValvula **Origen, int Valv, int i);

	void AsignaCilindro(TBloqueMotor *EngineBlock);

	void ActualizaAnguloValvula(double TiempoActual, double Regimen);

	void TuboCalculandose(int TuboActual) {
	}
	;
};

#endif



================================================
FILE: Source/Boundaries/TCCCompresor.cpp
================================================
/* --------------------------------------------------------------------------------*\
==========================|
 \\   /\ /\   // O pen     | OpenWAM: The Open Source 1D Gas-Dynamic Code
 \\ |  X  | //  W ave     |
 \\ \/_\/ //   A ction   | CMT-Motores Termicos / Universidad Politecnica Valencia
 \\/   \//    M odel    |
 ----------------------------------------------------------------------------------
 License

 This file is part of OpenWAM.

 OpenWAM is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 OpenWAM is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with OpenWAM.  If not, see <http://www.gnu.org/licenses/>.


 \*-------------------------------------------------------------------------------- */

// ---------------------------------------------------------------------------
#pragma hdrstop

//#include <cmath>
#ifdef __BORLANDC__
#include <vcl.h>
#endif

#include "TCCCompresor.h"
#include "TCompTubDep.h"
#include "TCompTubos.h"
#include "TCompresorDep.h"
#include "TCCEntradaCompresor.h"

#include "TTubo.h"
#include "TDeposito.h"
#include "TCompresor.h"

// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------
TCCCompresor::TCCCompresor(nmTypeBC TipoCC, int numCC, nmTipoCalculoEspecies SpeciesModel, int numeroespecies,
						   nmCalculoGamma GammaCalculation, bool ThereIsEGR) :
	TCondicionContorno(TipoCC, numCC, SpeciesModel, numeroespecies, GammaCalculation, ThereIsEGR) {

	FTuboExtremo = NULL;
	FTiempoActual = 0;
	FNumeroTubo = NULL;

}
// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------

TCCCompresor::~TCCCompresor() {

	if(FNumeroTubo != NULL)
		delete[] FNumeroTubo;
	if(FTuboExtremo != NULL)
		delete[] FTuboExtremo;

}

// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------

void TCCCompresor::LeeNumeroCompresor(const char *FileWAM, fpos_t &filepos) {
	try {

		FILE *fich = fopen(FileWAM, "r");
		fsetpos(fich, &filepos);

		fscanf(fich, "%d ", &FNumeroCompresor);

		fgetpos(fich, &filepos);
		fclose(fich);

	} catch(exception & N) {
		std::cout << "ERROR: TCCCompresor::LeeCompresor en la condicion de contorno: " << FNumeroCC << std::endl;
		std::cout << "Tipo de error: " << N.what() << std::endl;
		throw Exception(N.what());
	}
}

// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------

void TCCCompresor::AsignacionDatos(TCompresor **Compressor, TDeposito **Plenum, const char *FileWAM, fpos_t &filepos,
								   int NumberOfPipes, TTubo **Pipe, TCondicionContorno **BC, int numCC, double AmbientTemperature, double AmbientPressure,
								   double *AtmosphericComposition) {
	try {
		int i = 0;
		bool haytubo = false;
		int tipoentrada = 0;

		FTamb = AmbientTemperature;
		FPamb = AmbientPressure;
		FCompresor = Compressor[FNumeroCompresor - 1];
		FFraccionMasicaEspecie = new double[FNumeroEspecies - FIntEGR];

		if(FCompresor->getModeloCompresor() == nmCompOriginal) {
			// Posee un tubo y un deposito. Hay que asignarselos a la BC.

			FTuboExtremo = new stTuboExtremo[1];
			FTuboExtremo[0].Pipe = NULL;

			while(FNumeroTubosCC < 1 && i < NumberOfPipes) {
				if(Pipe[i]->getNodoIzq() == FNumeroCC) {
					FTuboExtremo[FNumeroTubosCC].Pipe = Pipe[i];
					FTuboExtremo[FNumeroTubosCC].TipoExtremo = nmLeft;
					FNumeroTubosCC++;
				}
				if(Pipe[i]->getNodoDer() == FNumeroCC) {
					FTuboExtremo[FNumeroTubosCC].Pipe = Pipe[i];
					FTuboExtremo[FNumeroTubosCC].TipoExtremo = nmRight;
					FNumeroTubosCC++;
				}
				i++;
			}
			FILE *fich = fopen(FileWAM, "r");
			fsetpos(fich, &filepos);

			fscanf(fich, "%d ", &tipoentrada);

			fgetpos(fich, &filepos);
			fclose(fich);

			switch(tipoentrada) {
			case 0:
				FEntradaCompresor = nmAtmosphere;
				break;
			case 1:
				FEntradaCompresor = nmPipe;
				break;
			case 2:
				FEntradaCompresor = nmPlenum;
				break;
			}

			if(FEntradaCompresor == nmPlenum) {

				FILE *fich = fopen(FileWAM, "r");
				fsetpos(fich, &filepos);

				fscanf(fich, "%d ", &FNumeroDeposito);

				fgetpos(fich, &filepos);
				fclose(fich);

				FDeposito = Plenum[FNumeroDeposito - 1];
				dynamic_cast<TCompTubDep*>(FCompresor)->BusquedaEntradaSalida(FEntradaCompresor, FTamb, FNumeroCC, BC,
						AtmosphericComposition);

			} else if(FEntradaCompresor == nmPipe) {
				for(int i = 0; i < numCC; i++) {
					if(BC[i]->getTipoCC() == nmEntradaCompre) {
						if(dynamic_cast<TCCEntradaCompresor*>(BC[i])->getNumeroCompresor() == FNumeroCompresor) {
							haytubo = true;
							FTuboRotor = BC[i]->GetTuboExtremo(0).Pipe;
							FExtremoTuboRotor = BC[i]->GetTuboExtremo(0).TipoExtremo;
						}
					}
				}
				if(haytubo) {
					dynamic_cast<TCompTubDep*>(FCompresor)->BusquedaEntradaSalida(FEntradaCompresor, AmbientTemperature, FNumeroCC, BC,
							AtmosphericComposition);
				} else {
					printf("ERROR: El compresor %d no tiene una BC tipo EntradaCompresor a su entrada.\n ", FNumeroCompresor);
				}
			} else if(FEntradaCompresor == nmAtmosphere) {
				dynamic_cast<TCompTubDep*>(FCompresor)->BusquedaEntradaSalida(FEntradaCompresor, AmbientTemperature, FNumeroCC, BC,
						AtmosphericComposition);
			}

		} else if(FCompresor->getModeloCompresor() == nmCompPipes) {
			// Posee dos tubos. Hay que asignarselos a la BC.

			FTuboExtremo = new stTuboExtremo[2];
			FNumeroTubo = new int[2];
			for(int j = 0; j < 2; j++) {
				FTuboExtremo[j].Pipe = NULL;
			}

			while(FNumeroTubosCC < 2 && i < NumberOfPipes) {
				if(Pipe[i]->getNodoIzq() == FNumeroCC) {
					FTuboExtremo[FNumeroTubosCC].Pipe = Pipe[i];
					FTuboExtremo[FNumeroTubosCC].TipoExtremo = nmLeft;
					FNumeroTubo[FNumeroTubosCC] = i;
					FNumeroTubosCC++;
				}
				if(Pipe[i]->getNodoDer() == FNumeroCC) {
					FTuboExtremo[FNumeroTubosCC].Pipe = Pipe[i];
					FTuboExtremo[FNumeroTubosCC].TipoExtremo = nmRight;
					FNumeroTubo[FNumeroTubosCC] = i;
					FNumeroTubosCC++;
				}
				i++;
			}
			dynamic_cast<TCompTubos*>(FCompresor)->RelacionTubos(BC, FNumeroCC);

		} else if(FCompresor->getModeloCompresor() == nmCompPlenums) {
			// Posee dos depositos. Hay que asignarselos a la BC.

			FILE *fich = fopen(FileWAM, "r");
			fsetpos(fich, &filepos);

			fscanf(fich, "%d ", &FNumeroDepositoRot);
			fscanf(fich, "%d ", &FNumeroDepositoEst);

			fgetpos(fich, &filepos);
			fclose(fich);

			FDepositoRot = Plenum[FNumeroDepositoRot - 1];
			FDepositoEst = Plenum[FNumeroDepositoEst - 1];

			dynamic_cast<TCompresorDep*>(FCompresor)->RelacionDepositoCompresor(FDepositoRot, FDepositoEst);

		}

	} catch(exception & N) {
		std::cout << "ERROR: TCCCompresor::AsignaCompresor en la condicion de contorno: " << FNumeroCC << std::endl;
		std::cout << "Tipo de error: " << N.what() << std::endl;
		throw Exception(N.what());
	}
}

// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------

void TCCCompresor::ObtencionValoresInstantaneos(double Theta, double tiempoactual) {
	try {

		FTheta = Theta;
		FTiempoActual = tiempoactual;

	} catch(exception & N) {
		std::cout << "ERROR: TCCCompresor::ObtencionValoresInstantaneos en la condicion de contorno: " << FNumeroCC <<
				  std::endl;
		std::cout << "Tipo de error: " << N.what() << std::endl;
		throw Exception(N.what());
	}
}

// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------

void TCCCompresor::CalculaCondicionContorno(double Time) {
	try {
		double TrabajoInsTurbina = 0.; /* para que compile.inacabado. */
		int TuboCalculado = 0;

		if(FCompresor->getModeloCompresor() == nmCompOriginal) {
			TuboCalculado = 0; // Es la posicion del tubo a calcular en el vector estructura FTuboExtremo.
			// Para este modelo de compresor no hace falta,pero si en el de 2 tubos. Como comparten
			// funcion virtual, la llamada de la misma ha de ser igual. Por eso lo anado.
			dynamic_cast<TCompTubDep*>(FCompresor)->DatosEntradaCompresor(FTamb, FPamb, this);
			FCompresor->CondicionCompresor(FTheta, FTuboExtremo, FTiempoActual, TuboCalculado);
			FCompresor->AcumulaMedias(FTiempoActual);
		}
		if(FCompresor->getModeloCompresor() == nmCompPlenums) {
			FCompresor->CalculaGasto(TrabajoInsTurbina, FTiempoActual); /* Falta Acabar!!!!! */
			FCompresor->AcumulaMedias(FTiempoActual);
		}
		if(FCompresor->getModeloCompresor() == nmCompPipes) {
			// Identificacion del tubo que se esta calculando en el instante current. Solo han de variar sus propiedades.
			if(FTuboActual == 10000) {
				TuboCalculado = FTuboActual;
			} else {
				for(int i = 0; i < FNumeroTubosCC; i++) {
					if(FNumeroTubo[i] == FTuboActual) {
						TuboCalculado = i; // Es la posicion del tubo calculado en el vector estructura FTuboExtremo.
					}
				}
			}
			FCompresor->CondicionCompresor(FTheta, FTuboExtremo, FTiempoActual, TuboCalculado);
			FCompresor->AcumulaMedias(FTiempoActual);
		}

		// Transporte de especies quimicas.  (Paso de informacion del objeto Compressor al objeto BC Compressor
		for(int i = 0; i < FNumeroEspecies - FIntEGR; i++) {
			FFraccionMasicaEspecie[i] = FCompresor->GetFraccionMasicaEspecie(i);
		}

	} catch(exception & N) {
		std::cout << "ERROR: TCCCompresor::CalculaCondicionesContorno en la condicion de contorno: " << FNumeroCC << std::endl;
		std::cout << "Tipo de error: " << N.what() << std::endl;
		throw Exception(N.what());
	}
}

// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------

void TCCCompresor::TuboCalculandose(int TuboActual) {
	try {
		FTuboActual = TuboActual;
	} catch(exception & N) {
		std::cout << "ERROR: TCCUnionEntreTubos::TuboCalculandose en la condicion de contorno: " << FNumeroCC << std::endl;
		std::cout << "Tipo de error: " << N.what() << std::endl;
		throw Exception(N.what());
	}
}

void TCCCompresor::ReadCompressorData(const char *FileWAM, fpos_t &filepos, TCompresor **Compressor) {

	int tipoentrada = 0;

	if(Compressor[FNumeroCompresor - 1]->getModeloCompresor() == nmCompOriginal) {
		FILE *fich = fopen(FileWAM, "r");
		fsetpos(fich, &filepos);

		fscanf(fich, "%d ", &tipoentrada);

		switch(tipoentrada) {
		case 0:
			FEntradaCompresor = nmAtmosphere;
			break;
		case 1:
			FEntradaCompresor = nmPipe;
			break;
		case 2:
			FEntradaCompresor = nmPlenum;
			fscanf(fich, "%d ", &FNumeroDeposito);
			break;
		}
		fgetpos(fich, &filepos);
		fclose(fich);
	} else if(Compressor[FNumeroCompresor - 1]->getModeloCompresor() == nmCompPlenums) {
		// Posee dos depositos. Hay que asignarselos a la BC.

		FILE *fich = fopen(FileWAM, "r");
		fsetpos(fich, &filepos);

		fscanf(fich, "%d ", &FNumeroDepositoRot);
		fscanf(fich, "%d ", &FNumeroDepositoEst);

		fgetpos(fich, &filepos);
		fclose(fich);
	}
}

void TCCCompresor::AsignData(TDeposito **Plenum, int NumberOfPipes, TTubo **Pipe, TCondicionContorno **BC, int numCC,
							 double *AtmosphericComposition, TCompresor **Compressor, double AmbientTemperature, double AmbientPressure) {
	try {
		int i = 0;
		bool haytubo = false;

		FTamb = AmbientTemperature;
		FPamb = AmbientPressure;
		FCompresor = Compressor[FNumeroCompresor - 1];
		FFraccionMasicaEspecie = new double[FNumeroEspecies - FIntEGR];

		if(FCompresor->getModeloCompresor() == nmCompOriginal) {
			// Posee un tubo y un deposito. Hay que asignarselos a la BC.

			FTuboExtremo = new stTuboExtremo[1];
			FTuboExtremo[0].Pipe = NULL;

			while(FNumeroTubosCC < 1 && i < NumberOfPipes) {
				if(Pipe[i]->getNodoIzq() == FNumeroCC) {
					FTuboExtremo[FNumeroTubosCC].Pipe = Pipe[i];
					FTuboExtremo[FNumeroTubosCC].TipoExtremo = nmLeft;
					FNumeroTubosCC++;
				}
				if(Pipe[i]->getNodoDer() == FNumeroCC) {
					FTuboExtremo[FNumeroTubosCC].Pipe = Pipe[i];
					FTuboExtremo[FNumeroTubosCC].TipoExtremo = nmRight;
					FNumeroTubosCC++;
				}
				i++;
			}

			if(FEntradaCompresor == nmPlenum) {

				FDeposito = Plenum[FNumeroDeposito - 1];
				dynamic_cast<TCompTubDep*>(FCompresor)->BusquedaEntradaSalida(FEntradaCompresor, FTamb, FNumeroCC, BC,
						AtmosphericComposition);

			} else if(FEntradaCompresor == nmPipe) {
				for(int i = 0; i < numCC; i++) {
					if(BC[i]->getTipoCC() == nmEntradaCompre) {
						if(dynamic_cast<TCCEntradaCompresor*>(BC[i])->getNumeroCompresor() == FNumeroCompresor) {
							haytubo = true;
							FTuboRotor = BC[i]->GetTuboExtremo(0).Pipe;
							FExtremoTuboRotor = BC[i]->GetTuboExtremo(0).TipoExtremo;
						}
					}
				}
				if(haytubo) {
					dynamic_cast<TCompTubDep*>(FCompresor)->BusquedaEntradaSalida(FEntradaCompresor, FTamb, FNumeroCC, BC,
							AtmosphericComposition);
				} else {
					printf("ERROR: El compresor %d no tiene una BC tipo EntradaCompresor a su entrada.\n ", FNumeroCompresor);
				}
			} else if(FEntradaCompresor == nmAtmosphere) {
				dynamic_cast<TCompTubDep*>(FCompresor)->BusquedaEntradaSalida(FEntradaCompresor, FTamb, FNumeroCC, BC,
						AtmosphericComposition);
			}

		} else if(FCompresor->getModeloCompresor() == nmCompPipes) {
			// Posee dos tubos. Hay que asignarselos a la BC.

			FTuboExtremo = new stTuboExtremo[2];
			FNumeroTubo = new int[2];
			for(int j = 0; j < 2; j++) {
				FTuboExtremo[j].Pipe = NULL;
			}

			while(FNumeroTubosCC < 2 && i < NumberOfPipes) {
				if(Pipe[i]->getNodoIzq() == FNumeroCC) {
					FTuboExtremo[FNumeroTubosCC].Pipe = Pipe[i];
					FTuboExtremo[FNumeroTubosCC].TipoExtremo = nmLeft;
					FNumeroTubo[FNumeroTubosCC] = i;
					FNumeroTubosCC++;
				}
				if(Pipe[i]->getNodoDer() == FNumeroCC) {
					FTuboExtremo[FNumeroTubosCC].Pipe = Pipe[i];
					FTuboExtremo[FNumeroTubosCC].TipoExtremo = nmRight;
					FNumeroTubo[FNumeroTubosCC] = i;
					FNumeroTubosCC++;
				}
				i++;
			}
			// dynamic_cast<TCompTubos*>(FCompresor)->RelacionTubos(BC, FNumeroCC);
			dynamic_cast<TCompTubos*>(FCompresor)->AsignPipes(BC, FNumeroCC);

		} else if(FCompresor->getModeloCompresor() == nmCompPlenums) {

			FDepositoRot = Plenum[FNumeroDepositoRot - 1];
			FDepositoEst = Plenum[FNumeroDepositoEst - 1];

			dynamic_cast<TCompresorDep*>(FCompresor)->RelacionDepositoCompresor(FDepositoRot, FDepositoEst);

		}

	} catch(exception & N) {
		std::cout << "ERROR: TCCCompresor::AsignaCompresor en la condicion de contorno: " << FNumeroCC << std::endl;
		std::cout << "Tipo de error: " << N.what() << std::endl;
		throw Exception(N.what());
	}
}

// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------
#pragma package(smart_init)



================================================
FILE: Source/Boundaries/TCCCompresor.h
================================================
/* --------------------------------------------------------------------------------*\
==========================|
 \\   /\ /\   // O pen     | OpenWAM: The Open Source 1D Gas-Dynamic Code
 \\ |  X  | //  W ave     |
 \\ \/_\/ //   A ction   | CMT-Motores Termicos / Universidad Politecnica Valencia
 \\/   \//    M odel    |
 ----------------------------------------------------------------------------------
 License

 This file is part of OpenWAM.

 OpenWAM is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 OpenWAM is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with OpenWAM.  If not, see <http://www.gnu.org/licenses/>.


 \*-------------------------------------------------------------------------------- */

// ---------------------------------------------------------------------------
#ifndef TCCCompresorH
#define TCCCompresorH

#include "TCondicionContorno.h"

#include <cstdio>
#include <iostream>

// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------

class TCompresor;

class TDeposito;

class TCCCompresor: public TCondicionContorno {
  private:

	nmCompressorInlet FEntradaCompresor;
	nmPipeEnd FExtremoTuboRotor;

	int FNumeroCompresor;
	int FNumeroDeposito;
	int FNumeroDepositoRot;
	int FNumeroDepositoEst;

	TDeposito *FDeposito;
	TDeposito *FDepositoRot;
	TDeposito *FDepositoEst;

	TCompresor *FCompresor;

	TTubo *FTuboRotor;

	int FTuboActual; // Identifica el tubo que se esta calculando para el caso de Compressor de 2 tubos.
	int *FNumeroTubo;

	double FPamb;
	double FTamb;

	double FTheta;
	// double FTiempoActual;

  public:

	int getNumeroCompresor() {
		return FNumeroCompresor;
	}
	;

	TCompresor* getCompressor() {
		return FCompresor;
	}
	;

	TDeposito* getPlenum() {
		return FDeposito;
	}
	;

	TTubo* getTuboRotor() {
		return FTuboRotor;
	}
	;

	nmPipeEnd getExtremoTuboRotor() {
		return FExtremoTuboRotor;
	}
	;

	int getNumeroDeposito() {
		return FNumeroDeposito;
	}
	;

	int getNumeroDepositoRot() {
		return FNumeroDepositoRot;
	}
	;

	int getNumeroDepositoEst() {
		return FNumeroDepositoEst;
	}
	;

	double FTiempoActual;

	double getInstanteCalculo() {
		return FTiempoActual;
	}

	void PutInstanteCalculo(double valor) {
		FTiempoActual = valor;
	}
	;

	nmCompressorInlet getEntradaCompresor() {
		return FEntradaCompresor;
	}
	;

	TCCCompresor(nmTypeBC TipoCC, int numCC, nmTipoCalculoEspecies SpeciesModel, int numeroespecies,
				 nmCalculoGamma GammaCalculation, bool ThereIsEGR);

	~TCCCompresor();

	void LeeNumeroCompresor(const char *FileWAM, fpos_t &filepos);

	void AsignacionDatos(TCompresor **Compressor, TDeposito **Plenum, const char *FileWAM, fpos_t &filepos,
						 int NumberOfPipes, TTubo **Pipe, TCondicionContorno **BC, int numCC, double AmbientTemperature, double AmbientPressure,
						 double *AtmosphericComposition);

	void ObtencionValoresInstantaneos(double Theta, double tiempoactual);

	void CalculaCondicionContorno(double Time);

	void TuboCalculandose(int TuboActual);

	void ReadCompressorData(const char *FileWAM, fpos_t &filepos, TCompresor **Compressor);

	void AsignData(TDeposito **Plenum, int NumberOfPipes, TTubo **Pipe, TCondicionContorno **BC, int numCC,
				   double *AtmosphericComposition, TCompresor **Compressor, double AmbientTemperature, double AmbientPressure);
};

#endif



================================================
FILE: Source/Boundaries/TCCCompresorVolumetrico.cpp
================================================
/*--------------------------------------------------------------------------------*\
==========================|
 \\   /\ /\   // O pen     | OpenWAM: The Open Source 1D Gas-Dynamic Code
 \\ |  X  | //  W ave     |
 \\ \/_\/ //   A ction   | CMT-Motores Termicos / Universidad Politecnica Valencia
 \\/   \//    M odel    |
 ----------------------------------------------------------------------------------
 License

 This file is part of OpenWAM.

 OpenWAM is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 OpenWAM is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with OpenWAM.  If not, see <http://www.gnu.org/licenses/>.


 \*--------------------------------------------------------------------------------*/

//---------------------------------------------------------------------------
#pragma hdrstop

#include "TCCCompresorVolumetrico.h"
//#include <cmath>
#include <iostream>
#include "TTubo.h"

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

TCCCompresorVolumetrico::TCCCompresorVolumetrico(nmTypeBC TipoCC, int numCC, nmTipoCalculoEspecies SpeciesModel,
		int numeroespecies, nmCalculoGamma GammaCalculation, bool ThereIsEGR) :
	TCondicionContorno(TipoCC, numCC, SpeciesModel, numeroespecies, GammaCalculation, ThereIsEGR) {

	FTuboExtremo = NULL;
	asgNumeroCV = false;

	FResMediosCV.Potencia = false;
	FResMediosCV.Massflow = false;
	FResMediosCV.Pressure = false;

	FResInstantCV.Potencia = false;
	FResInstantCV.Massflow = false;
	FResInstantCV.Pressure = false;

	FComposicion = NULL;

}

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

TCCCompresorVolumetrico::~TCCCompresorVolumetrico() {

	delete[] FTuboExtremo;
	if(FComposicion != NULL)
		delete[] FComposicion;

}

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

void TCCCompresorVolumetrico::LeeCCCompresorVol(const char *FileWAM, fpos_t &filepos, int NumberOfPipes, TTubo **Pipe,
		bool HayMotor) {
	try {
		int i = 0, ControlRegimen;
		double fracciontotal = 0.;

		FTuboExtremo = new stTuboExtremo[1];
		FTuboExtremo[0].Pipe = NULL;

		while(FNumeroTubosCC < 1 && i < NumberOfPipes) {
			if(Pipe[i]->getNodoIzq() == FNumeroCC) {
				FTuboExtremo[FNumeroTubosCC].Pipe = Pipe[i];
				FTuboExtremo[FNumeroTubosCC].TipoExtremo = nmLeft;
				FNodoFin = 0;
				FIndiceCC = 0;
				FCC = &(FTuboExtremo[FNumeroTubosCC].Beta);
				FCD = &(FTuboExtremo[FNumeroTubosCC].Landa);
				FSeccionTubo = __geom::Circle_area(Pipe[i]->GetDiametro(FNodoFin));
				FNumeroTubosCC++;
			}
			if(Pipe[i]->getNodoDer() == FNumeroCC) {
				FTuboExtremo[FNumeroTubosCC].Pipe = Pipe[i];
				FTuboExtremo[FNumeroTubosCC].TipoExtremo = nmRight;
				FNodoFin = Pipe[i]->getNin() - 1;
				FIndiceCC = 1;
				FCC = &(FTuboExtremo[FNumeroTubosCC].Landa);
				FCD = &(FTuboExtremo[FNumeroTubosCC].Beta);
				FSeccionTubo = __geom::Circle_area(Pipe[i]->GetDiametro(FNodoFin));
				FNumeroTubosCC++;
			}
			i++;
		}

		FILE *fich = fopen(FileWAM, "r");
		fsetpos(fich, &filepos);

		fscanf(fich, "%d ", &ControlRegimen);

		switch(ControlRegimen) {
		case 0:
			FControlRegimen = nmPropio;
			break;
		case 1:
			FControlRegimen = nmMotor;
			break;
		}

		if(FControlRegimen == nmPropio) {
			fscanf(fich, "%lf ", &FRegimen);
			FRelacionVelocidadesCV = 1.;
		} else if(FControlRegimen == nmMotor && HayMotor) {
			fscanf(fich, "%lf ", &FRelacionVelocidadesCV);
		} else {
			std::cout <<
					  "ERROR: TCCCompresorVolumetrico::LeeCCDeposito Lectura del Control del Regimen erronea en la condicion de contorno: " <<
					  FNumeroCC << std::endl;
			throw Exception(" ");
		}

		fscanf(fich, "%lf %lf ", &FPresionCV, &FTemperaturaCV);
		fscanf(fich, "%lf %lf %lf ", &FC1Caudal, &FC2Caudal, &FC3Caudal);
		fscanf(fich, "%lf %lf %lf ", &FC1Temperatura, &FC2Temperatura, &FC3Temperatura);
		fscanf(fich, "%lf %lf %lf ", &FC1Potencia, &FC2Potencia, &FC3Potencia);
		fscanf(fich, "%lf %lf %lf ", &FC4Potencia, &FC5Potencia, &FC6Potencia);

// Inicializacion del transporte de especies quimicas.
		FFraccionMasicaEspecie = new double[FNumeroEspecies - FIntEGR];
		FComposicion = new double[FNumeroEspecies - FIntEGR];
		for(int i = 0; i < FNumeroEspecies - 1; i++) {
			fscanf(fich, "%lf ", &FComposicion[i]);
			FFraccionMasicaEspecie[i] = FTuboExtremo[0].Pipe->GetFraccionMasicaInicial(i);
			fracciontotal += FComposicion[i];
		}
		if(FHayEGR) {
			FFraccionMasicaEspecie[FNumeroEspecies - 1] = FTuboExtremo[0].Pipe->GetFraccionMasicaInicial(FNumeroEspecies - 1);
			if(FCalculoEspecies == nmCalculoCompleto) {
				if(FComposicion[0] > 0.2)
					FComposicion[FNumeroEspecies - 1] = 0.;
				else
					FComposicion[FNumeroEspecies - 1] = 1.;
			} else {
				if(FComposicion[0] > 0.5)
					FComposicion[FNumeroEspecies - 1] = 1.;
				else
					FComposicion[FNumeroEspecies - 1] = 0.;
			}
		}
		if(fracciontotal != 1.) {
			std::cout <<
					  "ERROR: La fraccion masica total no puede ser distinta de 1. Repasa la lectura en la condicion de contorno  " <<
					  FNumeroCC << std::endl;
			throw Exception(" ");
		}

		fgetpos(fich, &filepos);
		fclose(fich);

	}

	catch(exception &N) {
		std::cout << "ERROR: TCCCompresorVolumetrico::LeeCCCompresorVol en la condicion de contorno: " << FNumeroCC <<
				  std::endl;
		std::cout << "Tipo de error: " << N.what() << std::endl;
		throw Exception(N.what());
	}
}

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

void TCCCompresorVolumetrico::ObtencionValoresInstantaneos(double RegimenMotor) {
	try {

		FPressure = FTuboExtremo[FNumeroTubosCC - 1].Pipe->GetPresion(FNodoFin);
		if(FControlRegimen == nmMotor) {
			FRegimen = RegimenMotor;
		}

	} catch(exception &N) {
		std::cout << "ERROR: TCCCompresorVolumetrico::ObtencionValoresInstantaneos en la condicion de contorno: " << FNumeroCC
				  << std::endl;
		std::cout << "Tipo de error: " << N.what() << std::endl;
		throw Exception(N.what());
	}
}

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

void TCCCompresorVolumetrico::CalculaCondicionContorno(double Time) {
	try {
		double ei, ed, massflow, entropia, FraccionMasicaAcum = 0.;
		int cd = 0;

		FGamma = FTuboExtremo[0].Pipe->GetGamma(FNodoFin);
		FRMezcla = FTuboExtremo[0].Pipe->GetRMezcla(FNodoFin);
		FGamma3 = __Gamma::G3(FGamma);
		FGamma4 = __Gamma::G4(FGamma);

		/* Calculo del massflow volumetrico (l/s) */
		massflow = FC1Caudal + FC2Caudal * FPressure + FC3Caudal * FRelacionVelocidadesCV * FRegimen;

		/* Calculo del massflow masico (kg/s) */
		FDensidad = __units::BarToPa(FPresionCV) / (FRMezcla * __units::degCToK(FTemperaturaCV));
		FGasto = massflow * FDensidad / 1000.;

		/* Temperature del gas entrante en grados centigrados */
		FTemperature = FC1Temperatura * pow2(FPressure) + FC2Temperatura * FPressure + FC3Temperatura;

		/* Velocity del sonido en el tubo */
		FSonido = sqrt(FGamma * __units::degCToK(FTemperature) * FRMezcla) / __cons::ARef;

		/* Potencia */
		FPotencia = FC1Potencia * pow3(FPressure) + FC2Potencia * pow2(FPressure) + FC3Potencia * FPressure + FC4Potencia +
					FC5Potencia * exp(FC6Potencia * FRelacionVelocidadesCV * FRegimen);

		/*!Acotacion del intervalo donde esta U*/
		ei = 0;
		ed = FSonido;

		stComprVol CV(FTuboExtremo[0].Entropia, *FCC, FGamma, FSonido, FGasto, FSeccionTubo, __cons::PRef, __cons::ARef);
		FVelocity = FindRoot(CV, ei, ed);

		/* printf("ERROR: TCCCompresorVolumetrico::CalculaCondicionContorno No hay convergencia en el compresor volumetrico en la condicion de contorno: %d.\n",FNumeroCC);
		 printf("Repasar los datos. El compresor esta en condiciones supersonicas.\n");
		 throw Exception("ERROR: TCCCompresorVolumetrico::CalculaCondicionContorno No hay convergencia en el compresor volumetrico.");*/

		/* Obtencion de las variables de Riemann */ // Tal y como esta planteada esta BC, el flujo siempre sera entrante al tubo.
		FTuboExtremo[0].Entropia = CV.entropia;
		*FCC = FSonido - FGamma3 * FVelocity;
		*FCD = FSonido + FGamma3 * FVelocity;

// Transporte de Especies Quimicas
		if(*FCC > *FCD) {     // Flujo saliente del tubo
			for(int j = 0; j < FNumeroEspecies - 2; j++) {
				FFraccionMasicaEspecie[j] = FTuboExtremo[0].Pipe->GetFraccionMasicaCC(FIndiceCC, j);
				FraccionMasicaAcum += FFraccionMasicaEspecie[j];
			}
			FFraccionMasicaEspecie[FNumeroEspecies - 2] = 1. - FraccionMasicaAcum;
			FFraccionMasicaEspecie[FNumeroEspecies - 1] = FTuboExtremo[0].Pipe->GetFraccionMasicaCC(FIndiceCC, FNumeroEspecies - 1);
		} else if(*FCD > *FCC) {   // Flujo entrante al tubo
			for(int j = 0; j < FNumeroEspecies - FIntEGR; j++) {
				FFraccionMasicaEspecie[j] = FComposicion[j];
			}
		}
		/* La ultima opcion es que *FCC=*FCD. En este caso el flujo esta parado y la fraccion masica
		 de las especies permanece constante en dicho instante */

		AcumulaResultadosMediosCV(Time);

	} catch(exception &N) {
		std::cout << "ERROR: TCCCompresorVolumetrico::CalculaCondicionContorno en la condicion de contorno: " << FNumeroCC <<
				  std::endl;
		std::cout << "Tipo de error: " << N.what() << std::endl;
		throw Exception(N.what());
	}
}

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

//void TCCCompresorVolumetrico::PutNumeroCV(int valor)
//{
//try
//{
//if(!asgNumeroCV){
//     FNumeroCV=valor;
//     asgNumeroCV=true;
//}else{
//     std::cout << "ERROR: Este Compressor Volumetrico ya tiene numero asignado" << std::endl;
//     throw Exception("");
//}
//}
//catch(Exception &N)
//{
//std::cout << "ERROR: TCCCompresorVolumetrico::PutNumeroCV en la BC " << FNumeroCC << std::endl;
//std::cout << "Tipo de error: " << N.what() << std::endl;
//throw Exception(N.what());
//}
//}

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

void TCCCompresorVolumetrico::ReadAverageResultsCV(const char *FileWAM, fpos_t &filepos) {
	try {
		int nvars = 0, var = 0;

		FILE *fich = fopen(FileWAM, "r");
		fsetpos(fich, &filepos);

		fscanf(fich, "%d ", &nvars);
		for(int i = 0; i < nvars; i++) {
			fscanf(fich, "%d ", &var);
			switch(var) {
			case 0:
				FResMediosCV.Potencia = true;
				break;
			case 1:
				FResMediosCV.Massflow = true;
				break;
			case 2:
				FResMediosCV.Pressure = true;
				break;
			default:
				std::cout << "Resultados medios en CV(BC) " << FNumeroCC << " no implementados " << std::endl;
			}
		}

		fgetpos(fich, &filepos);
		fclose(fich);
	} catch(exception &N) {
		std::cout << "ERROR: TCCCompresorVolumetrico::ReadAverageResultsCV en la BC " << FNumeroCC << std::endl;
		std::cout << "Tipo de error: " << N.what() << std::endl;
		throw Exception(N.what());
	}
}

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

void TCCCompresorVolumetrico::CabeceraResultadosMedCV(stringstream& medoutput) {
	try {
//FILE *fich=fopen(FileSALIDA,"a");

		std::string Label;

		if(FResMediosCV.Potencia) {
			Label = "\t" + PutLabel(401) + std::to_string(FNumeroCC) + PutLabel(903);
			medoutput << Label.c_str();
		}
		if(FResMediosCV.Massflow) {
			Label = "\t" + PutLabel(402) + std::to_string(FNumeroCC) + PutLabel(904);
			medoutput << Label.c_str();
		}
		if(FResMediosCV.Pressure) {
			Label = "\t" + PutLabel(402) + std::to_string(FNumeroCC) + PutLabel(908);
			medoutput << Label.c_str();
		}

//fclose(fich);
	} catch(exception &N) {
		std::cout << "ERROR: TCCCompresorVolumetrico::CabeceraResultadosMedCV en la BC " << FNumeroCC << std::endl;
		std::cout << "Tipo de error: " << N.what() << std::endl;
		throw Exception(N.what());
	}
}

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

void TCCCompresorVolumetrico::ImprimeResultadosMedCV(stringstream& medoutput) {
	try {
//FILE *fich=fopen(FileSALIDA,"a");

		if(FResMediosCV.Potencia)
			medoutput << "\t" << FResMediosCV.PotenciaMED;
		if(FResMediosCV.Potencia)
			medoutput << "\t" << FResMediosCV.GastoMED;
		if(FResMediosCV.Potencia)
			medoutput << "\t" << FResMediosCV.PresionMED;

//fclose(fich);
	} catch(exception &N) {
		std::cout << "ERROR: TCCCompresorVolumetrico::ImprimerResultadosMedCV en la BC " << FNumeroCC << std::endl;
		std::cout << "Tipo de error: " << N.what() << std::endl;
		throw Exception(N.what());
	}
}

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

void TCCCompresorVolumetrico::IniciaMedias() {
	try {

		FResMediosCV.PotenciaSUM = 0.;
		FResMediosCV.GastoSUM = 0.;
		FResMediosCV.PresionSUM = 0.;
		FResMediosCV.TiempoSUM = 0.;
		FResMediosCV.Tiempo0 = 0.;

	} catch(exception &N) {
		std::cout << "ERROR: TCCCompresorVolumetrico::IniciaMedias en la BC: " << FNumeroCC << std::endl;
//std::cout << "Tipo de error: " << N.what() << std::endl;
		throw Exception(N.what());
	}
}

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

void TCCCompresorVolumetrico::ResultadosMediosCV() {
	try {
		if(FResMediosCV.Potencia) {
			FResMediosCV.PotenciaMED = FResMediosCV.PotenciaSUM / FResMediosCV.TiempoSUM;
			FResMediosCV.PotenciaSUM = 0.;
		}
		if(FResMediosCV.Massflow) {
			FResMediosCV.GastoMED = FResMediosCV.GastoSUM / FResMediosCV.TiempoSUM;
			FResMediosCV.GastoSUM = 0.;
		}
		if(FResMediosCV.Pressure) {
			FResMediosCV.PresionMED = FResMediosCV.PresionSUM / FResMediosCV.TiempoSUM;
			FResMediosCV.PresionSUM = 0.;
		}
		FResMediosCV.TiempoSUM = 0;
	} catch(exception &N) {
		std::cout << "ERROR: TCCCompresorVolumetrico::ResultadosMediosCV en la BC: " << FNumeroCC << std::endl;
		std::cout << "Tipo de error: " << N.what() << std::endl;
		throw Exception(N.what());
	}
}

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

void TCCCompresorVolumetrico::AcumulaResultadosMediosCV(double Actual) {
	try {

		double Delta = Actual - FResMediosCV.Tiempo0;

		if(FResMediosCV.Potencia) {
			FResMediosCV.PotenciaSUM += FPotencia * Delta;
		}
		if(FResMediosCV.Massflow) {
			FResMediosCV.GastoSUM += FGasto * Delta;
		}
		if(FResMediosCV.Pressure) {
			FResMediosCV.PresionSUM += FPressure * Delta;
		}

		FResMediosCV.TiempoSUM += Delta;
		FResMediosCV.Tiempo0 = Delta;
	} catch(exception &N) {
		std::cout << "ERROR: TCCCompresorVolumetrico::AcumulaResultadosMediosCV en la BC: " << FNumeroCC << std::endl;
		std::cout << "Tipo de error: " << N.what() << std::endl;
		throw Exception(N.what());
	}
}

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

void TCCCompresorVolumetrico::LeeResultadosInstantCV(const char *FileWAM, fpos_t &filepos) {
	int nvars = 0, var = 0;

	try {
		FILE *fich = fopen(FileWAM, "r");
		fsetpos(fich, &filepos);

		fscanf(fich, "%d ", &nvars);
		for(int i = 0; i < nvars; i++) {
			fscanf(fich, "%d ", &var);
			switch(var) {
			case 0:
				FResInstantCV.Potencia = true;
				break;
			case 1:
				FResInstantCV.Massflow = true;
				break;
			case 2:
				FResInstantCV.Pressure = true;
				break;
			default:
				std::cout << "Resultados medios en CV(BC) " << FNumeroCC << " no implementados " << std::endl;
			}
		}
		fgetpos(fich, &filepos);
		fclose(fich);
	} catch(exception &N) {
		std::cout << "ERROR: TCCCompresorVolumetrico::LeeResultadosInstantCV en la BC " << FNumeroCC << std::endl;
		std::cout << "Tipo de error: " << N.what() << std::endl;
		throw Exception(N.what());
	}
}

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

void TCCCompresorVolumetrico::CabeceraResultadosInstantCV(stringstream& insoutput) {
	try {
//FILE *fich=fopen(FileSALIDA,"a");
		std::string Label;

		if(FResInstantCV.Potencia) {
			Label = "\t" + PutLabel(401) + std::to_string(FNumeroCC) + PutLabel(903);
			insoutput << Label.c_str();
		}
		if(FResInstantCV.Massflow) {
			Label = "\t" + PutLabel(402) + std::to_string(FNumeroCC) + PutLabel(904);
			insoutput << Label.c_str();
		}
		if(FResInstantCV.Pressure) {
			Label = "\t" + PutLabel(403) + std::to_string(FNumeroCC) + PutLabel(908);
			insoutput << Label.c_str();
		}
//fclose(fich);
	} catch(exception &N) {
		std::cout << "ERROR: TCCCompresorVolumetrico::CabeceraResultadosInstantCV en la BC " << FNumeroCC << std::endl;
		std::cout << "Tipo de error: " << N.what() << std::endl;
		throw Exception(N.what());
	}
}

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

void TCCCompresorVolumetrico::ResultadosInstantCV() {
	try {
		if(FResInstantCV.Potencia)
			FResInstantCV.PotenciaINS = FPotencia;
		if(FResInstantCV.Massflow)
			FResInstantCV.GastoINS = FGasto;
		if(FResInstantCV.Pressure)
			FResInstantCV.PresionINS = FPressure;

	} catch(exception &N) {
		std::cout << "ERROR: TCCCompresorVolumetrico::ResultadosInstantCV en la BC " << FNumeroCC << std::endl;
		std::cout << "Tipo de error: " << N.what() << std::endl;
		throw Exception(N.what());
	}
}

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

void TCCCompresorVolumetrico::ImprimeResultadosInstantCV(stringstream& insoutput) {
	try {
//FILE *fich=fopen(FileSALIDA,"a");

		if(FResInstantCV.Potencia)
			insoutput << "\t" << FResInstantCV.PotenciaINS;
		if(FResInstantCV.Massflow)
			insoutput << "\t" << FResInstantCV.GastoINS;
		if(FResInstantCV.Pressure)
			insoutput << "\t" << FResInstantCV.PresionINS;

//fclose(fich);
	} catch(exception &N) {
		std::cout << "ERROR: TCCCompresorVolumetrico::ImprimeResultadosInstantCV en la BC " << FNumeroCC << std::endl;
		std::cout << "Tipo de error: " << N.what() << std::endl;
		throw Exception(N.what());
	}
}

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

#pragma package(smart_init)



================================================
FILE: Source/Boundaries/TCCCompresorVolumetrico.h
================================================
/* --------------------------------------------------------------------------------*\
==========================|
 |\\   /\ /\   // O pen     | OpenWAM: The Open Source 1D Gas-Dynamic Code
 | \\ |  X  | //  W ave     |
 |  \\ \/_\/ //   A ction   | CMT-Motores Termicos / Universidad Politecnica Valencia
 |   \\/   \//    M odel    |
 ----------------------------------------------------------------------------------
 License

 This file is part of OpenWAM.

 OpenWAM is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 OpenWAM is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with OpenWAM.  If not, see <http://www.gnu.org/licenses/>.


 \*-------------------------------------------------------------------------------- */

// ---------------------------------------------------------------------------
#ifndef TCCCompresorVolumetricoH
#define TCCCompresorVolumetricoH

#include "TCondicionContorno.h"

// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------

class TCCCompresorVolumetrico: public TCondicionContorno {
  private:

	// int FNumeroCV;     // Numero Compressor Volumetrico (de tornillo)
	bool asgNumeroCV;

	double FRelacionVelocidadesCV; // Relacion de velocidades compresor volumetrico - motor.
	double FPresionCV; // Presion de aspiracion.
	double FTemperaturaCV; // Temperature de aspiracion.

	// Declaracion de los coeficientes de caudal, temperatura y potencia del compresor volumetrico.
	double FC1Caudal, FC2Caudal, FC3Caudal;
	double FC1Temperatura, FC2Temperatura, FC3Temperatura;
	double FC1Potencia, FC2Potencia, FC3Potencia, FC4Potencia, FC5Potencia, FC6Potencia;

	int FNodoFin; // Nodo en el extremo del tubo que esta en la condicion de contorno.
	int FIndiceCC; // Posicion del vector para tomar datos del tubo para la BC (0 Nodo izquierdo; 1 Nodo derecho)
	double *FCC; // Caracteristica conocida del tubo.
	double *FCD; // Caracteristica desconocida del tubo.
	double FSeccionTubo; // Diametro del tubo en la condicion de contorno.

	double FGasto; // Massflow volumetrico del compresor en kg/s.
	double FDensidad; // Density del aire en la aspiracion.
	double FTemperature; // Temperature del gas entrante en degC.
	double FPotencia;
	double FPressure;
	double FRegimen;
	double FVelocity;

	double FSonido; // Velocity del sonido en el tubo.

	stResMediosCV FResMediosCV;
	stResInstantCV FResInstantCV;

	nmRegimenValv FControlRegimen;

	double FGamma3; // Son expresiones con Gamma. Se usan estas variables para no calcularlas tantas veces por instante de tiempo en la misma funcion.
	double FGamma4;
	double *FComposicion;

	// FUNCIONES PRIVADAS

	// void PutNumeroCV(int valor);

  public:

	void PutNumeroCV(int valor) {

		if(!asgNumeroCV) {
			FNumeroCV = valor;
			asgNumeroCV = true;
		} else {
			std::cout << "ERROR: Este Compressor Volumetrico ya tiene numero asignado" << std::endl;
			throw Exception("");
		}

	}

	int FNumeroCV;

	// Numero Compressor Volumetrico (de tornillo)
	int getNumeroCV() {
		return FNumeroCV;
	}

	double getPotenciaCV() {
		return FPotencia;
	}
	;

	TCCCompresorVolumetrico(nmTypeBC TipoCC, int numCC, nmTipoCalculoEspecies SpeciesModel, int numeroespecies,
							nmCalculoGamma GammaCalculation, bool ThereIsEGR);

	~TCCCompresorVolumetrico();

	void CalculaCondicionContorno(double Time);

	void LeeCCCompresorVol(const char *FileWAM, fpos_t &filepos, int NumberOfPipes, TTubo **Pipe, bool HayMotor);

	void ObtencionValoresInstantaneos(double ene);

	void ReadAverageResultsCV(const char *FileWAM, fpos_t &filepos);

	void CabeceraResultadosMedCV(stringstream& medoutput);

	void ImprimeResultadosMedCV(stringstream& medoutput);

	void ResultadosMediosCV();

	void AcumulaResultadosMediosCV(double Actual);

	void LeeResultadosInstantCV(const char *FileWAM, fpos_t &filepos);

	void CabeceraResultadosInstantCV(stringstream& insoutput);

	void ImprimeResultadosInstantCV(stringstream& insoutput);

	void ResultadosInstantCV();

	void IniciaMedias();

};

#endif




================================================
FILE: Source/Boundaries/TCCDeposito.cpp
================================================
/* --------------------------------------------------------------------------------*\
==========================|
 \\   /\ /\   // O pen     | OpenWAM: The Open Source 1D Gas-Dynamic Code
 \\ |  X  | //  W ave     |
 \\ \/_\/ //   A ction   | CMT-Motores Termicos / Universidad Politecnica Valencia
 \\/   \//    M odel    |
 ----------------------------------------------------------------------------------
 License

 This file is part of OpenWAM.

 OpenWAM is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 OpenWAM is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with OpenWAM.  If not, see <http://www.gnu.org/licenses/>.


 \*-------------------------------------------------------------------------------- */

// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------
#pragma hdrstop

#include "TCCDeposito.h"
//#include <cmath>
#ifdef __BORLANDC__
#include <vcl.h>
#endif

#include "TCDFijo.h"
#include "TValvula4T.h"
#include "TLamina.h"
#include "TDiscoRotativo.h"
#include "TLumbrera.h"
#include "TValvulaContr.h"
#include "TWasteGate.h"
#include "TEstatorTurbina.h"
#include "TRotorTurbina.h"
#include "TCDExterno.h"
#include "TMariposa.h"

#include "TDepVolVariable.h"
#include "TDepVolCte.h"
#include "TTurbinaSimple.h"
#include "TTurbinaTwin.h"
#include "TVenturi.h"
#include "TUnionDireccional.h"

#include "TTubo.h"
#include "TDPF.h"
#include "TCanalDPF.h"

// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------

TCCDeposito::TCCDeposito(nmTypeBC TipoCC, int numCC, nmTipoCalculoEspecies SpeciesModel, int numeroespecies,
						 nmCalculoGamma GammaCalculation, bool ThereIsEGR) :
	TCondicionContorno(TipoCC, numCC, SpeciesModel, numeroespecies, GammaCalculation, ThereIsEGR) {

	FTuboExtremo = NULL;
	FValvula = NULL;
	FGasto = 0;
	FVelocity = 0;
	FSonido = 1;
	FVelocidadGarganta = 0;
	FMachGarganta = 1;
	FRelacionPresionGarganta = 1;
	FSentidoFlujo = nmParado;
	FMachVenturi = 0;

	FTime0 = 0.;
	FTime1 = 0.;
	FAnguloAnterior = 0.;
	FAnguloActual = 0.;

}
// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------

TCCDeposito::~TCCDeposito() {

	delete[] FTuboExtremo;

	if(FValvula != NULL)
		delete FValvula;

	FValvula = NULL;

}

// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------

void TCCDeposito::ReadBoundaryData(const char *FileWAM, fpos_t &filepos, int NumberOfPipes, TTubo **Pipe, int nDPF,
								   TDPF **DPF) {
	try {
		int i = 0, j = 0;
		int numid = 0; // Variable necesaria para WAMer.

		FTuboExtremo = new stTuboExtremo[1];
		FTuboExtremo[0].Pipe = NULL;
#ifdef ParticulateFilter
		FTuboExtremo[0].DPF = NULL;
#endif
		FTuboExtremo[0].NumeroHaz = -1;
		FTuboExtremo[0].TipoCanal = -1;

		FPref = 1;

		while(FNumeroTubosCC < 1 && i < NumberOfPipes) {
			if(Pipe[i]->getNodoIzq() == FNumeroCC) {
				FTuboExtremo[FNumeroTubosCC].Pipe = Pipe[i];
				FTuboExtremo[FNumeroTubosCC].TipoExtremo = nmLeft;
				FNodoFin = 0;
				FIndiceCC = 0;
				FCC = &(FTuboExtremo[FNumeroTubosCC].Beta);
				FCD = &(FTuboExtremo[FNumeroTubosCC].Landa);
				FNumeroTubosCC++;
				FUnionDPF = false;
				FEncontrado = true;
			}
			if(Pipe[i]->getNodoDer() == FNumeroCC) {
				FTuboExtremo[FNumeroTubosCC].Pipe = Pipe[i];
				FTuboExtremo[FNumeroTubosCC].TipoExtremo = nmRight;
				FNodoFin = Pipe[i]->getNin() - 1;
				FIndiceCC = 1;
				FCC = &(FTuboExtremo[FNumeroTubosCC].Landa);
				FCD = &(FTuboExtremo[FNumeroTubosCC].Beta);
				FNumeroTubosCC++;
				FUnionDPF = false;
				FEncontrado = true;
			}
			i++;
		}
#ifdef ParticulateFilter
		if(!FEncontrado) {    // It is a junction between a plenum and a DPF
			int k = 0;
			while(FNumeroTubosCC < 1 && j < nDPF) {
				while(k < DPF[j]->getNumeroHacesCanales()) {
					if(DPF[j]->GetCanal(k, 0)->getNodoIzq() == FNumeroCC) {
						FTuboExtremo[FNumeroTubosCC].NumeroHaz = k;
						FTuboExtremo[FNumeroTubosCC].TipoCanal = 0;
						FTuboExtremo[FNumeroTubosCC].DPF = DPF[j];
						FTuboExtremo[FNumeroTubosCC].TipoExtremo = nmLeft;
						FNodoFin = 0;
						FIndiceCC = 0;
						FCC = & (FTuboExtremo[FNumeroTubosCC].Beta);
						FCD = & (FTuboExtremo[FNumeroTubosCC].Landa);
						FNumeroTubosCC++;
					}
					if(DPF[j]->GetCanal(k, 0)->getNodoDer() == FNumeroCC) {
						FTuboExtremo[FNumeroTubosCC].NumeroHaz = k;
						FTuboExtremo[FNumeroTubosCC].TipoCanal = 0;
						FTuboExtremo[FNumeroTubosCC].DPF = DPF[j];
						FTuboExtremo[FNumeroTubosCC].TipoExtremo = nmRight;
						FNodoFin = DPF[j]->GetCanal(k, 0)->getNin() - 1;
						FIndiceCC = 1;
						FCC = & (FTuboExtremo[FNumeroTubosCC].Landa);
						FCD = & (FTuboExtremo[FNumeroTubosCC].Beta);
						FNumeroTubosCC++;
					}
					if(DPF[j]->GetCanal(k, 1)->getNodoIzq() == FNumeroCC) {
						FTuboExtremo[FNumeroTubosCC].NumeroHaz = k;
						FTuboExtremo[FNumeroTubosCC].TipoCanal = 1;
						FTuboExtremo[FNumeroTubosCC].DPF = DPF[j];
						FTuboExtremo[FNumeroTubosCC].TipoExtremo = nmLeft;
						FNodoFin = 0;
						FIndiceCC = 0;
						FCC = & (FTuboExtremo[FNumeroTubosCC].Beta);
						FCD = & (FTuboExtremo[FNumeroTubosCC].Landa);
						FNumeroTubosCC++;
					}
					if(DPF[j]->GetCanal(k, 1)->getNodoDer() == FNumeroCC) {
						FTuboExtremo[FNumeroTubosCC].NumeroHaz = k;
						FTuboExtremo[FNumeroTubosCC].TipoCanal = 1;
						FTuboExtremo[FNumeroTubosCC].DPF = DPF[j];
						FTuboExtremo[FNumeroTubosCC].TipoExtremo = nmRight;
						FNodoFin = DPF[j]->GetCanal(k, 1)->getNin() - 1;
						FIndiceCC = 1;
						FCC = & (FTuboExtremo[FNumeroTubosCC].Landa);
						FCD = & (FTuboExtremo[FNumeroTubosCC].Beta);
						FNumeroTubosCC++;
					}
					k++;
				}
				j++;
				k = 0;
			}
			FEncontrado = true;
			FUnionDPF = true;
		}
#endif
		FILE *fich = fopen(FileWAM, "r");
		fsetpos(fich, &filepos);

		fscanf(fich, "%d ",
			   &numid); // Esto es un dato que necesita el WAMer. Los usuarios de WAM hacemos la vista gorda hasta que se arregle.
		fscanf(fich, "%d ", &FNumeroDeposito);

		fgetpos(fich, &filepos);
		fclose(fich);

		// Inicializacion del transporte de especies quimicas
		FFraccionMasicaEspecie = new double[FNumeroEspecies - FIntEGR];
		if(!FUnionDPF) {
			for(int i = 0; i < FNumeroEspecies - FIntEGR; i++) {
				FFraccionMasicaEspecie[i] = FTuboExtremo[0].Pipe->GetFraccionMasicaInicial(i);
			}
		} else {
#ifdef ParticulateFilter
			for(int i = 0; i < FNumeroEspecies - FIntEGR; i++) {
				FFraccionMasicaEspecie[i] = FTuboExtremo[0].DPF->GetCanal(FTuboExtremo[0].NumeroHaz, 0)->GetFraccionMasicaInicial(i);
			}
#endif
		}

	} catch(exception & N) {
		std::cout << "ERROR: TCCDeposito::LeeCCDeposito en la condicion de contorno: " << FNumeroCC << std::endl;
		std::cout << "Tipo de error: " << N.what() << std::endl;
		throw Exception(N.what());
	}
}

// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------

void TCCDeposito::AsignaDeposito(TDeposito **Plenum) {
	try {

		FDeposito = Plenum[FNumeroDeposito - 1];
		FValvula->PutPlenum(FDeposito);

	} catch(exception & N) {
		std::cout << "ERROR: TCCDeposito::AsignaDeposito en la condicion de contorno: " << FNumeroCC << std::endl;
		std::cout << "Tipo de error: " << N.what() << std::endl;
		throw Exception(N.what());
	}
}

// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------

void TCCDeposito::AsignaTipoValvula(TTipoValvula **Origen, int Valv, int i) {
	try {

		switch(Origen[Valv - 1]->getTypeOfValve()) {
		case nmCDFijo:
			FValvula = new TCDFijo(dynamic_cast<TCDFijo*>(Origen[Valv - 1]), i);
			break;
		case nmValvula4T:
			FValvula = new TValvula4T(dynamic_cast<TValvula4T*>(Origen[Valv - 1]), i);
			break;
		case nmLamina:
			FValvula = new TLamina(dynamic_cast<TLamina*>(Origen[Valv - 1]), i);
			break;
		case nmDiscoRotativo:
			FValvula = new TDiscoRotativo(dynamic_cast<TDiscoRotativo*>(Origen[Valv - 1]), i);
			break;
		case nmLumbrera2T:
			FValvula = new TLumbrera(dynamic_cast<TLumbrera*>(Origen[Valv - 1]), i);
			break;
		case nmValvulaContr:
			FValvula = new TValvulaContr(dynamic_cast<TValvulaContr*>(Origen[Valv - 1]), i);
			break;
		case nmWasteGate:
			FValvula = new TWasteGate(dynamic_cast<TWasteGate*>(Origen[Valv - 1]), i);
			break;
		case nmStator:
			FValvula = new TEstatorTurbina(dynamic_cast<TEstatorTurbina*>(Origen[Valv - 1]), i);
			break;
		case nmRotor:
			FValvula = new TRotorTurbina(dynamic_cast<TRotorTurbina*>(Origen[Valv - 1]), i);
			break;
		case nmCalcExtern:
			FValvula = new TCDExterno(dynamic_cast<TCDExterno*>(Origen[Valv - 1]), i);
			break;
		case nmMariposa:
			FValvula = new TMariposa(dynamic_cast<TMariposa*>(Origen[Valv - 1]), i);
			break;
		}

		if(!FUnionDPF) {
			FValvula->PutPipe(FTuboExtremo[0].Pipe, FNodoFin);
			FValvula->PutDiametroTubo(FTuboExtremo[0].Pipe->GetDiametro(FNodoFin));
		} else {
#ifdef ParticulateFilter
			FValvula->PutDiametroTubo(FTuboExtremo[0].DPF->GetCanal(FTuboExtremo[0].NumeroHaz,
									  FTuboExtremo[0].TipoCanal)->GetDiametro(FNodoFin));
#endif
		}

		if(FValvula->getTypeOfValve() == nmCDFijo) {
			// dynamic_cast<TCDFijo *>(FValvula)->CalculaCD();
			FCDEntrada = FValvula->getCDTubVol();
			FCDSalida = FValvula->getCDVolTub();
			// FCTorbellino=FValvula->getCTorb();
			if(FCDEntrada > 1.) {
				FValvula->AsignaCRecuperacion(FCDEntrada - 1.);
			} else
				FValvula->AsignaCRecuperacion(0.);
		}

	} catch(exception & N) {
		std::cout << "ERROR: TCCDeposito::AsignaTipoValvula en la condicion de contorno: " << FNumeroCC << std::endl;
		std::cout << "Tipo de error: " << N.what() << std::endl;
		throw Exception(N.what());
	}
}

// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------

void TCCDeposito::CalculaCoeficientesDescarga(double TiempoActual, double mfcomb, double RegimenMotor) {
	try {
		double PVol = 0., PTub = 0., PAdm = 0., DeltaP = 0., distancia = 0., CDExt = 0., nodoadm = 0., p1 = 0., p2 = 0.;
		int turb = 0, entr = 0, NodoFin = 0;

		switch(FValvula->getTypeOfValve()) {
		case nmCDFijo:
			dynamic_cast<TCDFijo*>(FValvula)->CalculaCD();
			break;

		case nmValvula4T:
			if(FValvula->getControlRegimen() == nmMotor) {
				FRegimen = RegimenMotor;
			} else {
				FRegimen = FValvula->getRegimen();
			}
			FTime0 = FTime1;
			FTime1 = TiempoActual;
			FDeltaT = FTime1 - FTime0;
			FDeltaAngulo = 360. * FRegimen * FValvula->getRelacionVelocidades() / 60. * FDeltaT;
			FAnguloAnterior = FAnguloActual;
			FAnguloActual = FAnguloAnterior + FDeltaAngulo;
			if(FAnguloActual > 360.) {
				FAnguloActual -= 360.;
			}
			dynamic_cast<TValvula4T*>(FValvula)->CalculaCD(FAnguloActual);
			break;

		case nmStator:
			dynamic_cast<TEstatorTurbina*>(FValvula)->CalculaCD();
			break;

		case nmRotor:
			dynamic_cast<TRotorTurbina*>(FValvula)->CalculaCD();
			break;

		case nmLamina:
			if(FTuboExtremo[0].TipoExtremo == nmLeft) {
				NodoFin = 0;
			} else
				NodoFin = FTuboExtremo[0].Pipe->getNin() - 1;
			DeltaP = FTuboExtremo[0].Pipe->GetPresion(NodoFin) - FDeposito->getPressure();
			dynamic_cast<TLamina*>(FValvula)->CalculaCD(DeltaP, FTuboExtremo[0].Pipe->getTime1());
			break;

		case nmDiscoRotativo:
			if(FValvula->getControlRegimen() == nmMotor) {
				FRegimen = RegimenMotor;
			} else {
				FRegimen = FValvula->getRegimen();
			}
			FTime0 = FTime1;
			FTime1 = TiempoActual;
			FDeltaT = FTime1 - FTime0;
			FDeltaAngulo = 360. * FRegimen * FValvula->getRelacionVelocidades() / 60. * FDeltaT;
			FAnguloAnterior = FAnguloActual;
			FAnguloActual = FAnguloAnterior + FDeltaAngulo;
			if(FAnguloActual > 360.) {
				FAnguloActual -= 360.;
			}
			dynamic_cast<TDiscoRotativo*>(FValvula)->CalculaCD(FAnguloActual);
			break;

		case nmLumbrera2T:
			FRegimen = dynamic_cast<TDepVolVariable*>(FDeposito)->getRegimen();
			FTime0 = FTime1;
			FTime1 = TiempoActual;
			FDeltaT = FTime1 - FTime0;
			FDeltaAngulo = 360. * FRegimen * dynamic_cast<TDepVolVariable*>(FDeposito)->getRelacionVelocidades() / 60. * FDeltaT;
			FAnguloAnterior = FAnguloActual;
			FAnguloActual = FAnguloAnterior + FDeltaAngulo;
			if(FAnguloActual > 360.) {
				FAnguloActual -= 360.;
			}
			dynamic_cast<TLumbrera*>(FValvula)->CalculaCD(FAnguloActual);
			break;

		case nmValvulaContr:
			FRegimen = RegimenMotor;
			FTime0 = FTime1;
			FTime1 = TiempoActual;
			FDeltaT = FTime1 - FTime0;
			FDeltaAngulo = 360. * FRegimen / 60. * FDeltaT;
			FAnguloAnterior = FAnguloActual;
			FAnguloActual = FAnguloAnterior + FDeltaAngulo;
			if(FAnguloActual > 720.) {
				FAnguloActual -= 720.;
			}
			dynamic_cast<TValvulaContr*>(FValvula)->CalculaCD(FAnguloActual, mfcomb);
			break;

		case nmWasteGate:
			if(FTuboExtremo[0].TipoExtremo == nmLeft) {
				NodoFin = 0;
			} else
				NodoFin = FTuboExtremo[0].Pipe->getNin() - 1;
			PTub = FTuboExtremo[0].Pipe->GetPresion(NodoFin);
			PVol = FDeposito->getPressure();
			nodoadm = dynamic_cast<TWasteGate*>(FValvula)->getNodoAdm();
			distancia = dynamic_cast<TWasteGate*>(FValvula)->getDist();
			p1 = dynamic_cast<TWasteGate*>(FValvula)->getTuboAdm()->GetPresion(nodoadm);
			p2 = dynamic_cast<TWasteGate*>(FValvula)->getTuboAdm()->GetPresion(nodoadm + 1);
			PAdm = Interpola(p1, p2, 1.0, distancia);
			dynamic_cast<TWasteGate*>(FValvula)->CalculaCD(PAdm, PTub, PVol, FTuboExtremo[0].Pipe->getTime1());
			break;

		case nmCalcExtern:
			dynamic_cast<TCDExterno*>(FValvula)->CalculaCD();
			break;

		case nmMariposa:
			dynamic_cast<TMariposa*>(FValvula)->CalculaCD(TiempoActual);
			break;
		}

		FCDEntrada = FValvula->getCDTubVol();
		FCDEntrada = FValvula->getCDTubVol();
		FCDSalida = FValvula->getCDVolTub();
		FCTorbellino = FValvula->getCTorb();
		if(FCDEntrada > 1.) {
			FValvula->AsignaCRecuperacion(FCDEntrada - 1.);
		} else
			FValvula->AsignaCRecuperacion(0.);

		if(FCDEntrada > 2.0 || FCDEntrada < 0.0) {
			printf("ERROR: TCCDeposito::CalculaCoeficientesDescarga, en calculo coeficiente descarga entrante: %lf, en %lf grados,en la condicion de contorno: %d \n",
				   FCDEntrada, FAnguloActual,
				   FNumeroCC);
			throw Exception(
				"ERROR: TCCDeposito::CalculaCoeficientesDescarga en calculo coeficiente descarga entrante: " + std::to_string(
					FCDEntrada) + ", en " + std::to_string(FAnguloActual) + " grados ");

		}
		if(FCDSalida > 1.0 || FCDSalida < 0.0) {
			printf("ERROR: TCCDeposito::CalculaCoeficientesDescarga, en calculo coeficiente descarga saliente: %lf, en %lf grados, en la condicion de contorno: %d\n",
				   FCDSalida, FAnguloActual,
				   FNumeroCC);
			throw Exception(
				"ERROR: TCCDeposito::CalculaCoeficientesDescarga en calculo coeficiente descarga saliente: " + std::to_string(
					FCDSalida) + ", en " + std::to_string(FAnguloActual) + " grados ");
		}
	} catch(exception & N) {
		std::cout << "ERROR: TCCDeposito::CalculaCoeficientesDescarga en la condicion de contorno: " << FNumeroCC << std::endl;
		std::cout << "Tipo de error: " << N.what() << std::endl;
		throw Exception(N.what());
	}
}

// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------

void TCCDeposito::IniciaGamma() {
	try {

		if(!FUnionDPF) {
			FRMezcla = FTuboExtremo[0].Pipe->GetRMezcla(FNodoFin);
			FGamma = FTuboExtremo[0].Pipe->GetGamma(FNodoFin);
			FSeccionTubo = __geom::Circle_area(FTuboExtremo[0].Pipe->GetDiametro(FNodoFin));
		} else {
#ifdef ParticulateFilter
			FRMezcla = FTuboExtremo[0].DPF->GetCanal(FTuboExtremo[0].NumeroHaz,
					   FTuboExtremo[0].TipoCanal)->GetRMezcla(FNodoFin);
			FGamma = FTuboExtremo[0].DPF->GetCanal(FTuboExtremo[0].NumeroHaz,
												   FTuboExtremo[0].TipoCanal)->GetGamma(FNodoFin);
			FSeccionTubo = __geom::Circle_area(
							   FTuboExtremo[0].DPF->GetCanal(
								   FTuboExtremo[0].NumeroHaz,
								   FTuboExtremo[0].TipoCanal)->GetDiametro(
								   FNodoFin));
#endif
		}
		FSeccionValvula = FSeccionTubo;

	} catch(exception & N) {
		std::cout << "ERROR: TCCDeposito::CalculaCondicionContorno en la condicion de contorno: " << FNumeroCC << std::endl;
		std::cout << "Tipo de error: " << N.what() << std::endl;
		throw Exception(N.what());
	}
}

// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------

void TCCDeposito::CalculaCondicionContorno(double Time) {
	try {
		double rel_CCon_Entropia, FraccionMasicaAcum = 0.;

		if(!FUnionDPF) {
			FGamma = FTuboExtremo[0].Pipe->GetGamma(FNodoFin);
		} else {
#ifdef ParticulateFilter
			FGamma = FTuboExtremo[0].DPF->GetCanal(FTuboExtremo[0].NumeroHaz, FTuboExtremo[0].TipoCanal)->GetGamma(FNodoFin);
#endif
		}
		FGamma1 = __Gamma::G1(FGamma);
		FGamma2 = __Gamma::G2(FGamma);
		FGamma3 = __Gamma::G3(FGamma);
		FGamma4 = __Gamma::G4(FGamma);
		FGamma5 = __Gamma::G5(FGamma);
		FGamma6 = __Gamma::G6(FGamma);

		FAd = pow(FDeposito->getPressure() / FPref, 1. / FGamma4);
		rel_CCon_Entropia = *FCC / FTuboExtremo[0].Entropia;
		FAdCr = FAd / sqrt(1 + pow2(FMachVenturi) * FGamma3); // Importante solo si hay venturi.
		// Si no es asi, no modifica el valor de Ad.
		if(rel_CCon_Entropia / FAdCr > 1 + 1e-5) {   // Flujo entrante al deposito
			FValvula->GetCDin(Time);
			FCDEntrada = FValvula->getCDTubVol();
			FSentidoFlujo = nmEntrante;
			if(FCDEntrada > 0.0001) {  /* Abierto */
				if(FCDEntrada <= 1.0) {
					FSeccionEficaz = FCDEntrada * FSeccionValvula;
					FlujoEntranteDeposito();
				} else { /* Recuperacion de la energia cinetica */
					FEDRecuperacionEnergiaCinetica();
				}

				// Transporte de especies quimicas.
				for(int j = 0; j < FNumeroEspecies - 2; j++) {
					if(!FUnionDPF) {
						FFraccionMasicaEspecie[j] = FTuboExtremo[0].Pipe->GetFraccionMasicaCC(FIndiceCC, j);
					} else {
#ifdef ParticulateFilter
						FFraccionMasicaEspecie[j] = FTuboExtremo[0].DPF->GetCanal(FTuboExtremo[0].NumeroHaz,
													FTuboExtremo[0].TipoCanal)->GetFraccionMasicaCC(FIndiceCC, j);
#endif
					}
					FraccionMasicaAcum += FFraccionMasicaEspecie[j];
				}
				FFraccionMasicaEspecie[FNumeroEspecies - 2] = 1. - FraccionMasicaAcum;
				if(!FUnionDPF) {
					if(FHayEGR)
						FFraccionMasicaEspecie[FNumeroEspecies - 1] = FTuboExtremo[0].Pipe->GetFraccionMasicaCC(FIndiceCC, FNumeroEspecies - 1);
				} else {
#ifdef ParticulateFilter
					if(FHayEGR) FFraccionMasicaEspecie[FNumeroEspecies - 1] = FTuboExtremo[0].DPF->GetCanal(FTuboExtremo[0].NumeroHaz,
								FTuboExtremo[0].TipoCanal)->GetFraccionMasicaCC(FIndiceCC, FNumeroEspecies - 1);
#endif
				}
			} else { /* Cerrado */
				*FCD = *FCC;
				FGasto = 0.;
				FVelocity = 0.;
				FSonido = *FCC;
				// La composicion se mantiene, al estar el deposito cerrado.
			}
		} else if(rel_CCon_Entropia / FAdCr < 1 - 1e-5) {   // Flujo saliente del deposito
			FSentidoFlujo = nmSaliente;
			FValvula->GetCDout(Time);
			FCDSalida = FValvula->getCDVolTub();
			if(FCDSalida > 0.0001) {  /* Abierto */
				// double TmpAa=FTuboExtremo[0].Entropia;  // nuevo para ver que pasa
				FSeccionEficaz = FCDSalida * FSeccionValvula;
				if(FDeposito->getTipoDeposito() == nmUnionDireccional) {
					FValvula->AsignaCDVolTub(FCDSalida);
				}
				FlujoSalienteDeposito();

				// Transporte de especies quimicas.
				for(int j = 0; j < FNumeroEspecies - 2; j++) {
					FFraccionMasicaEspecie[j] = FDeposito->GetFraccionMasicaEspecie(j);
					FraccionMasicaAcum += FFraccionMasicaEspecie[j];
				}
				FFraccionMasicaEspecie[FNumeroEspecies - 2] = 1. - FraccionMasicaAcum;
				if(FHayEGR)
					FFraccionMasicaEspecie[FNumeroEspecies - 1] = FDeposito->GetFraccionMasicaEspecie(FNumeroEspecies - 1);
				// }                                           // nuevo para ver que pasa
			} else { /* Cerrado */
				*FCD = *FCC;
				FGasto = 0.;
				FVelocity = 0.;
				FSonido = *FCC;
				// La composicion se mantiene, al estar el deposito cerrado.
			}
		} else { // Flujo Parado
			FSentidoFlujo = nmParado;
			*FCD = *FCC;
			FGasto = 0.;
			FVelocity = 0.;
			FSonido = *FCC;
			// La composicion se mantiene, al estar el flujo parado.
		}
		FValvula->AcumulaCDMedio(Time);
	} catch(exception & N) {
		std::cout << "ERROR: TCCDeposito::CalculaCondicionContorno en la condicion de contorno: " << FNumeroCC << std::endl;
		std::cout << "Tipo de error: " << N.what() << std::endl;
		throw Exception(N.what());
	}
}

// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------

void TCCDeposito::FEDRecuperacionEnergiaCinetica() {
	try {
		double xaa2 = 0., ed = 0., ei = 0., a1 = 0., a2supuesta = 0.;

		ed = *FCC;
		ei = *FCC * 2. / FGamma2;
		a2supuesta = ei; // Se suponen condiciones sonicas.

		stRecover FA2(FTuboExtremo[0].Entropia, FAdCr, FGamma, FValvula->getCRecuperacion(), *FCC);
		double error = FA2(a2supuesta);

		if(error > 0) {
			FSonido = FindRoot(FA2, ed, ei);
			FVelocity = FA2.U2;
			FVelocidadGarganta = FA2.UThroat;
			a1 = FA2.A1;
		} else {
			FVelocity = 0.9999 * ei;
			FSonido = FA2.A2_2;
			FVelocidadGarganta = FA2.UThroat;
			a1 = FA2.A1;
		}

		xaa2 = pow(FTuboExtremo[0].Entropia, FGamma4);
		*FCD = FSonido - FGamma3 * FVelocity;
		*FCC = FSonido + FGamma3 * FVelocity;
		FGasto = __units::BarToPa(-FGamma * FSeccionTubo * pow(FSonido,
								  2 * FGamma6) * FVelocity) / (__cons::ARef * xaa2); // Massflow entrante al deposito negativo.
		FRelacionPresionGarganta = pow(FSonido / (FTuboExtremo[0].Entropia * FAdCr), FGamma4);
		FGastoGarganta = FGasto / (FValvula->getCRecuperacion() * FSeccionValvula);
		FMachGarganta = FVelocidadGarganta / a1; // En valor absoluto.

	} catch(exception & N) {
		std::cout << "ERROR: TCCDeposito::FEDRecuperacionEnergiaCinetica en la condicion de contorno: " << FNumeroCC <<
				  std::endl;
		std::cout << "Tipo de error: " << N.what() << std::endl;
		throw Exception(N.what());
	}
}

// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------

void TCCDeposito::FlujoEntranteDeposito() {
	try {
		double vel_son_garganta = 0., velocidad_garganta = 0., Mach = 0., xaa2 = 0., ycal = 0., d1 = 0.;

		Fk = FSeccionTubo / FSeccionEficaz;
		if(Fk < 1)
			Fk = 1.0;
		vel_son_garganta = FTuboExtremo[0].Entropia * FAdCr;
		// Velocity del sonido en la garganta. Adimensional.

		// Calculo de la velocidad en la garganta.Caso de salto subcritico.
		FCaso = nmFlujoEntranteSaltoSubcritico;
		if(Fk == 1) {
			FSonido = FTuboExtremo[0].Entropia * FAdCr;
			FVelocity = (*FCC - FSonido) / FGamma3;
		} else
			Resolucion(vel_son_garganta, *FCC, FCaso, &FVelocity, &FSonido);

		// Ecuacion de la energia
		velocidad_garganta = sqrt(2. * FGamma6 * (pow2(FSonido) + FGamma3 * pow2(FVelocity) - pow2(vel_son_garganta)));
		// Se ha calculado la velocidad en la garganta en valor absoluto.

		// Calculo de la velocidad en la garganta en el caso de salto supercritico
		if(velocidad_garganta > vel_son_garganta) {
			FCaso = nmFlujoEntranteSaltoSupercritico;
			Resolucion(0.0, 1.0, FCaso, &ycal, &Mach);
			FVelocity = *FCC / (1 / Mach + FGamma3);
			FSonido = FVelocity / Mach;

			d1 = Fk * FVelocity * pow(FSonido, 1. / FGamma3);
			vel_son_garganta = pow(d1, FGamma1 / FGamma2);
			velocidad_garganta = vel_son_garganta;
		}
		// Fin caso de salto supercritico

		xaa2 = pow(FTuboExtremo[0].Entropia, FGamma4);
		FGasto = __units::BarToPa(-FGamma * FSeccionTubo * pow(FSonido,
								  2 * FGamma6) * FVelocity) / (__cons::ARef * xaa2); // Massflow entrante al deposito negativo
		*FCD = FSonido - FGamma3 * FVelocity;
		*FCC = FSonido + FGamma3 * FVelocity;
		FRelacionPresionGarganta = pow(FSonido / (FTuboExtremo[0].Entropia * FAdCr), FGamma4);
		FGastoGarganta = FGasto / (FCDEntrada * FSeccionValvula);
		FMachGarganta = velocidad_garganta / vel_son_garganta;
		// En valor absoluto.Antes tenia signo.
		FVelocidadGarganta = velocidad_garganta;

	}

	catch(exception & N) {
		std::cout << "ERROR: TCCDeposito::FlujoEntranteDeposito en la condicion de contorno: " << FNumeroCC << std::endl;
		std::cout << "Tipo de error: " << N.what() << std::endl;
		throw Exception(N.what());
	}
}

// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------

void TCCDeposito::FlujoSalienteDeposito() {
	try {

		double a1 = 0., xx = 0., yy = 0., d1 = 0.;
		double a2cr = 0., val1 = 0., val2 = 0., u2cr = 0., ycal = 0., error = 0., valde = 0., miembro2 = 0.;
		// Variables para resolver la onda de choque.
		double relacion_velocidades_son, Mach_tras_ondachoque, Mach, temp_antes_ondachoque, temp_tras_ondachoque;

		Fk = FSeccionTubo / FSeccionEficaz;
		if(Fk < 1)
			Fk = 1;

		/* Calculo del valor de la velocidad del sonido en el extremo del tubo para
		 el cual el salto es critico. */
		u2cr = FDeposito->getSpeedsound() * sqrt(2. / FGamma2) * (sqrt(pow2(Fk) + FGamma1 * FGamma2) - Fk) / FGamma1;
		a2cr = sqrt(pow2(FDeposito->getSpeedsound()) - FGamma3 * pow2(u2cr));
		// Ecuacion de la energia. Garganta-Deposito.

		/* A partir  de a2cr se determina el error en el calculo de A2 al suponer salto
		 subcritico. Si es negativo, el salto es supercritico. Si es positivo, el salto
		 es subcritico. */
		// FSSubcritico(a2cr,&error,&miembro2);
		stFSSub FSA2(FTuboExtremo[0].Entropia, FAdCr, FGamma, Fk, *FCC, FDeposito->getSpeedsound());

		error = FSA2(a2cr);

		if(error < 0.) {   // Salto de presiones supercritico.

			/* Determinacion del intervalo de iteracion. Para ello se supone que
			 en el extremo del tubo se dan las condiciones criticas. Explicado en
			 los apuntes de Pedro. */
			a1 = sqrt(2. / FGamma2) * FDeposito->getSpeedsound();
			FVelocidadGarganta = a1;
			xx = pow(FAdCr / FDeposito->getSpeedsound(), FGamma4);
			yy = pow(a1, 2. / FGamma1);
			Fcc = FVelocidadGarganta * yy * xx / Fk;

			stFSSup FU2(FTuboExtremo[0].Entropia, Fcc, FGamma, Fk, *FCC, FDeposito->getSpeedsound());
			val1 = FU2(FVelocidadGarganta);

			// FSSupercritico(FVelocidadGarganta,&val1,&val2);
			if(val1 < 0.)
				valde = FVelocidadGarganta;
			if(val1 >= 0.) {
				double Epsilon = numeric_limits<double>::epsilon();
				valde = FDeposito->getSpeedsound() / sqrt(FGamma3) - Epsilon;
			}

			/* Una vez conocido el intervalo de iteracion, se pasa a la resolucion
			 del caso flujo saliente salto supercritico. */
			FCaso = nmFlujoSalienteSaltoSupercritico;
			Resolucion(0.0, valde, FCaso, &FVelocity, &FSonido);

			// Calcula del massflow. Como es saliente del deposito, siempre es positivo.
			xx = pow(sqrt(2. / FGamma2), (FGamma2 / FGamma1));
			yy = pow(FAdCr, FGamma4);
			FGasto = __units::BarToPa(FCDSalida * FSeccionValvula * FGamma * xx * yy) / (FDeposito->getSpeedsound() * __cons::ARef);

			/* Reduccion a flujo subsonico mediante onda de choque plana en el caso
			 de que se hayan obtenido condiciones supersonicas en el extremo del
			 tubo. Explicado en la tesis Corberan (pagina de la 47 a la 52
			 (punto 2.5) y de la 122 a la 129 (lo importante a partir de la 127) */
			Mach = FVelocity / FSonido;
			xx = *FCC + FGamma3 * FVelocity;
			FTuboExtremo[0].Entropia = FTuboExtremo[0].Entropia * FSonido / xx;
			// Ecuacion de la caracteristica incidente.
			if(Mach > 1.) {

				/* Las ecuaciones siguientes corresponden a la resolucion de la onda
				 de choque plana. Se pueden encontrar en el punto 2.5 de la tesis
				 de Corberan. */
				xx = FGamma4 * pow2(Mach) - 1.;
				Mach_tras_ondachoque = sqrt((pow2(Mach) + 2. / FGamma1) / xx);
				temp_tras_ondachoque = FGamma3 * pow2(Mach) + 1.;
				temp_antes_ondachoque = FGamma3 * pow2(Mach_tras_ondachoque) + 1.;
				relacion_velocidades_son = sqrt(temp_tras_ondachoque / temp_antes_ondachoque);
				FSonido = FSonido * relacion_velocidades_son;
				FVelocity = FSonido * Mach_tras_ondachoque;
				d1 = xx * FGamma1 / FGamma2;
				FTuboExtremo[0].Entropia = FTuboExtremo[0].Entropia * relacion_velocidades_son / pow(d1, FGamma5);
			}
		} else { // Salto de presiones subcritico.

			// Resolucion del caso de flujo saliente salto subcritico.
			FCaso = nmFlujoSalienteSaltoSubcritico;
			Resolucion(a2cr, FDeposito->getSpeedsound(), FCaso, &ycal, &FSonido);
			// Aplicando la Ecuacion de la Energia entre el deposito y la garganta:
			FVelocity = sqrt((pow2(FDeposito->getSpeedsound()) - pow2(FSonido)) / FGamma3);

			// Calculo del massflow. Como es saliente del deposito, siempre es positivo.
			a1 = FDeposito->getSpeedsound() * (*FCC + FGamma3 * FVelocity) / (FTuboExtremo[0].Entropia * FAd);
			FVelocidadGarganta = Fk * pow2(a1) * FVelocity / pow2(FSonido);
			FGasto = __units::BarToPa(FCDSalida * FSeccionValvula * FGamma * pow(FAd / FDeposito->getSpeedsound(),
									  FGamma4) * FVelocidadGarganta * pow(a1, 2. / FGamma1)) / __cons::ARef;
			xx = *FCC + FGamma3 * FVelocity;
			FTuboExtremo[0].Entropia = FTuboExtremo[0].Entropia * FSonido / xx;
			// Ecuacion de la caracteristica incidente.
		}
		*FCD = FSonido + FGamma3 * FVelocity;
		*FCC = FSonido - FGamma3 * FVelocity;
		d1 = FSonido / (FTuboExtremo[0].Entropia * FAdCr);
		FRelacionPresionGarganta = pow(d1, FGamma4);
		FMachGarganta = FVelocidadGarganta / a1; // En valor absoluto.
		FGastoGarganta = FGasto / (FCDSalida * FSeccionValvula);
	} catch(exception & N) {
		std::cout << "ERROR: TCCDeposito::FlujoSalienteDeposito en la condicion de contorno: " << FNumeroCC << std::endl;
		std::cout << "Tipo de error: " << N.what() << std::endl;
		throw Exception(N.what());
	}
}
// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------

void TCCDeposito::Resolucion(double ext1, double ext2, nmCaso Caso, double *u2t, double *a2t) {
	try {
		/* std::cout << FNumeroCC << std::endl;
		 if(FNumeroCC==26){
		 std::cout << "peta";
		 } */

		if(Caso == nmFlujoEntranteSaltoSubcritico) {
			stFESub FEA2(FTuboExtremo[0].Entropia, FAdCr, FGamma, Fk, *FCC);
			*a2t = FindRoot(FEA2, ext1, ext2);
			*u2t = FEA2.U2;
		} else if(Caso == nmFlujoEntranteSaltoSupercritico) {
			stFESup FMatch(FGamma, Fk);
			*a2t = FindRoot(FMatch, ext1, ext2);
			*u2t = 0.;
		} else if(Caso == nmFlujoSalienteSaltoSubcritico) {
			stFSSub FSA2(FTuboExtremo[0].Entropia, FAdCr, FGamma, Fk, *FCC, FDeposito->getSpeedsound());
			*a2t = FindRoot(FSA2, ext1, ext2);
			*u2t = FSA2.U2;
		} else if(Caso == nmFlujoSalienteSaltoSupercritico) {
			stFSSup FU2(FTuboExtremo[0].Entropia, Fcc, FGamma, Fk, *FCC, FDeposito->getSpeedsound());
			*u2t = FindRoot(FU2, ext1, ext2);
			*a2t = FU2.A2;
		} else {
			printf("Error en la definicion del flujo TCCDeposito::Resolucion en la condicion de contorno: %d\n", FNumeroCC);
			throw Exception("");
		}
	}

	catch(exception & N) {
		std::cout << "ERROR: TCCDeposito::Resolucion en la condicion de contorno: " << FNumeroCC << std::endl;
		std::cout << "Tipo de error: " << N.what() << std::endl;
		throw Exception(N.what());
	}
}

////---------------------------------------------------------------------------
////---------------------------------------------------------------------------
//
// void TCCDeposito::FESubcritico(double vel_son_supuesta,double *u2_1,double *u2_2)
// {
// try
// {
//
// double xx,yy;
//
// /* Resolucion de la ecuacion (20) del articulo "Solucion a la condicion de
// contorno de la union cilindro-conducto de los MCIA". Ecuacion 4.30 en la
// tesis de Corberan */
//
// xx=vel_son_supuesta/(FTuboExtremo[0].Entropia*FAdCr);
// yy=pow(xx,4.*FGamma6);
// yy=pow(Fk,2.)*yy-1.;
// *u2_2=FTuboExtremo[0].Entropia*FAdCr*sqrt(2.*FGamma6*(pow(xx,2.)-1.)/yy);   // Valor absoluto
//
//
// /* Resolucion de la ecuacion de la caracteristica incidente. */
//
// *u2_1=(*FCC-vel_son_supuesta)/FGamma3;  // En valor absoluto
//
//
//
// }
// catch(Exception &N)
// {
// std::cout << "ERROR: TCCDeposito::FESubcritico en la condicion de contorno: " << FNumeroCC << std::endl;
// std::cout << "Tipo de error: " << N.what() << std::endl;
// throw Exception(N.what());
// }
// }
//
////---------------------------------------------------------------------------
////---------------------------------------------------------------------------.
//
// void TCCDeposito::FESupercritico(double mach_supuesto,double *miembro1,
// double *miembro2)
// {
// try
// {
//
// double xx,yy;
//
// /* Resolucion de la ecuacion (21) del articulo "Solucion a la condicion de
// contorno de la union cilindro-conducto de los MCIA". Ecuacion (4.31) de
// la tesis de Corberan */
//
// yy=(FGamma2/2.)*pow(Fk*mach_supuesto,2.*FGamma1/FGamma2);
// xx=FGamma3*pow(mach_supuesto,2);
// *miembro1=xx-yy+1.;     // Miembro 1 de la ecuacion (21)
// *miembro2=0;            // Miembro 2 de la ecuacion (21)
//
// }
// catch(Exception &N)
// {
// std::cout << "ERROR: TCCDeposito::FESupercritico en la condicion de contorno: " << FNumeroCC << std::endl;
// std::cout << "Tipo de error: " << N.what() << std::endl;
// throw Exception(N.what());
// }
// }
//
////---------------------------------------------------------------------------
////---------------------------------------------------------------------------
//
// void TCCDeposito::FSSubcritico(double vel_son_supuesta,double *error,double *miembro2)
// {
// try
// {
// double a1,u1,u2;
//
// *miembro2=0;
//
// /* Resolucion del algoritmo de calculo propuesto en la pagina 113 de la tesis
// de Corberan. */
//
// u2 = sqrt((pow(FDeposito->getSpeedsound(),2)-pow(vel_son_supuesta,2))/FGamma3);
// a1 = FDeposito->getSpeedsound()*(*FCC+FGamma3*u2)/(FTuboExtremo[0].Entropia*FAdCr);
// u1 = Fk*u2*pow(a1,2)/pow(vel_son_supuesta,2);
// *error=pow(a1,2)+FGamma3*pow(u1,2)-pow(FDeposito->getSpeedsound(),2);
//
// }
// catch(Exception &N)
// {
// std::cout << "ERROR: TCCDeposito::FSSubcritico en la condicion de contorno: " << FNumeroCC << std::endl;
// std::cout << "Tipo de error: " << N.what() << std::endl;
// throw Exception(N.what());
// }
// }
//
////---------------------------------------------------------------------------
////---------------------------------------------------------------------------
//
// void TCCDeposito::FSSupercritico(double vel_supuesta,double *a2_1,double *a2_2)
// {
// try
// {
//
// // Resolucion de la ecuacion de la energia entre el deposito y el extremo del tubo.
// *a2_1 = sqrt(pow(FDeposito->getSpeedsound(),2)-FGamma3*pow(vel_supuesta,2));
//
// // Resolucion de la ecuacion 4.20 de la tesis de Corberan.
// *a2_2 = sqrt(vel_supuesta*pow((*FCC+FGamma3*vel_supuesta)/
// FTuboExtremo[0].Entropia,FGamma4)/Fcc);
//
// }
// catch(Exception &N)
// {
// std::cout << "ERROR: TCCDeposito::FSSupercritico en la condicion de contorno: " << FNumeroCC << std::endl;
// std::cout << "Tipo de error: " << N.what() << std::endl;
// throw Exception(N.what());
// }
// }
//
////---------------------------------------------------------------------------
////---------------------------------------------------------------------------

#pragma package(smart_init)



================================================
FILE: Source/Boundaries/TCCDeposito.h
================================================
/*--------------------------------------------------------------------------------*\
==========================|
 \\   /\ /\   // O pen     | OpenWAM: The Open Source 1D Gas-Dynamic Code
 \\ |  X  | //  W ave     |
 \\ \/_\/ //   A ction   | CMT-Motores Termicos / Universidad Politecnica Valencia
 \\/   \//    M odel    |
 ----------------------------------------------------------------------------------
 License

 This file is part of OpenWAM.

 OpenWAM is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 OpenWAM is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with OpenWAM.  If not, see <http://www.gnu.org/licenses/>.


 \*--------------------------------------------------------------------------------*/

//---------------------------------------------------------------------------
#ifndef TCCDepositoH
#define TCCDepositoH

#include "TCondicionContorno.h"
#include <cstdio>
#include <iostream>

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
class TDeposito;

class TCCDeposito: public TCondicionContorno {
  private:

	TTipoValvula *FValvula;
	TDeposito *FDeposito;

	int FNumeroDeposito; // Numero de deposito ligado a la condicion de contorno.

	int FNodoFin;               // Nodo en el extremo del tubo.
	int FIndiceCC; // Posicion del vector para tomar datos del tubo para la BC (0 Nodo izquierdo; 1 Nodo derecho)
	double *FCC;                // Caracteristica conocida del tubo.
	double *FCD;                // Caracteristica desconocida del tubo.

	double FPref;            // Pressure de referencia

	double FCDEntrada;       // Coeficiente de descarga a la entrada
	double FCDSalida;        // Coeficiente de descarga a la salida
	double FCTorbellino;    // Coeficiente de torbellino

	double FSeccionEficaz;   // Seccion eficaz de la valvula
	double FGasto; // Massflow en el extremo del tubo. Si es entrante, signo -. Si es saliente, signo +
	double FVelocity;         // Velocity en el extremo del tubo
	double FSonido;            // Velocity del sonido en el extremo del tubo
	double FVelocidadGarganta;  // Velocity en la garganta
	double FMachGarganta;       // Numero de Mach en la garganta.
	double FGastoGarganta;      // Massflow en la garganta.
	double FRelacionPresionGarganta;
	double FAd;
	double FAdCr;  // Ad teniendo en cuenta la recuperacion de energia cinetica.

	double FSeccionValvula;   // Seccion en la garganta
	double FSeccionTubo;      // Seccion en el extremo del tubo

	double FCarrera;
	double Fk; // Relacion entre la seccion del tubo en el extremo y la seccion eficaz de la valvula.
	double Fcc; // Variable auxiliar utilizada para el calculo de el caso saliente supercritico.
// double FMachVenturi;      // Numero de Mach en la condicion de contorno que para el calculo de presion de parada en                    // por el modelo en el extremo del tubo. Influye en el calculo de FAdCr
	// el extremo del tubo.
	nmCaso FCaso;
	nmSentidoFlujo FSentidoFlujo;

	double FRegimen;

	double FGamma1;
	double FGamma2;
	double FGamma3;
	double FGamma4;
	double FGamma5;
	double FGamma6;

	bool FEncontrado;

// FUNCIONES

	void FEDRecuperacionEnergiaCinetica();

	void FlujoEntranteDeposito();

	void FlujoSalienteDeposito();

	void Resolucion(double ext1, double ext2, nmCaso Caso, double *u2t, double *a2t);

  public:

	int getNumeroDeposito() {
		return FNumeroDeposito;
	}
	;
	double getMassflow() {
		return FGasto;
	}
	;
	double getVelocity() {
		return FVelocity;
	}
	;
	double getSpeedSound() {
		return FSonido;
	}
	;
	double getSeccionTubo() {
		return FSeccionTubo;
	}
	;
	TTipoValvula* getValvula() {
		return FValvula;
	}
	;
	nmSentidoFlujo getSentidoFlujo() {
		return FSentidoFlujo;
	}
	;
	TDeposito* getPlenum() {
		return FDeposito;
	}
	;
	void PutCDSalida(double valor) {
		FCDSalida = valor;
	}
	;
	double FMachVenturi;
	double getMachVenturi() {
		return FMachVenturi;
	}
	;
	void putMachVenturi(double valor) {
		FMachVenturi = valor;
	}

	TCCDeposito(nmTypeBC TipoCC, int numCC, nmTipoCalculoEspecies SpeciesModel, int numeroespecies,
				nmCalculoGamma GammaCalculation, bool ThereIsEGR);

	~TCCDeposito();

	void ReadBoundaryData(const char *FileWAM, fpos_t &filepos, int NumberOfPipes, TTubo **Pipe, int nDPF, TDPF **DPF);

	void AsignaDeposito(TDeposito **Plenum);

	void CalculaCondicionContorno(double Time);

	void AsignaTipoValvula(TTipoValvula **Origen, int Valv, int i);

	void CalculaCoeficientesDescarga(double TiempoAcutal, double mfcomb = 0., double RegimenMotor = 0.);

	void IniciaGamma();

	void TuboCalculandose(int TuboActual) {
	}
	;

};

#endif




================================================
FILE: Source/Boundaries/TCCDescargaExtremoAbierto.cpp
================================================
/* --------------------------------------------------------------------------------*\
==========================|
 \\   /\ /\   // O pen     | OpenWAM: The Open Source 1D Gas-Dynamic Code
 \\ |  X  | //  W ave     |
 \\ \/_\/ //   A ction   | CMT-Motores Termicos / Universidad Politecnica Valencia
 \\/   \//    M odel    |
 ----------------------------------------------------------------------------------
 License

 This file is part of OpenWAM.

 OpenWAM is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 OpenWAM is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with OpenWAM.  If not, see <http://www.gnu.org/licenses/>.


 \*-------------------------------------------------------------------------------- */

// ---------------------------------------------------------------------------
#pragma hdrstop

#include "TCCDescargaExtremoAbierto.h"
#include "TTubo.h"

// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------

TCCDescargaExtremoAbierto::TCCDescargaExtremoAbierto(nmTypeBC TipoCC, int numCC, nmTipoCalculoEspecies SpeciesModel,
		int numeroespecies, nmCalculoGamma GammaCalculation, bool ThereIsEGR) :
	TCondicionContorno(TipoCC, numCC, SpeciesModel, numeroespecies, GammaCalculation, ThereIsEGR) {
	if(TipoCC == nmOpenEndAtmosphere) {
		FTipoDescarga = nmDescargaAtmosfera;
	} else if(TipoCC == nmOpenEndReservoir) {
		FTipoDescarga = nmDescargaRemanso;
	} else if(TipoCC == nmOpenEndCalcExtern) {
		FTipoDescarga = nmDescargaRemansoMatlab;
	} else
		printf("ERROR:TCCDescargaExtremoAbierto:Asignacion Tipo BC,en la condicion de contorno: %d\n", FNumeroCC);

	FComposicion = NULL;
	FTuboExtremo = NULL;
	FVelocidadSonidoDep = 0;

}

// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------

TCCDescargaExtremoAbierto::~TCCDescargaExtremoAbierto() {
	delete[] FTuboExtremo;
	if(FComposicion != NULL)
		delete[] FComposicion;
}

// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------

void TCCDescargaExtremoAbierto::AsignAmbientConditions(double Tamb, double Pamb, double *AtmosphericComposition) {

	double RMezclaDep = 0., CvMezclaDep = 0., CpMezclaDep = 0., GammaDep = 0.;
	int modeladoescape = 0;

	FPressure = Pamb;
	FTemperaturaDep = Tamb;
	// Inicializacion del transporte de especies quimicas.
	FFraccionMasicaEspecie = new double[FNumeroEspecies - FIntEGR];
	FComposicion = new double[FNumeroEspecies - FIntEGR];
	for(int i = 0; i < FNumeroEspecies - FIntEGR; i++) {
		FComposicion[i] = AtmosphericComposition[i];
		FFraccionMasicaEspecie[i] = FTuboExtremo[0].Pipe->GetFraccionMasicaInicial(i);
	}
	if(FCalculoEspecies == nmCalculoCompleto) {

		RMezclaDep = CalculoCompletoRMezcla(FComposicion[0], FComposicion[1], FComposicion[2], 0, FCalculoGamma, nmMEP);
		CpMezclaDep = CalculoCompletoCpMezcla(FComposicion[0], FComposicion[1], FComposicion[2], 0,
											  __units::degCToK(FTemperaturaDep), FCalculoGamma, nmMEP);
		GammaDep = CalculoCompletoGamma(RMezclaDep, CpMezclaDep, FCalculoGamma);

	} else if(FCalculoEspecies == nmCalculoSimple) {

		RMezclaDep = CalculoSimpleRMezcla(FComposicion[0], 0, FCalculoGamma, nmMEP);
		CvMezclaDep = CalculoSimpleCvMezcla(__units::degCToK(FTemperaturaDep), FComposicion[0], 0, FCalculoGamma, nmMEP);
		GammaDep = CalculoSimpleGamma(RMezclaDep, CvMezclaDep, FCalculoGamma);

	}
	FVelocidadSonidoDep = sqrt(__units::degCToK(FTemperaturaDep) * GammaDep * RMezclaDep) / __cons::ARef;

}

// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------

void TCCDescargaExtremoAbierto::ReadBoundaryData(const char *FileWAM, fpos_t &filepos, int NumberOfPipes, TTubo **Pipe,
		int nDPF, TDPF **DPF) {
	try {
		int i = 0;
		double fracciontotal = 0.;
		double RMezclaDep = 0., CvMezclaDep = 0., CpMezclaDep = 0., GammaDep = 0.;
		int modeladoescape = 0;

		FTuboExtremo = new stTuboExtremo[1];
		FTuboExtremo[0].Pipe = NULL;

		FPref = 1;

		while(FNumeroTubosCC < 1 && i < NumberOfPipes) {
			if(Pipe[i]->getNodoIzq() == FNumeroCC) {
				FTuboExtremo[FNumeroTubosCC].Pipe = Pipe[i];
				FTuboExtremo[FNumeroTubosCC].TipoExtremo = nmLeft;
				FCC = &(FTuboExtremo[FNumeroTubosCC].Beta);
				FCD = &(FTuboExtremo[FNumeroTubosCC].Landa);
				FNodoFin = 0;
				FIndiceCC = 0;
				FNumeroTubosCC++;
			}
			if(Pipe[i]->getNodoDer() == FNumeroCC) {
				FTuboExtremo[FNumeroTubosCC].Pipe = Pipe[i];
				FTuboExtremo[FNumeroTubosCC].TipoExtremo = nmRight;
				FCC = &(FTuboExtremo[FNumeroTubosCC].Landa);
				FCD = &(FTuboExtremo[FNumeroTubosCC].Beta);
				FNodoFin = FTuboExtremo[FNumeroTubosCC].Pipe->getNin() - 1;
				FIndiceCC = 1;
				FNumeroTubosCC++;
			}
			i++;
		}

		FILE *fich = fopen(FileWAM, "r");
		fsetpos(fich, &filepos);

		if(FTipoDescarga == nmDescargaAtmosfera) {   // DESCARGA A LA ATMOSFERA
			fscanf(fich, "%lf ", &FPerdidaExtremo);

		} else if(FTipoDescarga == nmDescargaRemanso) {   // DESCARGA A UN DEPOSITO DE REMANSO
			fscanf(fich, "%lf %lf %lf ", &FPressure, &FTemperaturaDep, &FPerdidaExtremo);

			// Se determina si este remanso modela el escape del motor.
			fscanf(fich, "%d ", &modeladoescape);
			modeladoescape == 0 ? FModeladoEscape = false : FModeladoEscape = true;

			// Inicializacion del transporte de especies quimicas.
			FFraccionMasicaEspecie = new double[FNumeroEspecies - FIntEGR];
			FComposicion = new double[FNumeroEspecies - FIntEGR];
			for(int i = 0; i < FNumeroEspecies - 1; i++) {
				fscanf(fich, "%lf ", &FComposicion[i]);
				FFraccionMasicaEspecie[i] = FTuboExtremo[0].Pipe->GetFraccionMasicaInicial(i);
				fracciontotal += FComposicion[i];
			}
			if(FHayEGR) {
				FFraccionMasicaEspecie[FNumeroEspecies - 1] = FTuboExtremo[0].Pipe->GetFraccionMasicaInicial(FNumeroEspecies - 1);
				if(FCalculoEspecies == nmCalculoCompleto) {
					if(FComposicion[0] > 0.20)
						FComposicion[FNumeroEspecies - 1] = 0.;
					else
						FComposicion[FNumeroEspecies - 1] = 1.;
				} else {
					if(FComposicion[0] > 0.50)
						FComposicion[FNumeroEspecies - 1] = 1.;
					else
						FComposicion[FNumeroEspecies - 1] = 0.;
				}
			}
			if(fracciontotal < 1. - 1e-10 || fracciontotal > 1. + 1e-10) {
				std::cout << "ERROR: Total mass fraction must be equal to 1. Check the input data for boundary condition  " << FNumeroCC
						  << std::endl;
				throw Exception(" ");
			}
			if(FCalculoEspecies == nmCalculoCompleto) {

				RMezclaDep = CalculoCompletoRMezcla(FComposicion[0], FComposicion[1], FComposicion[2], 0, FCalculoGamma, nmMEP);
				CpMezclaDep = CalculoCompletoCpMezcla(FComposicion[0], FComposicion[1], FComposicion[2], 0,
													  __units::degCToK(FTemperaturaDep), FCalculoGamma, nmMEP);
				GammaDep = CalculoCompletoGamma(RMezclaDep, CpMezclaDep, FCalculoGamma);

			} else if(FCalculoEspecies == nmCalculoSimple) {

				RMezclaDep = CalculoSimpleRMezcla(FComposicion[0], 0, FCalculoGamma, nmMEP);
				CvMezclaDep = CalculoSimpleCvMezcla(__units::degCToK(FTemperaturaDep), FComposicion[0], 0, FCalculoGamma, nmMEP);
				GammaDep = CalculoSimpleGamma(RMezclaDep, CvMezclaDep, FCalculoGamma);

			}
			FVelocidadSonidoDep = sqrt(__units::degCToK(FTemperaturaDep) * GammaDep * RMezclaDep) / __cons::ARef;

		} else if(FTipoDescarga == nmDescargaRemansoMatlab) {
			fscanf(fich, "%lf %lf %lf ", &FPressure, &FTemperaturaDep, &FPerdidaExtremo);

			// Se determina si este remanso modela el escape del motor.
			fscanf(fich, "%d ", &modeladoescape);
			modeladoescape == 0 ? FModeladoEscape = false : FModeladoEscape = true;

			// Inicializacion del transporte de especies quimicas.
			FFraccionMasicaEspecie = new double[FNumeroEspecies - FIntEGR];
			FComposicion = new double[FNumeroEspecies - FIntEGR];
			for(int i = 0; i < FNumeroEspecies - 1; i++) {
				fscanf(fich, "%lf ", &FComposicion[i]);
				FFraccionMasicaEspecie[i] = FTuboExtremo[0].Pipe->GetFraccionMasicaInicial(i);
				fracciontotal += FComposicion[i];
			}
			if(FHayEGR) {
				FFraccionMasicaEspecie[FNumeroEspecies - 1] = FTuboExtremo[0].Pipe->GetFraccionMasicaInicial(FNumeroEspecies - 1);
				if(FCalculoEspecies == nmCalculoCompleto) {
					if(FComposicion[0] > 0.2)
						FComposicion[FNumeroEspecies - 1] = 0.;
					else
						FComposicion[FNumeroEspecies - 1] = 1.;
				} else {
					if(FComposicion[0] > 0.5)
						FComposicion[FNumeroEspecies - 1] = 1.;
					else
						FComposicion[FNumeroEspecies - 1] = 0.;
				}
			}
			if(fracciontotal != 1.) {
				std::cout <<
						  "ERROR: La fraccion masica total no puede ser distinta de 1. Repasa la lectura en la condicion de contorno  " <<
						  FNumeroCC << std::endl;
				throw Exception(" ");
			}
			if(FCalculoEspecies == nmCalculoCompleto) {

				RMezclaDep = CalculoCompletoRMezcla(FComposicion[0], FComposicion[1], FComposicion[2], 0, FCalculoGamma, nmMEP);
				CpMezclaDep = CalculoCompletoCpMezcla(FComposicion[0], FComposicion[1], FComposicion[2], 0,
													  __units::degCToK(FTemperaturaDep), FCalculoGamma, nmMEP);
				GammaDep = CalculoCompletoGamma(RMezclaDep, CpMezclaDep, FCalculoGamma);

			} else if(FCalculoEspecies == nmCalculoSimple) {

				RMezclaDep = CalculoSimpleRMezcla(FComposicion[0], 0, FCalculoGamma, nmMEP);
				CvMezclaDep = CalculoSimpleCvMezcla(__units::degCToK(FTemperaturaDep), FComposicion[0], 0, FCalculoGamma, nmMEP);
				GammaDep = CalculoSimpleGamma(RMezclaDep, CvMezclaDep, FCalculoGamma);

			}
			FVelocidadSonidoDep = sqrt(__units::degCToK(FTemperaturaDep) * GammaDep * RMezclaDep) / __cons::ARef;

		} else
			printf("ERROR:TCCDescargaExtremoAbierto::LeeDescargaExtremoAbierto.Asignacion Tipo BC\n");

		fgetpos(fich, &filepos);
		fclose(fich);

	} catch(exception & N) {
		std::cout << "ERROR: TCCDescargaExtremoAbierto::LeeDescargaExtremoAbierto en la condicion de contorno: " << FNumeroCC <<
				  std::endl;
		std::cout << "Tipo de error: " << N.what() << std::endl;
		throw Exception(N.what());
	}
}

// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------

//void TCCDescargaExtremoAbierto::PutPresion(double valor) {
//	try {
//		FPressure = valor;
//	}
//	catch(Exception & N) {
//		std::cout << "ERROR: TCCDescargaExtremoAbierto::PutPresion en la condicion de contorno: " <<
//			FNumeroCC << std::endl;
//		std::cout << "Tipo de error: " << N.what() << std::endl;
//		throw Exception(N.what());
//	}
//}

// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------

//void TCCDescargaExtremoAbierto::PutTemperatura(double valor) {
//	try {
//		double RMezclaDep = 0., CvMezclaDep = 0., CpMezclaDep = 0., GammaDep = 0.;
//
//		FTemperaturaDep = valor;
//		if (FCalculoEspecies == nmCalculoCompleto) {
//
//			RMezclaDep = CalculoCompletoRMezcla(FComposicion[0], FComposicion[1], FComposicion[2],
//				FCalculoGamma);
//			CpMezclaDep = CalculoCompletoCpMezcla(FComposicion[0], FComposicion[1],
//				FComposicion[2], FTemperaturaDep, FCalculoGamma, 0);
//			GammaDep = CalculoCompletoGamma(RMezclaDep, CpMezclaDep, FCalculoGamma, 0);
//
//		}
//		else if (FCalculoEspecies == nmCalculoSimple) {
//
//			RMezclaDep = CalculoSimpleRMezcla(FComposicion[0], FCalculoGamma, 0);
//			CvMezclaDep = CalculoSimpleCvMezcla(FTemperaturaDep, FComposicion[0], FCalculoGamma, 0);
//			GammaDep = CalculoSimpleGamma(RMezclaDep, CvMezclaDep, FCalculoGamma);
//
//		}
//		FVelocidadSonidoDep = sqrt(FTemperaturaDep * GammaDep * RMezclaDep) / __cons::ARef;
//	}
//	catch(Exception & N) {
//		std::cout << "ERROR: TCCDescargaExtremoAbierto::PutTemperatura en la condicion de contorno: " <<
//			FNumeroCC << std::endl;
//		std::cout << "Tipo de error: " << N.what() << std::endl;
//		throw Exception(N.what());
//	}
//}

// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------

void TCCDescargaExtremoAbierto::CalculaCondicionContorno(double Time) {
	try {
		double rel_CCon_entropia, yyy, pplo, aap, xyx, b, a2, c, u_isen, a_isen, a_real, u_real;
		double FraccionMasicaAcum = 0.;

		FGamma = FTuboExtremo[0].Pipe->GetGamma(FNodoFin);
		FGamma3 = __Gamma::G3(FGamma);

		rel_CCon_entropia = *FCC / FTuboExtremo[0].Entropia;
		yyy = pow(FPressure / FPref, __Gamma::G5(FGamma));
		if(rel_CCon_entropia / yyy >= 1.000005) {   // Flujo Saliente del conducto.
			/* ________ */
			/* caso > 1 */
			/* ________ */
			*FCD = FTuboExtremo[0].Entropia * 2. * yyy - *FCC;
			pplo = __Gamma::G7(FGamma) * *FCC; /* Condicion flujo supersonico */
			if(*FCD < pplo) {
				*FCD = pplo;
			}
			// Transporte de especies quimicas.
			for(int j = 0; j < FNumeroEspecies - 2; j++) {
				FFraccionMasicaEspecie[j] = FTuboExtremo[0].Pipe->GetFraccionMasicaCC(FIndiceCC, j);
				FraccionMasicaAcum += FFraccionMasicaEspecie[j];
			}
			FFraccionMasicaEspecie[FNumeroEspecies - 2] = 1. - FraccionMasicaAcum;
			if(FHayEGR)
				FFraccionMasicaEspecie[FNumeroEspecies - 1] = FTuboExtremo[0].Pipe->GetFraccionMasicaCC(FIndiceCC, FNumeroEspecies - 1);

		} else if(rel_CCon_entropia / yyy < .999995) {   // Flujo Entrante al conducto.
			/* ________ */
			/* caso < 1 */
			/* ________ */
			aap = FVelocidadSonidoDep / yyy;
			xyx = aap / FTuboExtremo[0].Entropia;
			b = __Gamma::G1(FGamma) * *FCC * pow2(xyx) * FPerdidaExtremo;
			a2 = pow2(FGamma3 * xyx * FPerdidaExtremo) + FGamma3;
			c = pow2(xyx * *FCC) - pow2(FVelocidadSonidoDep);
			u_isen = (-b + sqrt(pow2(b) - a2 * 4. * c)) / (2. * a2);
			// Resolucion ecuacion de segundo grado
			a_isen = sqrt(pow2(FVelocidadSonidoDep) - FGamma3 * pow2(u_isen));
			u_real = u_isen * FPerdidaExtremo; // Con esta relacion obtenemos la velocidad real.
			a_real = sqrt(pow2(FVelocidadSonidoDep) - FGamma3 * pow2(u_real));
			aap = a_real / a_isen * aap;
			if(fabs(u_real) > a_real) {  /* Condicion flujo supersonico */
				a_real = sqrt(2 / __Gamma::G2(FGamma)) * FVelocidadSonidoDep;
				u_real = a_real;
				aap = FTuboExtremo[0].Entropia * a_real / (*FCC + FGamma3 * u_real);
			}
			*FCC = a_real - FGamma3 * u_real;
			*FCD = a_real + FGamma3 * u_real;
			FTuboExtremo[0].Entropia = aap;

			if(!FModeladoEscape) {
				for(int j = 0; j < FNumeroEspecies - FIntEGR; j++) {
					FFraccionMasicaEspecie[j] = FComposicion[j];
				}
			}

		} else { // Flujo Parado
			/* ________ */
			/* caso = 1 */
			/* ________ */
			*FCD = *FCC;
			// La composicion se mantiene, al estar el flujo parado.

		}

	} catch(exception & N) {
		std::cout << "ERROR: TCCDescargaExtremoAbierto::CalculaCondicionesContorno en la condicion de contorno: " << FNumeroCC
				  << std::endl;
		std::cout << "Tipo de error: " << N.what() << std::endl;
		throw Exception(N.what());
	}
}

// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------

#pragma package(smart_init)



================================================
FILE: Source/Boundaries/TCCDescargaExtremoAbierto.h
================================================
/* --------------------------------------------------------------------------------*\
==========================|
 \\   /\ /\   // O pen     | OpenWAM: The Open Source 1D Gas-Dynamic Code
 \\ |  X  | //  W ave     |
 \\ \/_\/ //   A ction   | CMT-Motores Termicos / Universidad Politecnica Valencia
 \\/   \//    M odel    |
 ----------------------------------------------------------------------------------
 License

 This file is part of OpenWAM.

 OpenWAM is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 OpenWAM is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with OpenWAM.  If not, see <http://www.gnu.org/licenses/>.


 \*-------------------------------------------------------------------------------- */

// ---------------------------------------------------------------------------
#ifndef TCCDescargaExtremoAbiertoH
#define TCCDescargaExtremoAbiertoH

#include "TCondicionContorno.h"

//#include <cmath>
#ifdef __BORLANDC__
#include <vcl.h>
#endif
#include <cstdio>
#include <iostream>
// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------

class TCCDescargaExtremoAbierto: public TCondicionContorno {
  private:

	int FNodoFin; // Nodo del extremo del tubo que conecta con la condicion de contorno.
	int FIndiceCC; // Posicion del vector para tomar datos del tubo para la BC (0 Nodo izquierdo; 1 Nodo derecho)
	double *FComposicion; // Composicion de la atmasfera,el remanso o el deposito matlab(este inicialmente);
	double FPressure; // Presion de descarga.
	double FPref; // Presion de referencia.
	double FTemperaturaDep; // Temperature en la atmasfera o remanso.  (degC)
	double FPerdidaExtremo; // Coeficiente de perdidas en el extremo del tubo.
	double FVelocidadSonidoDep; // Velocity del sonido en el deposito adimensional.
	nmTipoDescarga FTipoDescarga;

	double FGamma3; // Son expresiones con Gamma. Se usan estas variables para no calcularlas tantas veces por instante de tiempo en la misma funcion.
	bool FModeladoEscape;

	double *FCC; // Caracteristica conocida del tubo.
	double *FCD; // Caracteristica desconocida del tubo.

	// void PutPresion(double valor);
	// void PutTemperatura(double valor);

  public:

	void PutComposicion(int i, double valor) {
		FFraccionMasicaEspecie[i] = valor;
	}

	void PutPresion(double valor) {

		FPressure = valor;

	}

	void PutTemperatura(double valor) {
		try {
			double RMezclaDep, CvMezclaDep, CpMezclaDep, GammaDep;

			FTemperaturaDep = valor;
			if(FCalculoEspecies == nmCalculoCompleto) {

				RMezclaDep = CalculoCompletoRMezcla(FComposicion[0], FComposicion[1], FComposicion[2], 0, FCalculoGamma, nmMEP);
				CpMezclaDep = CalculoCompletoCpMezcla(FComposicion[0], FComposicion[1], FComposicion[2], 0, FTemperaturaDep,
													  FCalculoGamma, nmMEP);
				GammaDep = CalculoCompletoGamma(RMezclaDep, CpMezclaDep, FCalculoGamma);

			} else if(FCalculoEspecies == nmCalculoSimple) {

				RMezclaDep = CalculoSimpleRMezcla(FComposicion[0], 0, FCalculoGamma, nmMEP);
				CvMezclaDep = CalculoSimpleCvMezcla(FTemperaturaDep, FComposicion[0], 0, FCalculoGamma, nmMEP);
				GammaDep = CalculoSimpleGamma(RMezclaDep, CvMezclaDep, FCalculoGamma);

			}
			FVelocidadSonidoDep = sqrt(FTemperaturaDep * GammaDep * RMezclaDep) / __cons::ARef;
		} catch(exception & N) {
			std::cout << "ERROR: TCCDescargaExtremoAbierto::PutTemperatura en la condicion de contorno: " << FNumeroCC << std::endl;
			std::cout << "Tipo de error: " << N.what() << std::endl;
			throw Exception(N.what());
		}
	}

	TCCDescargaExtremoAbierto(nmTypeBC TipoCC, int numCC, nmTipoCalculoEspecies SpeciesModel, int numeroespecies,
							  nmCalculoGamma GammaCalculation, bool ThereIsEGR);

	~TCCDescargaExtremoAbierto();

	void CalculaCondicionContorno(double Time);

	void ReadBoundaryData(const char *FileWAM, fpos_t &filepos, int NumberOfPipes, TTubo **Pipe, int nDPF, TDPF **DPF);

	void AsignAmbientConditions(double Tamb, double Pamb, double *AtmosphericComposition);

	void TuboCalculandose(int TuboActual) {
	}
	;

};

#endif



================================================
FILE: Source/Boundaries/TCCEntradaCompresor.cpp
================================================
/*--------------------------------------------------------------------------------*\
==========================|
 \\   /\ /\   // O pen     | OpenWAM: The Open Source 1D Gas-Dynamic Code
 \\ |  X  | //  W ave     |
 \\ \/_\/ //   A ction   | CMT-Motores Termicos / Universidad Politecnica Valencia
 \\/   \//    M odel    |
 ----------------------------------------------------------------------------------
 License

 This file is part of OpenWAM.

 OpenWAM is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 OpenWAM is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with OpenWAM.  If not, see <http://www.gnu.org/licenses/>.


 \*--------------------------------------------------------------------------------*/

//---------------------------------------------------------------------------
#pragma hdrstop

#include "TCCEntradaCompresor.h"
//#include <cmath>
#include <iostream>
#include "TCompresor.h"
#include "TTubo.h"

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

TCCEntradaCompresor::TCCEntradaCompresor(nmTypeBC TipoCC, int numCC, nmTipoCalculoEspecies SpeciesModel,
		int numeroespecies, nmCalculoGamma GammaCalculation, bool ThereIsEGR) :
	TCondicionContorno(TipoCC, numCC, SpeciesModel, numeroespecies, GammaCalculation, ThereIsEGR) {

	FTuboExtremo = NULL;
	FVelocity = 0;
	FSonido = 1;
	FPressure = 0;
	FGasto = 0;

}

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

TCCEntradaCompresor::~TCCEntradaCompresor() {

	delete[] FTuboExtremo;

}

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

void TCCEntradaCompresor::ReadBoundaryData(const char *FileWAM, fpos_t &filepos, int NumberOfPipes, TTubo **Pipe,
		int nDPF, TDPF **DPF) {
	try {
		int i = 0;

		FTuboExtremo = new stTuboExtremo[1];
		FTuboExtremo[0].Pipe = NULL;

		while(FNumeroTubosCC < 1 && i < NumberOfPipes) {
			if(Pipe[i]->getNodoIzq() == FNumeroCC) {
				FTuboExtremo[FNumeroTubosCC].Pipe = Pipe[i];
				FTuboExtremo[FNumeroTubosCC].TipoExtremo = nmLeft;
				FNodoFin = 0;
				FCC = &(FTuboExtremo[FNumeroTubosCC].Beta);
				FCD = &(FTuboExtremo[FNumeroTubosCC].Landa);
				FSeccionTubo = __geom::Circle_area(Pipe[i]->GetDiametro(FNodoFin));
				FPressure = Pipe[i]->GetPresion(FNodoFin);
				FNumeroTubosCC++;
			}
			if(Pipe[i]->getNodoDer() == FNumeroCC) {
				FTuboExtremo[FNumeroTubosCC].Pipe = Pipe[i];
				FTuboExtremo[FNumeroTubosCC].TipoExtremo = nmRight;
				FNodoFin = Pipe[i]->getNin() - 1;
				FCC = &(FTuboExtremo[FNumeroTubosCC].Landa);
				FCD = &(FTuboExtremo[FNumeroTubosCC].Beta);
				FSeccionTubo = __geom::Circle_area(Pipe[i]->GetDiametro(FNodoFin));
				FPressure = Pipe[i]->GetPresion(FNodoFin);
				FNumeroTubosCC++;
			}
			i++;
		}

		FILE *fich = fopen(FileWAM, "r");
		fsetpos(fich, &filepos);

		fscanf(fich, "%d ", &FNumeroCompresor);

		fgetpos(fich, &filepos);
		fclose(fich);

// Inicializacion del transporte de especies quimicas.
		FFraccionMasicaEspecie = new double[FNumeroEspecies - FIntEGR];
		for(int i = 0; i < FNumeroEspecies - FIntEGR; i++) {
			FFraccionMasicaEspecie[i] = FTuboExtremo[0].Pipe->GetFraccionMasicaInicial(i);
		}

	} catch(exception &N) {
		std::cout << "ERROR: TCCEntradaCompresor::AsignaTubos en la condicion de contorno: " << FNumeroCC << std::endl;
		std::cout << "Tipo de error: " << N.what() << std::endl;
		throw Exception(N.what());
	}
}
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

void TCCEntradaCompresor::AsignaCompresor(TCompresor **Compressor) {
	try {

		FCompresor = Compressor[FNumeroCompresor - 1];

	} catch(exception &N) {
		std::cout << "ERROR: TCCEntradaCompresor::AsignaCompresor en la condicion de contorno: " << FNumeroCC << std::endl;
		std::cout << "Tipo de error: " << N.what() << std::endl;
		throw Exception(N.what());
	}
}

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

void TCCEntradaCompresor::CalculaCondicionContorno(double Time) {
	try {
		double cte1 = 0., cte2 = 0., ctea = 0., numerador = 0., denominador = 0., presionact = 0.;
		int contador = 0;
		double error = 1e5;

		FGamma = FTuboExtremo[0].Pipe->GetGamma(FNodoFin);
		FGamma1 = __Gamma::G1(FGamma);
		FGamma3 = __Gamma::G3(FGamma);
		FGamma5 = __Gamma::G5(FGamma);

		FGasto = FCompresor->getMassflow();
		cte1 = FTuboExtremo[0].Entropia;
		cte2 = FGamma1 * pow2(FTuboExtremo[0].Entropia) * FGasto * __cons::ARef / (2 * FGamma * FSeccionTubo * 1e5);
		ctea = FGamma1 / FGamma;

		while(error > 1e-5 && contador < 800) {
			contador++;
			numerador = cte1 * pow(FPressure, FGamma5) + cte2 * pow(FPressure, ctea - 1) - *FCC;
			denominador = cte1 * FGamma5 * pow(FPressure, FGamma5 - 1) + cte2 * (ctea - 1) * pow(FPressure, ctea - 2);
			presionact = FPressure - numerador / denominador;
			error = fabs(FPressure - presionact);
			FPressure = presionact;
		}
		if(contador > 799) {
			printf("ERROR: TCCEntradaCompresor::CalculaCondicionContorno, no converge en entrada compresor en la condicion de contorno: %d\n",
				   FNumeroCC);
			throw Exception("ERROR: TCCEntradaCompresor::CalculaCondicionContorno no converge en entrada compresor");
		}

// Calculo de velocidad,velocidad del sonido y caracteristica reflejada.
		FSonido = FTuboExtremo[0].Entropia * pow(FPressure, FGamma5);
		FVelocity = (*FCC - FSonido) / FGamma3;
		*FCD = FSonido - FGamma3 * FVelocity;

// Segun este modelo de compresor,el flujo solo puede entrar en el compresor. Asi que la composicion
// sera la determinada por la linea de corriente que llega del tubo. Esta sera la composicion del fluido
// en el compresor. Se actualiza directamente en el compresor.

	} catch(exception &N) {
		std::cout << "ERROR: TCCEntradaCompresor::CalculaCondicionContorno en la condicion de contorno: " << FNumeroCC <<
				  std::endl;
		std::cout << "Tipo de error: " << N.what() << std::endl;
		throw Exception(N.what());
	}
}

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

#pragma package(smart_init)



================================================
FILE: Source/Boundaries/TCCEntradaCompresor.h
================================================
/*--------------------------------------------------------------------------------*\
==========================|
 \\   /\ /\   // O pen     | OpenWAM: The Open Source 1D Gas-Dynamic Code
 \\ |  X  | //  W ave     |
 \\ \/_\/ //   A ction   | CMT-Motores Termicos / Universidad Politecnica Valencia
 \\/   \//    M odel    |
 ----------------------------------------------------------------------------------
 License

 This file is part of OpenWAM.

 OpenWAM is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 OpenWAM is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with OpenWAM.  If not, see <http://www.gnu.org/licenses/>.


 \*--------------------------------------------------------------------------------*/

//---------------------------------------------------------------------------
#ifndef TCCEntradaCompresorH
#define TCCEntradaCompresorH

#include "TCondicionContorno.h"
#include <cstdio>
#include <iostream>

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

class TCompresor;

class TCCEntradaCompresor: public TCondicionContorno {
  private:

	int FNumeroCompresor;
	TCompresor *FCompresor;

	int FNodoFin; // Nodo en el extremo del tubo que esta en la condicion de contorno.
	double *FCC;          // Caracteristica conocida del tubo.
	double *FCD;          // Caracteristica desconocida del tubo.
	double FSeccionTubo;  // Diametro del tubo en la condicion de contorno.

	double FVelocity;
	double FSonido;
	double FPressure;
	double FGasto;

	double FGamma1;
	double FGamma3;
	double FGamma5;

  public:

	int getNumeroCompresor() {
		return FNumeroCompresor;
	}
	;

	TCCEntradaCompresor(nmTypeBC TipoCC, int numCC, nmTipoCalculoEspecies SpeciesModel, int numeroespecies,
						nmCalculoGamma GammaCalculation, bool ThereIsEGR);

	~TCCEntradaCompresor();

	void CalculaCondicionContorno(double Time);

	void ReadBoundaryData(const char *FileWAM, fpos_t &filepos, int NumberOfPipes, TTubo **Pipe, int nDPF, TDPF **DPF);

	void AsignaCompresor(TCompresor **Compressor);

};

#endif



================================================
FILE: Source/Boundaries/TCCExternalConnection.cpp
================================================
// ---------------------------------------------------------------------------

#pragma hdrstop

#include "TCCExternalConnection.h"
#include "TTubo.h"

// ---------------------------------------------------------------------------

TCCExternalConnection::TCCExternalConnection(nmTypeBC TipoCC, int numCC, nmTipoCalculoEspecies SpeciesModel,
		int numeroespecies, nmCalculoGamma GammaCalculation, bool ThereIsEGR) :
	TCondicionContorno(TipoCC, numCC, SpeciesModel, numeroespecies, GammaCalculation, ThereIsEGR) {

	FTuboExtremo = NULL;
	// FComposicion = NULL;

	FUExt.resize(2);
	FTExt.resize(2);
	FPExt.resize(2);
	FDExt.resize(2);
	FAExt.resize(2);
}

TCCExternalConnection::~TCCExternalConnection() {
}

void TCCExternalConnection::UpdateCurrentExternalProperties(double U0, double U1, double T0, double T1, double P0,
		double P1, double t) {

	FUExt[0] = U0;
	FUExt[1] = U1;
	FTExt[0] = T0;
	FTExt[1] = T1;
	FPExt[0] = P0;
	FPExt[1] = P1;

	FCurrentTime = t;
}

void TCCExternalConnection::AsignGeometricalData(double D0, double D1, double deltaX) {

	FDExt[0] = D0;
	FDExt[1] = D1;
	FAExt[0] = __geom::Circle_area(D0);
	FAExt[1] = __geom::Circle_area(D1);

	FDeltaX = deltaX;
}

void TCCExternalConnection::ExternalCharacteristics(double Time) {

	// Calculo Entropia
	double x = 0., Px = 0., Tx = 0., Ux = 0., Ax = 0.;
	double Deltat = Time - FCurrentTime;

	double g = __Gamma::G;
	double gg = __Gamma::G_5;

	double A0 = sqrt(g * __R::Air * FTExt[0]);
	double A1 = sqrt(g * __R::Air * FTExt[1]);

	double AA0 = A0 / pow(FPExt[0], gg);
	double AA1 = A1 / pow(FPExt[1], gg);

	if(FUExt[0] > 0) {
		x = FUExt[0] * FDeltaX / (FDeltaX / Deltat + FUExt[0] - FUExt[1]);

		FA_AExt = (AA0 * (FDeltaX - x) + AA1 * x) / FDeltaX / __cons::ARef;

	} else {
		FA_AExt = AA0 / __cons::ARef;
	}
	double UWave0 = A0 + FUExt[0];
	double UWave1 = A1 + FUExt[1];

	x = UWave0 * FDeltaX / (FDeltaX / Deltat + UWave0 - UWave1);

	Ux = (FUExt[0] * (FDeltaX - x) + FUExt[1] * x) / FDeltaX;
	Ax = (A0 * (FDeltaX - x) + A1 * x) / FDeltaX;

	double deltaEnt = Ax * (AA0 - FA_AExt * __cons::ARef) / FA_AExt / __cons::ARef;

	FK_CExt = (Ax + (g - 1) / 2 * Ux + deltaEnt) / __cons::ARef;

}

void TCCExternalConnection::CalculaCondicionContorno(double Time) {

	double flujo = 0.;

	ExternalCharacteristics(Time);

	flujo = (FK_CExt / FA_AExt) / (*FCC / FTuboExtremo[0].Entropia);

	if(flujo < 0.999995) {

		double A = FTuboExtremo[0].Entropia / (FTuboExtremo[0].Entropia + FA_AExt) * (*FCC + FK_CExt);
		FT_Boundary = pow2(A * __cons::ARef) / __R::Air / __Gamma::G;
		FU_Boundary = (A - *FCC) / __Gamma::G_3;
		*FCD = A + __Gamma::G_3 * FU_Boundary;
		FU_Boundary *= __cons::ARef;
		FP_Boundary = pow(A / FTuboExtremo[0].Entropia, __Gamma::G_4);
	} else if(flujo > 1.000005) {
		double A = FA_AExt / (FTuboExtremo[0].Entropia + FA_AExt) * (*FCC + FK_CExt);
		FT_Boundary = pow2(A * __cons::ARef) / __R::Air / __Gamma::G;
		FU_Boundary = (FK_CExt - A) / __Gamma::G_3;
		*FCD = A + __Gamma::G_3 * FU_Boundary;
		*FCC = A - __Gamma::G_3 * FU_Boundary;
		FTuboExtremo[0].Entropia = FA_AExt;
		FU_Boundary *= __cons::ARef;
		FP_Boundary = pow(A / FTuboExtremo[0].Entropia, __Gamma::G_4);

	} else {
		double A = *FCC;
		FT_Boundary = pow2(A * __cons::ARef) / __R::Air / __Gamma::G;
		FU_Boundary = 0;
		*FCD = *FCC;
		FP_Boundary = pow(A / FTuboExtremo[0].Entropia, __Gamma::G_4);
	}

}

void TCCExternalConnection::ReadBoundaryData(const char *FileWAM, fpos_t &filepos, int NumberOfPipes, TTubo **Pipe,
		int nDPF, TDPF **DPF) {

	int i = 0;

	FTuboExtremo = new stTuboExtremo[1];
	FTuboExtremo[0].Pipe = NULL;

	while(FNumeroTubosCC < 1 && i < NumberOfPipes) {
		if(Pipe[i]->getNodoIzq() == FNumeroCC) {
			FTuboExtremo[FNumeroTubosCC].Pipe = Pipe[i];
			FTuboExtremo[FNumeroTubosCC].TipoExtremo = nmLeft;
			FCC = &(FTuboExtremo[FNumeroTubosCC].Beta);
			FCD = &(FTuboExtremo[FNumeroTubosCC].Landa);
			FNodoFin = 0;
			FIndiceCC = 0;
			FNumeroTubosCC++;
		}
		if(Pipe[i]->getNodoDer() == FNumeroCC) {
			FTuboExtremo[FNumeroTubosCC].Pipe = Pipe[i];
			FTuboExtremo[FNumeroTubosCC].TipoExtremo = nmRight;
			FCC = &(FTuboExtremo[FNumeroTubosCC].Landa);
			FCD = &(FTuboExtremo[FNumeroTubosCC].Beta);
			FNodoFin = FTuboExtremo[FNumeroTubosCC].Pipe->getNin() - 1;
			FIndiceCC = 1;
			FNumeroTubosCC++;
		}
		i++;
	}

	// Inicializacion del transporte de especies quimicas.
	FFraccionMasicaEspecie = new double[FNumeroEspecies - FIntEGR];
	for(int i = 0; i < FNumeroEspecies - FIntEGR; i++) {
		FFraccionMasicaEspecie[i] = FTuboExtremo[0].Pipe->GetFraccionMasicaInicial(i);
	}

	FILE *fich = fopen(FileWAM, "r");
	fsetpos(fich, &filepos);

	fscanf(fich, "%d ", &FID);

	fgetpos(fich, &filepos);
	fclose(fich);

}

void TCCExternalConnection::LoadNewData(double* p, double* T, double* u) {

	*p = FP_Boundary;
	*T = FT_Boundary;
	*u = FU_Boundary;
}

#pragma package(smart_init)



================================================
FILE: Source/Boundaries/TCCExternalConnection.h
================================================
// ---------------------------------------------------------------------------

#ifndef TCCExternalConnectionH
#define TCCExternalConnectionH
// ---------------------------------------------------------------------------

#include "TCondicionContorno.h"

class TCCExternalConnection: public TCondicionContorno {
  private:

	dVector FUExt;
	dVector FTExt;
	dVector FPExt;

	dVector FDExt;
	dVector FAExt;

	double FDeltaX;

	double FCurrentTime;

	double FA_AExt;
	double FK_CExt;

	double FP_Boundary;
	double FT_Boundary;
	double FU_Boundary;

	double *FCC; // Caracteristica conocida del tubo.
	double *FCD; // Caracteristica desconocida del tubo.

	int FNodoFin;
	int FIndiceCC;

	int FID;

  protected:

  public:
	TCCExternalConnection(nmTypeBC TipoCC, int numCC, nmTipoCalculoEspecies SpeciesModel, int numeroespecies,
						  nmCalculoGamma GammaCalculation, bool ThereIsEGR);

	~TCCExternalConnection();

	void UpdateCurrentExternalProperties(double U0, double U1, double T0, double T1, double P0, double P1, double t);

	void AsignGeometricalData(double D0, double D1, double deltaX);

	void ExternalCharacteristics(double Time);

	void CalculaCondicionContorno(double Time);

	void ReadBoundaryData(const char *FileWAM, fpos_t &filepos, int NumberOfPipes, TTubo **Pipe, int nDPF, TDPF **DPF);

	int GetID() {
		return FID;
	}
	;

	void LoadNewData(double* p, double* T, double* u);

};
#endif



================================================
FILE: Source/Boundaries/TCCExternalConnectionVol.cpp
================================================
// ---------------------------------------------------------------------------

#pragma hdrstop

#include "TCCExternalConnectionVol.h"
#include "TTubo.h"

// ---------------------------------------------------------------------------

TCCExternalConnectionVol::TCCExternalConnectionVol(nmTypeBC TipoCC, int numCC, nmTipoCalculoEspecies SpeciesModel,
		int numeroespecies, nmCalculoGamma GammaCalculation, bool ThereIsEGR) :
	TCondicionContorno(TipoCC, numCC, SpeciesModel, numeroespecies, GammaCalculation, ThereIsEGR) {

	FTuboExtremo = NULL;
	FTime0 = 0;

	FTimeSum = 0;

	FT_BoundarySum = 0;
	FU_BoundarySum = 0;
	FP_BoundarySum = 0;

	// FComposicion = NULL;

}

TCCExternalConnectionVol::~TCCExternalConnectionVol() {
}

void TCCExternalConnectionVol::UpdateCurrentExternalProperties(double U0, double T0, double P0, double t) {

	FUExt = U0;
	FTExt = T0;
	FPExt = P0;

	FCurrentTime = t;
}

void TCCExternalConnectionVol::AsignGeometricalData(double D0, double deltaX) {

	FDExt = D0;
	FAExt = __geom::Circle_area(D0);

	FDeltaX = deltaX;
}

void TCCExternalConnectionVol::ExternalCharacteristics(double Time) {

	// Calculo Entropia
	double x = 0., Px = 0., Tx = 0., Ux = 0., Ax = 0.;
	// double Deltat = Time - FTime0;

	double g = __Gamma::G;
	double gg = __Gamma::G_5;

	double A0 = sqrt(g * __R::Air * FTExt);

	FA_AExt = A0 / pow(__units::PaToBar(FPExt), gg) / __cons::ARef;

	FK_CExt = (A0 + (g - 1) / 2 * FUExt) / __cons::ARef;

}

void TCCExternalConnectionVol::CalculaCondicionContorno(double Time) {

	double flujo = 0.;

	ExternalCharacteristics(Time);

	flujo = (FK_CExt / FA_AExt) / (*FCC / FTuboExtremo[0].Entropia);

	if(flujo < 0.999995) {

		double A = FTuboExtremo[0].Entropia / (FTuboExtremo[0].Entropia + FA_AExt) * (*FCC + FK_CExt);
		FT_Boundary = pow2(A * __cons::ARef) / __R::Air / __Gamma::G;
		FU_Boundary = (A - *FCC) / __Gamma::G_3;
		*FCD = A + __Gamma::G_3 * FU_Boundary;
		FU_Boundary *= __cons::ARef;
		FP_Boundary = pow(A / FTuboExtremo[0].Entropia, __Gamma::G_4);
	} else if(flujo > 1.000005) {
		double A = FA_AExt / (FTuboExtremo[0].Entropia + FA_AExt) * (*FCC + FK_CExt);
		FT_Boundary = pow2(A * __cons::ARef) / __R::Air / __Gamma::G;
		FU_Boundary = (FK_CExt - A) / __Gamma::G_3;
		*FCD = A + __Gamma::G_3 * FU_Boundary;
		*FCC = A - __Gamma::G_3 * FU_Boundary;
		FTuboExtremo[0].Entropia = FA_AExt;
		FU_Boundary *= __cons::ARef;
		FP_Boundary = pow(A / FTuboExtremo[0].Entropia, __Gamma::G_4);

	} else {
		double A = *FCC;
		FT_Boundary = pow2(A * __cons::ARef) / __R::Air / __Gamma::G;
		FU_Boundary = 0;
		*FCD = *FCC;
		FP_Boundary = pow(A / FTuboExtremo[0].Entropia, __Gamma::G_4);
	}
	double deltat = Time - FTime0;

	FT_BoundarySum = FT_Boundary * deltat;
	FU_BoundarySum = FU_Boundary * deltat;
	FP_BoundarySum = FP_Boundary * deltat;

	FTimeSum = deltat;

	FTime0 = Time;

}

void TCCExternalConnectionVol::ReadBoundaryData(const char *FileWAM, fpos_t &filepos, int NumberOfPipes, TTubo **Pipe,
		int nDPF, TDPF **DPF) {

	int i = 0;

	FTuboExtremo = new stTuboExtremo[1];
	FTuboExtremo[0].Pipe = NULL;

	while(FNumeroTubosCC < 1 && i < NumberOfPipes) {
		if(Pipe[i]->getNodoIzq() == FNumeroCC) {
			FTuboExtremo[FNumeroTubosCC].Pipe = Pipe[i];
			FTuboExtremo[FNumeroTubosCC].TipoExtremo = nmLeft;
			FCC = &(FTuboExtremo[FNumeroTubosCC].Beta);
			FCD = &(FTuboExtremo[FNumeroTubosCC].Landa);
			FNodoFin = 0;
			FIndiceCC = 0;
			FNumeroTubosCC++;
		}
		if(Pipe[i]->getNodoDer() == FNumeroCC) {
			FTuboExtremo[FNumeroTubosCC].Pipe = Pipe[i];
			FTuboExtremo[FNumeroTubosCC].TipoExtremo = nmRight;
			FCC = &(FTuboExtremo[FNumeroTubosCC].Landa);
			FCD = &(FTuboExtremo[FNumeroTubosCC].Beta);
			FNodoFin = FTuboExtremo[FNumeroTubosCC].Pipe->getNin() - 1;
			FIndiceCC = 1;
			FNumeroTubosCC++;
		}
		i++;
	}

	// Inicializacion del transporte de especies quimicas.
	FFraccionMasicaEspecie = new double[FNumeroEspecies - FIntEGR];
	for(int i = 0; i < FNumeroEspecies - FIntEGR; i++) {
		FFraccionMasicaEspecie[i] = FTuboExtremo[0].Pipe->GetFraccionMasicaInicial(i);
	}

	FILE *fich = fopen(FileWAM, "r");
	fsetpos(fich, &filepos);

	fscanf(fich, "%d ", &FID);

	fgetpos(fich, &filepos);
	fclose(fich);

}

void TCCExternalConnectionVol::LoadNewData(double* p, double* T, double* u) {

	if(FTimeSum > 0) {
		*p = FP_BoundarySum / FTimeSum;
		*T = FT_BoundarySum / FTimeSum;
		*u = FU_BoundarySum / FTimeSum;
	} else {
		*p = FP_Boundary;
		*T = FT_Boundary;
		*u = FU_Boundary;
	}

	FT_BoundarySum = 0;
	FU_BoundarySum = 0;
	FP_BoundarySum = 0;

	FTimeSum = 0;
}

#pragma package(smart_init)



================================================
FILE: Source/Boundaries/TCCExternalConnectionVol.h
================================================
//---------------------------------------------------------------------------

#ifndef TCCExternalConnectionVolH
#define TCCExternalConnectionVolH
//---------------------------------------------------------------------------

#include "TCondicionContorno.h"

class TCCExternalConnectionVol: public TCondicionContorno {
  private:

	double FUExt;
	double FTExt;
	double FPExt;

	double FDExt;
	double FAExt;

	double FDeltaX;

	double FCurrentTime;

	double FA_AExt;
	double FK_CExt;

	double FP_Boundary;
	double FT_Boundary;
	double FU_Boundary;

	double FP_BoundarySum;
	double FT_BoundarySum;
	double FU_BoundarySum;

	double *FCC; // Caracteristica conocida del tubo.
	double *FCD; // Caracteristica desconocida del tubo.

	int FNodoFin;
	int FIndiceCC;

	int FID;

	double FTime0;
	double FTimeSum;

  protected:

  public:
	TCCExternalConnectionVol(nmTypeBC TipoCC, int numCC, nmTipoCalculoEspecies SpeciesModel, int numeroespecies,
							 nmCalculoGamma GammaCalculation, bool ThereIsEGR);

	~TCCExternalConnectionVol();

	void UpdateCurrentExternalProperties(double U0, double T0, double P0, double t);

	void AsignGeometricalData(double D0, double deltaX);

	void ExternalCharacteristics(double Time);

	void CalculaCondicionContorno(double Time);

	void ReadBoundaryData(const char *FileWAM, fpos_t &filepos, int NumberOfPipes, TTubo **Pipe, int nDPF, TDPF **DPF);

	int GetID() {
		return FID;
	}
	;

	void LoadNewData(double* p, double* T, double* u);

};
#endif



================================================
FILE: Source/Boundaries/TCCExtremoAnecoico.cpp
================================================
/*--------------------------------------------------------------------------------*\
==========================|
 \\   /\ /\   // O pen     | OpenWAM: The Open Source 1D Gas-Dynamic Code
 \\ |  X  | //  W ave     |
 \\ \/_\/ //   A ction   | CMT-Motores Termicos / Universidad Politecnica Valencia
 \\/   \//    M odel    |
 ----------------------------------------------------------------------------------
 License

 This file is part of OpenWAM.

 OpenWAM is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 OpenWAM is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with OpenWAM.  If not, see <http://www.gnu.org/licenses/>.


 \*--------------------------------------------------------------------------------*/

//---------------------------------------------------------------------------
#pragma hdrstop

#include "TCCExtremoAnecoico.h"
#include "TTubo.h"

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

TCCExtremoAnecoico::TCCExtremoAnecoico(nmTypeBC TipoCC, int numCC, nmTipoCalculoEspecies SpeciesModel,
									   int numeroespecies, nmCalculoGamma GammaCalculation, bool ThereIsEGR) :
	TCondicionContorno(TipoCC, numCC, SpeciesModel, numeroespecies, GammaCalculation, ThereIsEGR) {

	FTuboExtremo = NULL;

}
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

TCCExtremoAnecoico::~TCCExtremoAnecoico() {

	delete[] FTuboExtremo;

}

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

void TCCExtremoAnecoico::AsignaTubos(int NumberOfPipes, TTubo **Pipe) {
	try {
		int i = 0;

		FTuboExtremo = new stTuboExtremo[1];
		FTuboExtremo[0].Pipe = NULL;

		while(FNumeroTubosCC < 1 && i < NumberOfPipes) {
			if(Pipe[i]->getNodoIzq() == FNumeroCC) {
				FTuboExtremo[FNumeroTubosCC].Pipe = Pipe[i];
				FCC = &(FTuboExtremo[FNumeroTubosCC].Beta);
				FCD = &(FTuboExtremo[FNumeroTubosCC].Landa);
				FTuboExtremo[FNumeroTubosCC].TipoExtremo = nmLeft;
				FNodoFin = 0;
				FIndiceCC = 0;
				FNumeroTubosCC++;
			}
			if(Pipe[i]->getNodoDer() == FNumeroCC) {
				FTuboExtremo[FNumeroTubosCC].Pipe = Pipe[i];
				FTuboExtremo[FNumeroTubosCC].TipoExtremo = nmRight;
				FCC = &(FTuboExtremo[FNumeroTubosCC].Landa);
				FCD = &(FTuboExtremo[FNumeroTubosCC].Beta);
				FNodoFin = FTuboExtremo[FNumeroTubosCC].Pipe->getNin() - 1;
				FIndiceCC = 1;
				FNumeroTubosCC++;
			}
			i++;
		}

// Inicializacion del transporte de especies quimicas.
		FFraccionMasicaEspecie = new double[FNumeroEspecies - FIntEGR];
		for(int i = 0; i < FNumeroEspecies - FIntEGR; i++) {
			FFraccionMasicaEspecie[i] = FTuboExtremo[0].Pipe->GetFraccionMasicaInicial(i);
		}

	} catch(exception &N) {
		std::cout << "ERROR: TCCExtremoAnecoico::AsignaTubos en la condicion de contorno: " << FNumeroCC << std::endl;
		std::cout << "Tipo de error: " << N.what() << std::endl;
		throw Exception(N.what());
	}
}

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

void TCCExtremoAnecoico::CalculaCondicionContorno(double Time) {
	try {
		double FraccionMasicaAcum = 0.;

		*FCD = FTuboExtremo[0].Entropia;

//Transporte de especies quimicas.
		for(int j = 0; j < FNumeroEspecies - 2; j++) {
			FFraccionMasicaEspecie[j] = FTuboExtremo[0].Pipe->GetFraccionMasicaCC(FIndiceCC, j);
			FraccionMasicaAcum += FFraccionMasicaEspecie[j];
		}
		FFraccionMasicaEspecie[FNumeroEspecies - 2] = 1. - FraccionMasicaAcum;
		if(FHayEGR)
			FFraccionMasicaEspecie[FNumeroEspecies - 1] = FTuboExtremo[0].Pipe->GetFraccionMasicaCC(FIndiceCC, FNumeroEspecies - 1);

	} catch(exception &N) {
		std::cout << "ERROR: TCCExtremoAnecoico::CalculaCondicionesContorno en la condicion de contorno: " << FNumeroCC <<
				  std::endl;
		std::cout << "Tipo de error: " << N.what() << std::endl;
		throw Exception(N.what());
	}
}

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

#pragma package(smart_init)




================================================
FILE: Source/Boundaries/TCCExtremoAnecoico.h
================================================
/*--------------------------------------------------------------------------------*\
==========================|
 \\   /\ /\   // O pen     | OpenWAM: The Open Source 1D Gas-Dynamic Code
 \\ |  X  | //  W ave     |
 \\ \/_\/ //   A ction   | CMT-Motores Termicos / Universidad Politecnica Valencia
 \\/   \//    M odel    |
 ----------------------------------------------------------------------------------
 License

 This file is part of OpenWAM.

 OpenWAM is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 OpenWAM is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with OpenWAM.  If not, see <http://www.gnu.org/licenses/>.


 \*--------------------------------------------------------------------------------*/

//---------------------------------------------------------------------------
#ifndef TCCExtremoAnecoicoH
#define TCCExtremoAnecoicoH

#include "TCondicionContorno.h"

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

class TCCExtremoAnecoico: public TCondicionContorno {
  private:

	int FNodoFin; // Nodo del extremo del tubo que conecta con la condicion de contorno.
	int FIndiceCC; // Posicion del vector para tomar datos del tubo para la BC (0 Nodo izquierdo; 1 Nodo derecho)
	double *FCC;          // Caracteristica conocida del tubo.
	double *FCD;          // Caracteristica desconocida del tubo.

  public:
	TCCExtremoAnecoico(nmTypeBC TipoCC, int numCC, nmTipoCalculoEspecies SpeciesModel, int numeroespecies,
					   nmCalculoGamma GammaCalculation, bool ThereIsEGR);

	~TCCExtremoAnecoico();

	void AsignaTubos(int NumberOfPipes, TTubo **Pipe);

	void CalculaCondicionContorno(double Time);

	void TuboCalculandose(int TuboActual) {
	}
	;
};

#endif




================================================
FILE: Source/Boundaries/TCCExtremoCerrado.cpp
================================================
/*--------------------------------------------------------------------------------*\
==========================|
 \\   /\ /\   // O pen     | OpenWAM: The Open Source 1D Gas-Dynamic Code
 \\ |  X  | //  W ave     |
 \\ \/_\/ //   A ction   | CMT-Motores Termicos / Universidad Politecnica Valencia
 \\/   \//    M odel    |
 ----------------------------------------------------------------------------------
 License

 This file is part of OpenWAM.

 OpenWAM is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 OpenWAM is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with OpenWAM.  If not, see <http://www.gnu.org/licenses/>.


 \*--------------------------------------------------------------------------------*/

//---------------------------------------------------------------------------
#pragma hdrstop

#include "TCCExtremoCerrado.h"
#include "TTubo.h"

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

TCCExtremoCerrado::TCCExtremoCerrado(nmTypeBC TipoCC, int numCC, nmTipoCalculoEspecies SpeciesModel, int numeroespecies,
									 nmCalculoGamma GammaCalculation, bool ThereIsEGR) :
	TCondicionContorno(TipoCC, numCC, SpeciesModel, numeroespecies, GammaCalculation, ThereIsEGR) {

	FTuboExtremo = NULL;

}
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

TCCExtremoCerrado::~TCCExtremoCerrado() {

	delete[] FTuboExtremo;

}

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

void TCCExtremoCerrado::AsignaTubos(int NumberOfPipes, TTubo **Pipe) {
	try {
		int i = 0;

		FTuboExtremo = new stTuboExtremo[1];
		FTuboExtremo[0].Pipe = NULL;

		while(FNumeroTubosCC < 1 && i < NumberOfPipes) {
			if(Pipe[i]->getNodoIzq() == FNumeroCC) {
				FTuboExtremo[FNumeroTubosCC].Pipe = Pipe[i];
				FTuboExtremo[FNumeroTubosCC].TipoExtremo = nmLeft;
				FCC = &(FTuboExtremo[FNumeroTubosCC].Beta);
				FCD = &(FTuboExtremo[FNumeroTubosCC].Landa);
				FNodoFin = 0;
				FIndiceCC = 0;
				FNumeroTubosCC++;
			}
			if(Pipe[i]->getNodoDer() == FNumeroCC) {
				FTuboExtremo[FNumeroTubosCC].Pipe = Pipe[i];
				FTuboExtremo[FNumeroTubosCC].TipoExtremo = nmRight;
				FCC = &(FTuboExtremo[FNumeroTubosCC].Landa);
				FCD = &(FTuboExtremo[FNumeroTubosCC].Beta);
				FNodoFin = FTuboExtremo[FNumeroTubosCC].Pipe->getNin() - 1;
				FIndiceCC = 1;
				FNumeroTubosCC++;
			}
			i++;
		}

// Inicializacion del transporte de especies quimicas.
		FFraccionMasicaEspecie = new double[FNumeroEspecies - FIntEGR];
		for(int i = 0; i < FNumeroEspecies - FIntEGR; i++) {
			FFraccionMasicaEspecie[i] = FTuboExtremo[0].Pipe->GetFraccionMasicaInicial(i);
		}

	} catch(exception &N) {
		std::cout << "ERROR: TCCExtremoCerrado::AsignaTubos en la condicion de contorno: " << FNumeroCC << std::endl;
		std::cout << "Tipo de error: " << N.what() << std::endl;
		throw Exception(N.what());
	}
}

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

void TCCExtremoCerrado::CalculaCondicionContorno(double Time) {
	try {
		double FraccionMasicaAcum = 0.;

		*FCD = *FCC;

//Transporte de especies quimicas.
		for(int j = 0; j < FNumeroEspecies - 2; j++) {
			FFraccionMasicaEspecie[j] = FTuboExtremo[0].Pipe->GetFraccionMasicaCC(FIndiceCC, j);
			FraccionMasicaAcum += FFraccionMasicaEspecie[j];
		}
		FFraccionMasicaEspecie[FNumeroEspecies - 2] = 1. - FraccionMasicaAcum;
		if(FHayEGR)
			FFraccionMasicaEspecie[FNumeroEspecies - 1] = FTuboExtremo[0].Pipe->GetFraccionMasicaCC(FIndiceCC, FNumeroEspecies - 1);
	} catch(exception &N) {
		std::cout << "ERROR: TCCExtremoCerrado::CalculaCondicionesContorno en la condicion de contorno: " << FNumeroCC <<
				  std::endl;
		std::cout << "Tipo de error: " << N.what() << std::endl;
		throw Exception(N.what());
	}
}

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

#pragma package(smart_init)




================================================
FILE: Source/Boundaries/TCCExtremoCerrado.h
================================================
/*--------------------------------------------------------------------------------*\
==========================|
 \\   /\ /\   // O pen     | OpenWAM: The Open Source 1D Gas-Dynamic Code
 \\ |  X  | //  W ave     |
 \\ \/_\/ //   A ction   | CMT-Motores Termicos / Universidad Politecnica Valencia
 \\/   \//    M odel    |
 ----------------------------------------------------------------------------------
 License

 This file is part of OpenWAM.

 OpenWAM is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 OpenWAM is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with OpenWAM.  If not, see <http://www.gnu.org/licenses/>.


 \*--------------------------------------------------------------------------------*/

//---------------------------------------------------------------------------
#ifndef TCCExtremoCerradoH
#define TCCExtremoCerradoH

#include "TCondicionContorno.h"

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

class TCCExtremoCerrado: public TCondicionContorno {
  private:

	int FNodoFin; // Nodo del extremo del tubo que conecta con la condicion de contorno.
	int FIndiceCC; // Posicion del vector para tomar datos del tubo para la BC (0 Nodo izquierdo; 1 Nodo derecho)
	double *FCC;    // Caracteristica conocida del tubo.
	double *FCD;    // Caracteristica desconocida del tubo.

  public:
	TCCExtremoCerrado(nmTypeBC TipoCC, int numCC, nmTipoCalculoEspecies SpeciesModel, int numeroespecies,
					  nmCalculoGamma GammaCalculation, bool ThereIsEGR);

	~TCCExtremoCerrado();

	void AsignaTubos(int NumberOfPipes, TTubo **Pipe);

	void CalculaCondicionContorno(double Time);

	void TuboCalculandose(int TuboActual) {
	}
	;
};

#endif




================================================
FILE: Source/Boundaries/TCCExtremoInyeccion.cpp
================================================
/*--------------------------------------------------------------------------------*\
==========================|
 \\   /\ /\   // O pen     | OpenWAM: The Open Source 1D Gas-Dynamic Code
 \\ |  X  | //  W ave     |
 \\ \/_\/ //   A ction   | CMT-Motores Termicos / Universidad Politecnica Valencia
 \\/   \//    M odel    |
 ----------------------------------------------------------------------------------
 License

 This file is part of OpenWAM.

 OpenWAM is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 OpenWAM is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with OpenWAM.  If not, see <http://www.gnu.org/licenses/>.


 \*--------------------------------------------------------------------------------*/

//---------------------------------------------------------------------------
#pragma hdrstop

#include "TCCExtremoInyeccion.h"
//#include <cmath>
#include <iostream>
#include "TTubo.h"

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

TCCExtremoInyeccion::TCCExtremoInyeccion(nmTypeBC TipoCC, int numCC, nmTipoCalculoEspecies SpeciesModel,
		int numeroespecies, nmCalculoGamma GammaCalculation, bool ThereIsEGR) :
	TCondicionContorno(TipoCC, numCC, SpeciesModel, numeroespecies, GammaCalculation, ThereIsEGR) {

	FTuboExtremo = NULL;
	FComposicion = NULL;
	FVelocity = 0;
	FSonido = 1;
	FPressure = 0;

}

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

TCCExtremoInyeccion::~TCCExtremoInyeccion() {

	delete[] FTuboExtremo;
	if(FComposicion != NULL)
		delete[] FComposicion;

}

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

void TCCExtremoInyeccion::ReadBoundaryData(const char *FileWAM, fpos_t &filepos, int NumberOfPipes, TTubo **Pipe,
		int nDPF, TDPF **DPF) {
	try {
		int i = 0;
		double fracciontotal = 0.;

		FTuboExtremo = new stTuboExtremo[1];
		FTuboExtremo[0].Pipe = NULL;

		while(FNumeroTubosCC < 1 && i < NumberOfPipes) {
			if(Pipe[i]->getNodoIzq() == FNumeroCC) {
				FTuboExtremo[FNumeroTubosCC].Pipe = Pipe[i];
				FTuboExtremo[FNumeroTubosCC].TipoExtremo = nmLeft;
				FNodoFin = 0;
				FIndiceCC = 0;
				FCC = &(FTuboExtremo[FNumeroTubosCC].Beta);
				FCD = &(FTuboExtremo[FNumeroTubosCC].Landa);
				FSeccion = __geom::Circle_area(Pipe[i]->GetDiametro(FNodoFin));
				FNumeroTubosCC++;
			}
			if(Pipe[i]->getNodoDer() == FNumeroCC) {
				FTuboExtremo[FNumeroTubosCC].Pipe = Pipe[i];
				FTuboExtremo[FNumeroTubosCC].TipoExtremo = nmRight;
				FNodoFin = Pipe[i]->getNin() - 1;
				FIndiceCC = 1;
				FCC = &(FTuboExtremo[FNumeroTubosCC].Landa);
				FCD = &(FTuboExtremo[FNumeroTubosCC].Beta);
				FSeccion = __geom::Circle_area(Pipe[i]->GetDiametro(FNodoFin));
				FNumeroTubosCC++;
			}
			i++;
		}

		FILE *fich = fopen(FileWAM, "r");
		fsetpos(fich, &filepos);

		fscanf(fich, "%lf %lf %lf ", &FGastoIny, &FTemperaturaIny, &FInicioIny);
		fscanf(fich, "%lf ", &FDuracionIny);

// Inicializacion del transporte de especies quimicas.
		FFraccionMasicaEspecie = new double[FNumeroEspecies - FIntEGR];
		FComposicion = new double[FNumeroEspecies - FIntEGR];
		for(int i = 0; i < FNumeroEspecies - 1; i++) {
			fscanf(fich, "%lf ", &FComposicion[i]);
			FFraccionMasicaEspecie[i] = FTuboExtremo[0].Pipe->GetFraccionMasicaInicial(i);
			fracciontotal += FComposicion[i];
		}
		if(FHayEGR) {
			FFraccionMasicaEspecie[FNumeroEspecies - 1] = FTuboExtremo[0].Pipe->GetFraccionMasicaInicial(FNumeroEspecies - 1);
			if(FCalculoEspecies == nmCalculoCompleto) {
				if(FComposicion[0] > 0.2)
					FComposicion[FNumeroEspecies - 1] = 0.;
				else
					FComposicion[FNumeroEspecies - 1] = 1.;
			} else {
				if(FComposicion[0] > 0.5)
					FComposicion[FNumeroEspecies - 1] = 1.;
				else
					FComposicion[FNumeroEspecies - 1] = 0.;
			}
		}
		if(fracciontotal != 1.) {
			std::cout <<
					  "ERROR: La fraccion masica total no puede ser distinta de 1. Repasa la lectura en la condicion de contorno  " <<
					  FNumeroCC << std::endl;
			throw Exception(" ");
		}

		fgetpos(fich, &filepos);
		fclose(fich);

	}

	catch(exception &N) {
		std::cout << "ERROR: TCCExtremoInyeccion::LeeExtremoInyeccion en la condicion de contorno: " << FNumeroCC << std::endl;
		std::cout << "Tipo de error: " << N.what() << std::endl;
		throw Exception(N.what());
	}
}

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

void TCCExtremoInyeccion::ObtencionValoresInstantaneos(double Theta) {
	try {
		double ang0 = 0.;

		FTheta = Theta;

		ang0 = FTheta - FInicioIny;
		FAngap = ang0 - floor(ang0 / 360.) * 360.;

	} catch(exception &N) {
		std::cout << "ERROR: TCCExtremoInyeccion::ObtencionValoresInstantaneos en la condicion de contorno: " << FNumeroCC <<
				  std::endl;
		std::cout << "Tipo de error: " << N.what() << std::endl;
		throw Exception(N.what());
	}
}

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

void TCCExtremoInyeccion::CalculaCondicionContorno(double Time) {
	try {
		double FraccionMasicaAcum = 0.;

		FGamma = FTuboExtremo[0].Pipe->GetGamma(FNodoFin);
		FRMezcla = FTuboExtremo[0].Pipe->GetRMezcla(FNodoFin);

		FGamma3 = __Gamma::G3(FGamma);
		FGamma5 = __Gamma::G5(FGamma);

		if(FAngap < FDuracionIny && FTheta > 720.) {
			FSonido = sqrt(FGamma * FRMezcla * __units::degCToK(FTemperaturaIny)) / __cons::ARef;
			FVelocity = (FSonido - *FCC) / FGamma3;
			FPressure = __units::PaToBar(FGastoIny * FRMezcla * __units::degCToK(FTemperaturaIny) /
										 (FVelocity * __cons::ARef * FSeccion)); // Cociente entre presion y la presion de referencia(1e5);
			if(FPressure < 0.0) {
				printf("ERROR: TCCExtremoInyeccion::CalculaCondicionContorno Velocity negativa en inyector %lf,Theta= %lf\n en la condicion de contorno: %d",
					   FVelocity * __cons::ARef, FTheta,
					   FNumeroCC);
				printf("       TCCExtremoInyeccion::CalculaCondicionContorno Presion negativa en inyector %lf\n", FPressure);
				throw Exception("");
			}
			*FCD = FSonido + FGamma3 * FVelocity;
			FTuboExtremo[0].Entropia = FSonido / pow(FPressure, FGamma5);

			//Transporte de especies quimicas.
			for(int j = 0; j < FNumeroEspecies - FIntEGR; j++) {
				FFraccionMasicaEspecie[j] = FComposicion[j];
			}

		} else {
			// No hay inyeccion,se comporta como un extremo cerrado.
			*FCD = *FCC;

			//Transporte de especies quimicas.
			for(int j = 0; j < FNumeroEspecies - 2; j++) {
				FFraccionMasicaEspecie[j] = FTuboExtremo[0].Pipe->GetFraccionMasicaCC(FIndiceCC, j);
				FraccionMasicaAcum += FFraccionMasicaEspecie[j];
			}
			FFraccionMasicaEspecie[FNumeroEspecies - 2] = 1. - FraccionMasicaAcum;
			if(FHayEGR)
				FFraccionMasicaEspecie[FNumeroEspecies - 1] = FTuboExtremo[0].Pipe->GetFraccionMasicaCC(FIndiceCC, FNumeroEspecies - 1);
		}

	} catch(exception &N) {
		std::cout << "ERROR: TCCExtremoInyeccion::CalculaCondicionContorno en la condicion de contorno: " << FNumeroCC <<
				  std::endl;
		std::cout << "Tipo de error: " << N.what() << std::endl;
		throw Exception(N.what());
	}
}

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

//void TCCExtremoInyeccion::PutIniIny(double valor)
//{
//try
//{
//
//FInicioIny=valor;
//
//}
//catch(Exception &N)
//{
//std::cout << "ERROR: TCCExtremoInyeccion::PutIniIny en la condicion de contorno: " << FNumeroCC <<  std::endl;
//std::cout << "Tipo de error: " << N.what() << std::endl;
//throw Exception(N.what());
//}
//}

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

//void TCCExtremoInyeccion::PutDuracionIny(double valor)
//{
//try
//{
//
//FDuracionIny=valor;
//
//}
//catch(Exception &N)
//{
//std::cout << "ERROR: TCCExtremoInyeccion::PutDuracionIny en la condicion de contorno: " << FNumeroCC <<  std::endl;
//std::cout << "Tipo de error: " << N.what() << std::endl;
//throw Exception(N.what());
//}
//}

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

#pragma package(smart_init)



================================================
FILE: Source/Boundaries/TCCExtremoInyeccion.h
================================================
/* --------------------------------------------------------------------------------*\
==========================|
 \\   /\ /\   // O pen     | OpenWAM: The Open Source 1D Gas-Dynamic Code
 \\ |  X  | //  W ave     |
 \\ \/_\/ //   A ction   | CMT-Motores Termicos / Universidad Politecnica Valencia
 \\/   \//    M odel    |
 ----------------------------------------------------------------------------------
 License

 This file is part of OpenWAM.

 OpenWAM is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 OpenWAM is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with OpenWAM.  If not, see <http://www.gnu.org/licenses/>.


 \*-------------------------------------------------------------------------------- */

// ---------------------------------------------------------------------------
#ifndef TCCExtremoInyeccionH
#define TCCExtremoInyeccionH

#include "TCondicionContorno.h"

// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------

class TCCExtremoInyeccion: public TCondicionContorno {
  private:

	int FNodoFin; // Nodo en el extremo del tubo que esta en la condicion de contorno.
	int FIndiceCC; // Posicion del vector para tomar datos del tubo para la BC (0 Nodo izquierdo; 1 Nodo derecho)
	double *FCC; // Caracteristica conocida del tubo.
	double *FCD; // Caracteristica desconocida del tubo.
	double FSeccion; // Diametro del tubo en la condicion de contorno.

	double FAngap;

	double FTheta; // Angulo del ciclo.
	double FVelocity;
	double FSonido;
	double FPressure;

	double FTemperaturaIny;
	double FGastoIny;
	double FDuracionIny;
	double FInicioIny;

	double *FComposicion;
	double FGamma3;
	double FGamma5;

	// void PutIniIny(double valor);

	// void PutDuracionIny(double valor);

  public:

	void PutIniIny(double valor) {
		FInicioIny = valor;
	}
	;

	void PutDuracionIny(double valor) {
		FDuracionIny = valor;
	}
	;

	TCCExtremoInyeccion(nmTypeBC TipoCC, int numCC, nmTipoCalculoEspecies SpeciesModel, int numeroespecies,
						nmCalculoGamma GammaCalculation, bool ThereIsEGR);

	~TCCExtremoInyeccion();

	void CalculaCondicionContorno(double Time);

	void ReadBoundaryData(const char *FileWAM, fpos_t &filepos, int NumberOfPipes, TTubo **Pipe, int nDPF, TDPF **DPF);

	void ObtencionValoresInstantaneos(double Theta);

};

#endif




================================================
FILE: Source/Boundaries/TCCPerdidadePresion.cpp
================================================
/*--------------------------------------------------------------------------------*\
==========================|
 \\   /\ /\   // O pen     | OpenWAM: The Open Source 1D Gas-Dynamic Code
 \\ |  X  | //  W ave     |
 \\ \/_\/ //   A ction   | CMT-Motores Termicos / Universidad Politecnica Valencia
 \\/   \//    M odel    |
 ----------------------------------------------------------------------------------
 License

 This file is part of OpenWAM.

 OpenWAM is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 OpenWAM is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with OpenWAM.  If not, see <http://www.gnu.org/licenses/>.


 \*--------------------------------------------------------------------------------*/

//---------------------------------------------------------------------------
#pragma hdrstop

#include "TCCPerdidadePresion.h"

//#include <cmath>
#ifdef __BORLANDC__
#include <vcl.h>
#endif
#include "TTubo.h"

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

TCCPerdidadePresion::TCCPerdidadePresion(nmTypeBC TipoCC, int numCC, nmTipoCalculoEspecies SpeciesModel,
		int numeroespecies, nmCalculoGamma GammaCalculation, bool ThereIsEGR) :
	TCondicionContorno(TipoCC, numCC, SpeciesModel, numeroespecies, GammaCalculation, ThereIsEGR) {

	FTuboExtremo = NULL;
	FCC = NULL;
	FCD = NULL;
	FNodoFin = NULL;
	FIndiceCC = NULL;
	FNumeroTubo = NULL;

	if(TipoCC == nmLinearPressureLoss)
		FTipoPP = nmPPLineal;
	else if(TipoCC == nmQuadraticPressureLoss)
		FTipoPP = nmPPCuadratica;
	else
		printf("ERROR en tipo de perdida de presion TCCPerdidadePresion en la condicion de contorno: %d\n", FNumeroCC);

}

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

TCCPerdidadePresion::~TCCPerdidadePresion() {
	delete[] FTuboExtremo;

	if(FNodoFin != NULL)
		delete[] FNodoFin;
	if(FIndiceCC != NULL)
		delete[] FIndiceCC;
	if(*FCC != NULL)
		delete[] FCC;
	if(*FCD != NULL)
		delete[] FCD;
	if(FNumeroTubo != NULL)
		delete[] FNumeroTubo;
}

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

void TCCPerdidadePresion::ReadBoundaryData(const char *FileWAM, fpos_t &filepos, int NumberOfPipes, TTubo **Pipe,
		int nDPF, TDPF **DPF) {
	try {
		int i = 0;
		FK = 0;

		FTuboExtremo = new stTuboExtremo[2];
		FNodoFin = new int[2];
		FIndiceCC = new int[2];
		FCC = new double*[2];
		FCD = new double*[2];
		FNumeroTubo = new int[2];

		for(int i = 0; i < 2; i++) {
			FTuboExtremo[i].Pipe = NULL;
		}

		while(FNumeroTubosCC < 2 && i < NumberOfPipes) {
			if(Pipe[i]->getNodoIzq() == FNumeroCC) {
				FTuboExtremo[FNumeroTubosCC].Pipe = Pipe[i];
				FTuboExtremo[FNumeroTubosCC].TipoExtremo = nmLeft;
				FNodoFin[FNumeroTubosCC] = 0;
				FIndiceCC[FNumeroTubosCC] = 0;
				FNumeroTubo[FNumeroTubosCC] = Pipe[i]->getNumeroTubo() - 1;
				FCC[FNumeroTubosCC] = &(FTuboExtremo[FNumeroTubosCC].Beta);
				FCD[FNumeroTubosCC] = &(FTuboExtremo[FNumeroTubosCC].Landa);
				FNumeroTubosCC++;
			}
			if(Pipe[i]->getNodoDer() == FNumeroCC) {
				FTuboExtremo[FNumeroTubosCC].Pipe = Pipe[i];
				FTuboExtremo[FNumeroTubosCC].TipoExtremo = nmRight;
				FNodoFin[FNumeroTubosCC] = Pipe[i]->getNin() - 1;
				FIndiceCC[FNumeroTubosCC] = 1;
				FNumeroTubo[FNumeroTubosCC] = Pipe[i]->getNumeroTubo() - 1;
				FCC[FNumeroTubosCC] = &(FTuboExtremo[FNumeroTubosCC].Landa);
				FCD[FNumeroTubosCC] = &(FTuboExtremo[FNumeroTubosCC].Beta);
				FNumeroTubosCC++;
			}
			i++;
		}

// Inicializacion del transporte de especies quimicas.
		FFraccionMasicaEspecie = new double[FNumeroEspecies - FIntEGR];
		for(int i = 0; i < FNumeroEspecies - FIntEGR; i++) {
			// Se elige como composicion inicial la del tubo 0. Es arbitrario.
			FFraccionMasicaEspecie[i] = FTuboExtremo[0].Pipe->GetFraccionMasicaInicial(i);
		}

		FILE *fich = fopen(FileWAM, "r");
		fsetpos(fich, &filepos);

		fscanf(fich, "%lf ", &FK); /* Coeficiente de perdidas con signo positivo */

		fgetpos(fich, &filepos);
		fclose(fich);

	} catch(exception &N) {
		std::cout << "ERROR: TCCPerdidadePresion::LecturaPerdidaPresion en la condicion de contorno: " << FNumeroCC <<
				  std::endl;
		std::cout << "Tipo de error: " << N.what() << std::endl;
		throw Exception(N.what());
	}
}

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

void TCCPerdidadePresion::TuboCalculandose(int TuboActual) {
	try {
		FTuboActual = TuboActual;
	} catch(exception &N) {
		std::cout << "ERROR: TCCPerdidadePresion::TuboCalculandose en la condicion de contorno: " << FNumeroCC << std::endl;
		std::cout << "Tipo de error: " << N.what() << std::endl;
		throw Exception(N.what());
	}
}

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

void TCCPerdidadePresion::CalculaCondicionContorno(double Time) {
	try {

		double vel_sonido_Out = 0., vel_Out = 0., vel_sonido_In = 0., vel_In = 0., xx3 = 0., ei = 0, ed = 0;
		double flujo, FraccionMasicaAcum = 0.;
		int TuboCalculado = 0;

		if(FTuboActual == 10000) {
			TuboCalculado = FTuboActual;
			FGamma = FTuboExtremo[0].Pipe->GetGamma(FNodoFin[0]);
		} else {
			for(int i = 0; i < FNumeroTubosCC; i++) {
				if(FNumeroTubo[i] == FTuboActual) {
					TuboCalculado = i;
				}
			}
			FGamma = FTuboExtremo[TuboCalculado].Pipe->GetGamma(FNodoFin[TuboCalculado]);
		}
		FGamma1 = __Gamma::G1(FGamma);
		FGamma3 = __Gamma::G3(FGamma);
		FGamma2 = __Gamma::G2(FGamma);
		FGamma5 = __Gamma::G5(FGamma);

		flujo = (*FCC[1] / FTuboExtremo[1].Entropia) / (*FCC[0] / FTuboExtremo[0].Entropia);

		if(flujo < .999995) {  /* Flujo de 0 (Saliente) a 1 (Entrante) */

			FRelacionEntropia = FTuboExtremo[0].Entropia / FTuboExtremo[1].Entropia;

			/*Acotacion del intervalo de busqueda para A1 (Velocity del sonido a la entrada)*/
			if((*FCC[0] * 2 / FGamma2) < (*FCC[0] / (FGamma3 / sqrt(FK) + 1) + 1e-6)) {
				ei = *FCC[0] / (FGamma3 / sqrt(FK) + 1) + 1e-6;
			} else {
				ei = *FCC[0] * 2 / FGamma2;
			}
			ed = *FCC[0];

			if(FTipoPP == nmPPLineal) {  /* Perdida lineal */

				ei = QuadraticEqP(FGamma1, 2 * FK, -2 * FK * *FCC[0]) + 1e-6;
				ed = *FCC[0];

				stPerdPresAdL PPAL(*FCC[0], *FCC[1], FK, FGamma, FRelacionEntropia, __cons::ARef);
				vel_sonido_Out = FindRoot(PPAL, ei, ed);
				vel_sonido_In = PPAL.A2;
				vel_In = PPAL.U2;
				vel_Out = PPAL.U1;
				xx3 = PPAL.xx3;

			} else if(FTipoPP == nmPPCuadratica) {  /* Perdida cuadratica */

				stPerdPresAd PPA(*FCC[0], *FCC[1], FK, FGamma, FRelacionEntropia);
				vel_sonido_Out = FindRoot(PPA, ei, ed);
				vel_sonido_In = PPA.A2;
				vel_In = PPA.U2;
				vel_Out = PPA.U1;
				xx3 = PPA.xx3;
				/*nuevo	if (abs(vel_sonido_Out-vel_Out)<1E-12) {
				 printf ("");
				 }               */

				if(PPA.U1 * PPA.U2 < 0) {
					PPA.U1 = 0;
					PPA.U2 = 0;
				}

			} else
				printf("Error en el tipo de perdida de presion en la condicion de contorno: %d\n", FNumeroCC);

			if(TuboCalculado == 1) {
				*FCC[1] = vel_sonido_In - FGamma3 * vel_In;
				*FCD[1] = vel_sonido_In + FGamma3 * vel_In;
				FTuboExtremo[1].Entropia = FTuboExtremo[1].Entropia * vel_sonido_In / xx3;

			} else if(TuboCalculado == 0) {
				*FCC[0] = vel_sonido_Out + FGamma3 * vel_Out;
				*FCD[0] = vel_sonido_Out - FGamma3 * vel_Out;

			} else if(TuboCalculado == 10000) {
				*FCC[1] = vel_sonido_In - FGamma3 * vel_In;
				*FCD[1] = vel_sonido_In + FGamma3 * vel_In;
				FTuboExtremo[1].Entropia = FTuboExtremo[1].Entropia * vel_sonido_In / xx3;
				*FCC[0] = vel_sonido_Out + FGamma3 * vel_Out;
				*FCD[0] = vel_sonido_Out - FGamma3 * vel_Out;

			}

			// Chemical species transport
			for(int j = 0; j < FNumeroEspecies - 2; j++) {
				FFraccionMasicaEspecie[j] = FTuboExtremo[0].Pipe->GetFraccionMasicaCC(FIndiceCC[0], j);
				FraccionMasicaAcum += FFraccionMasicaEspecie[j];
			}
			FFraccionMasicaEspecie[FNumeroEspecies - 2] = 1. - Fraccion