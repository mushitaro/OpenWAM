# OpenWAM エンジンモデル仕様書

このドキュメントは、OpenWAMエンジンシミュレーターのソースコードを解析し、その仕様と構造を明確化するためのものです。リファクタリングと再利用性の向上を目的とします。

---

## コンポーネント解析

### 1. TTubo (1次元配管モデル)

- **ファイル:** `Source/1DPipes/TTubo.cpp`, `Source/1DPipes/TTubo.h`
- **概要:** エンジンシミュレーションにおける1次元の配管（吸気管、排気管など）をモデル化するコンポーネント。内部を流れるガスの物理量（圧力、速度、温度等）を有限差分法を用いて計算します。

#### 主な責務
- パイプのジオメトリ定義と計算メッシュの生成。
- パイプ内ガスの初期状態（圧力、温度、流速、ガス組成）の初期化。
- 各時間ステップにおけるガス力学、壁面摩擦、熱伝達の計算。
- 化学種（O2, CO2, N2など）の輸送計算。
- 計算結果に基づいたパイプ内状態の更新。
- 設定ファイル（`.wam`またはJSON）からのデータ読み込みと、結果の出力。
- パイプ両端に接続される他のコンポーネントとの境界条件の連携。

#### データ構造
- クラス名は `TTubo`。
- メンバ変数はジオメトリ、熱・摩擦、流体プロパティ、数値計算ソルバー関連のカテゴリに大別され、そのほとんどが `F` プレフィックスを持つC言語スタイルのポインタ（`double*`, `double**`）で定義されています。

#### 主要なメソッド
- **`TTubo(...)` (コンストラクタ):** メンバ変数をNULLで初期化。
- **`~TTubo()` (デストラクタ):** `new`で確保された膨大な数の動的配列を `delete[]` で解放。
- **`LeeDatos...`:** C言語スタイルの`fscanf`で設定ファイルからデータを読み込む。
- **`IniciaVariablesFundamentalesTubo`:** 計算に必要な大多数の動的配列を`new`で確保し、初期値を設定。
- **`CalculaVariablesFundamentales`:** 設定された数値解法（Lax-Wendroff, TVD等）を呼び出すディスパッチャ。
- **`Transforma1Area`, `Transforma2Area`:** 物理量（圧力、流速等）とソルバーが扱う状態ベクトルとの相互変換を行う。
- **`configure_from_json`:** JSONオブジェクトから設定を読み込むモダンな初期化メソッド。

---

### 2. ACT_Sub_DLL (シリンダー内燃焼モデル)

- **ファイル:** `Source/Act/ACT_Sub_DLL.cpp`, `Source/Act/ACT_Sub_DLL.h`
- **概要:** ディーゼルエンジンのシリンダー内における閉鎖サイクル（燃料噴射、混合、燃焼、汚染物質生成）の物理現象を詳細に計算するサブモデル。DLLとして外部から呼び出されることを想定したC言語スタイルの関数群です。

#### 主な責務
- 燃料噴射プロセスのモデル化。
- シリンダー内熱力学サイクルの計算（圧力、温度、仕事量、熱損失）。
- 燃焼による熱発生率（ROHR）の計算。
- NOx（窒素酸化物）およびSoot（すす）の生成量の計算。
- Pmax（最高圧力）、IMEP（図示平均有効圧）などの性能指標の算出。

#### データ構造
- **`struct stControlElementComposition`:** 噴射燃料を複数の「要素」に分割し、各要素の燃焼過程（ガス組成、温度、NOx/Soot量など）を追跡するための核心的な構造体。
- **`struct sINtype`, `sOUTtype`:** モデルの入出力をまとめる構造体。
- その他、放射熱計算用の `stRadArray` など。

#### 主要な関数
- **`ACT(...)`:** モジュールのメイン関数（エントリーポイント）。膨大な数のポインタ配列を引数として受け取り、内部で各種計算処理を呼び出し、結果を引数の配列に書き込む。
- **`CALCULATE_CYCLE(...)`:** 閉鎖サイクル全体の計算を行う中心的な関数。時間ステップごとにエネルギーバランス式を反復計算し、圧力と温度を決定する。
- **`CALCULUS_OF_...`:** 燃料噴射速度、噴射要素の質量などを計算する一連の関数群。
- **`HEAT_COOLER(...)`:** シリンダー壁面への熱伝達量を計算する。
- **`FUNCTION_NOX(...)`, `FUNCTION_SOOT_C(...)`:** NOxとSootの生成量を計算する。特にNOx計算は、コード内にハードコーディングされた巨大なテーブルを参照する経験的モデル。

---

### 3. TCondicionContorno (境界条件 基底クラス)

- **ファイル:** `Source/Boundaries/TCondicionContorno.cpp`, `Source/Boundaries/TCondicionContorno.h`
- **概要:** すべての境界条件モデル（シリンダー、大気開放、分岐管など）の共通インターフェースを定義する**抽象基底クラス（Abstract Base Class）**です。このクラス自体はインスタンス化できず、具体的な境界条件クラス（`TCCCilindro`など）に継承されて使われます。

#### 主な責務
- すべての境界条件クラスが実装すべき純粋仮想関数を定義し、ポリモーフィズム（多態性）を実現する。
- 境界に接続されるパイプ（`TTubo`）の情報を管理する。
- 接続されたパイプから波の特性（エントロピー、λ、β）を計算するための共通機能を提供する。

#### データ構造
- クラス名は `TCondicionContorno`。
- **`FTuboExtremo`**: 接続されているパイプの端点の情報を格納する構造体 `stTuboExtremo` のポインタ配列。この構造体には、パイプオブジェクトへのポインタや、どちらの端（左/右）が接続されているかなどの情報が含まれます。
- **`FTipoCC`**: 境界条件の種類（シリンダー、分岐など）を示す `enum` 型。
- **`FNumeroTubosCC`**: この境界に接続されているパイプの数。

#### 主要なメソッド
- **`TCondicionContorno(...)` (コンストラクタ):** 共通のメンバ変数を初期化します。
- **`virtual ~TCondicionContorno() = 0` (純粋仮想デストラクタ):** このクラスが抽象クラスであることを示します。実装は `.cpp` ファイルにあり、派生クラスのデストラクタから呼び出されます。
- **`virtual void CalculaCondicionContorno(double Time) = 0` (純粋仮想関数):** 各具象境界条件クラスが、自身の物理モデルに基づいて計算を行うために**必ず実装しなければならない**中心的な関数です。
- **`virtual void ReadBoundaryData(...)`:** 設定ファイルから境界条件固有のデータを読み込むための仮想関数。各派生クラスでオーバーライドされます。
- **`CalculaCaracteristicas(double Time)`:** 接続されたパイプの端から波の特性（Landa, Beta, Entropia）を補間計算する共通メソッド。

#### 特筆すべき設計と問題点
- **良い点:** 抽象基底クラスを用いてポリモーフィズムを実現している点は、オブジェクト指向の原則に沿った良い設計です。これにより、メインループは様々な種類の境界条件を `TCondicionContorno*` ポインタを介して統一的に扱うことができます。
- **問題点:** `TTubo` と同様に、接続パイプの情報を保持する `FTuboExtremo` がC言語スタイルのポインタ配列で管理されています。この配列のメモリ確保・解放は各派生クラスの責任となっており、コードの重複とメモリリークのリスクを生んでいます。

---

### 4. BoundaryFunctions (境界条件 物理方程式ファンクタ群)

- **ファイル:** `Source/Boundaries/BoundaryFunctions.h` (`.cpp`はほぼ空)
- **概要:** このファイルは、様々な境界条件の物理モデルを記述する非線形方程式をカプセル化した、**関数オブジェクト（ファンクタ）**の集まりです。ヘッダーのみで実装が完結しています。

#### 主な責務と設計
- 各ファンクタ（`stExpansion`, `stContraction`, `stPerdPresAd`など）は、特定の物理現象（急拡大、急縮小、圧力損失など）に対応する方程式を表現します。
- 各ファンクタは構造体(`struct`)として定義され、コンストラクタで物理パラメータ（比熱比、面積比、既知の特性値など）を受け取ります。
- `operator()`（関数呼び出し演算子）をオーバーロードし、解くべき非線形方程式 `f(x) = 0` の `f(x)` の部分を実装しています。
- これらのファンクタは、具体的な境界条件クラス（例: `TCCUnionEntreTubos`）内でインスタンス化され、Brent法などの数値的根探索ソルバーに渡されて、未知の物理量（音速や流速など）を求めるために使用されます。

#### 主要なファンクタ
- **`stExpansion`**: 急拡大管における流れのモデル。
- **`stContraction`**: 急縮小管における流れのモデル。
- **`stPerdPresAd`**: 断熱された圧力損失要素のモデル。
- **`stComprVol`**: 容積式圧縮機のモデル。
- **`stCharOrigin`, `stPathOrigin`**: 特性曲線法の計算に関連するモデル。

#### 特筆すべき設計と問題点
- **良い点:**
    - 複雑な方程式を再利用可能なオブジェクトとしてカプセル化している点は良い設計です。
    - スタック上に確保される小さなオブジェクトであるため、`new`/`delete`が不要で、メモリ管理上の問題はありません。
- **問題点:**
    - **可読性の欠如:** 変数名が `AA`, `BC`, `Ga3`, `xx1` のように、物理的な意味が全く分からない非常に短い略語で命名されています。これは、元になったガス力学の専門書（おそらくBensonの著作）の数式表記をそのままコードに持ち込んだためと推測されますが、コードを読むだけでは式の意味を理解するのが極めて困難です。
    - **メンテナンス性の低さ:** 変数名が不明瞭なため、式の修正やデバッグが非常に困難です。

---

### 5. TCCCilindro (シリンダー境界モデル)

- **ファイル:** `Source/Boundaries/TCCCilindro.cpp`, `Source/Boundaries/TCCCilindro.h`
- **概要:** `TCondicionContorno`から派生した具象クラスで、パイプとエンジンシリンダー間の接続（つまり吸排気ポート）をモデル化します。エンジンシミュレーションの中核をなす境界条件です。

#### 主な責務
- **バルブ流れの計算:** シリンダー内外の圧力差と、バルブの有効断面積（リフト量と流量係数から決定）に基づき、ポートを通過するガスの質量流量と物理状態を計算する。
- **依存オブジェクトの管理:** 接続先のシリンダーオブジェクト (`TCilindro`) と、流れを制御するバルブオブジェクト (`TTipoValvula`) へのポインタを保持する。
- **仮想関数の実装:** 基底クラスで定義された純粋仮想関数 `CalculaCondicionContorno` を実装し、具体的な物理計算を行う。

#### データ構造と主要メソッド
- **`FValvula`**: バルブの挙動をカプセル化した `TTipoValvula` 型へのポインタ。`TValvula4T`（4ストローク用ポペットバルブ）、`TLamina`（リードバルブ）など、様々なバルブタイプをポリモーフィズムにより扱えるようになっている。
- **`FCilindro`**: 接続先のシリンダーオブジェクトへのポインタ。
- **`CalculaCondicionContorno(double Time)`**: メインロジック。シリンダーとパイプの圧力比から流れの方向（吸入/排出/停止）を判断し、`FlujoEntranteCilindro()` または `FlujoSalienteCilindro()` を呼び出す。
- **`FlujoEntranteCilindro()`, `FlujoSalienteCilindro()`**: `BoundaryFunctions.h` で定義されたファンクタ（`stFESub`など）を使い、非線形方程式を解いて、パイプ端での流速や音速を決定する。
- **`ReadBoundaryData(...)`**: 設定ファイルから、この境界がどのシリンダーに接続されているかといった情報を読み込む。
- **`AsignaTipoValvula(...)`**: `new` を使って具体的なバルブオブジェクト（例: `TValvula4T`）を生成し、`FValvula` ポインタに格納する。

#### 特筆すべき設計と問題点
- **良い点:** バルブのモデルを `TTipoValvula` という別の抽象クラスに分離し、ポリモーフィズムを活用している点は、拡張性の高い優れた設計です。
- **問題点（メモリ管理）:**
    - **`FTuboExtremo`**: 基底クラスから引き継いだ問題。`ReadBoundaryData`内で `new stTuboExtremo[1]` を実行し、デストラクタで `delete[]` しており、メモリ管理がこのクラスの責任になっている。
    - **`FValvula`**: `AsignaTipoValvula` で `new` されたオブジェクトが、デストラクタで `delete` されている。これは機能するものの、例外安全性がなく、現代のC++では `std::unique_ptr` を使うべきです。

---

### 6. TCCCompresor (コンプレッサー境界モデル)

- **ファイル:** `Source/Boundaries/TCCCompresor.cpp`, `Source/Boundaries/TCCCompresor.h`
- **概要:** `TCondicionContorno`から派生した具象クラス。実際のコンプレッサー物理モデル（`TCompresor`クラス）と、1D波動計算の領域（パイプやデポジット）とを接続するための「アダプター」または「インターフェース」として機能します。

#### 主な責務
- **コンポーネントの接続:** 設定ファイル（`.wam`）を読み込み、自身がどの`TCompresor`オブジェクトに関連付けられているか、また、そのコンプレッサーがどのパイプやデポジット（チャンバー）に接続されているかを特定し、ポインタを保持する。
- **計算の委譲:** `CalculaCondicionContorno`メソッドが呼び出されると、実際の物理計算は行わず、保持している`TCompresor`オブジェクトの計算メソッド（`CondicionCompresor`など）を呼び出し、計算を委譲する。
- **データの中継:** `TCompresor`オブジェクトが必要とするパイプ端の境界条件（特性値など）を渡し、計算結果をパイプ側に反映させる。

#### データ構造と主要メソッド
- **`FCompresor`**: 実際の物理モデルを持つ `TCompresor` オブジェクトへのポインタ。
- **`FTuboExtremo`, `FDeposito`, `FTuboRotor`**: コンプレッサーの入口や出口に接続されるパイプやデポジット（チャンバー）へのポインタ。
- **`AsignacionDatos(...)` / `AsignData(...)`**: このクラスの最も複雑な部分。`FCompresor`のモデルタイプ（パイプ-デポジット間、パイプ-パイプ間など）に応じて、接続先のパイプやデポジットを特定し、`FTuboExtremo`配列を動的に確保し、ポインタを格納する。この処理は、シミュレーション全体のコンポーネントリストをループしてIDを照合するという、手続き的で壊れやすい方法で行われる。
- **`CalculaCondicionContorno(double Time)`**: 実際の計算を`FCompresor`オブジェクトに委譲するディスパッチャとして機能する。

#### 特筆すべき設計と問題点
- **設計:** 境界条件のインターフェースとしての役割(`TCCCompresor`)と、物理モデルそのもの(`TCompresor`)を分離している点は、関心の分離の観点から見て良い設計です。
- **問題点:**
    - **メモリ管理:** `TCCCilindro`と同様に、`AsignacionDatos`内でコンプレッサーのモデルに応じて`new stTuboExtremo[1]`や`new stTuboExtremo[2]`を実行し、デストラクタで`delete[]`している。これは基底クラス`TCondicionContorno`の設計に起因する問題であり、リファクタリングの主要なターゲットです。
    - **複雑な初期化処理:** `AsignacionDatos`メソッドが、グローバルなリストを探索してコンポーネント間の接続を確立するという非常に手続き的なロジックを持っており、コードの理解を困難にし、変更を難しくしています。

---

### 7. TCCCompresorVolumetrico (容積式コンプレッサー境界モデル)

- **ファイル:** `Source/Boundaries/TCCCompresorVolumetrico.cpp`, `Source/Boundaries/TCCCompresorVolumetrico.h`
- **概要:** `TCondicionContorno`から派生した具象クラス。性能マップの代わりに、運転条件（回転数、圧力比）に関する**多項式**を用いて性能を記述する容積式コンプレッサー（スーパーチャージャーなど）をモデル化します。

#### 主な責務
- **性能計算:** 設定ファイルから読み込んだ性能多項式の係数に基づき、現在の運転条件での質量流量、出口温度、消費馬力を計算する。
- **境界条件の解決:** 計算された質量流量を境界条件として、`BoundaryFunctions.h`の`stComprVol`ファンクタと根探索ソルバー（`FindRoot`）を用いて、接続されたパイプ端の流速と音速を決定する。

#### データ構造と主要メソッド
- **`FRegimen`, `FRelacionVelocidadesCV`**: コンプレッサーの回転数を定義する変数。エンジン回転数に同期、または独立して設定可能。
- **`FC1Caudal`, `FC2Caudal`, ... `FC6Potencia`**: 流量、温度、馬力を計算するための多項式係数群。
- **`LeeCCCompresorVol(...)`**: `.wam`ファイルから`fscanf`を使い、上記の多項式係数や回転数の制御方法などを読み込む。
- **`CalculaCondicionContorno(double Time)`**: メインの計算ロジック。
    1. 多項式を評価して、現在の運転条件における質量流量 `FGasto`、出口温度 `FTemperature`、消費動力 `FPotencia` を計算する。
    2. `stComprVol`ファンクタをインスタンス化し、計算された`FGasto`をターゲットとして、パイプ端の流速 `FVelocity` を求める。
    3. 最終的なパイプ端の状態（リーマン不変量）を更新する。

#### 特筆すべき設計と問題点
- **設計:** 遠心式コンプレッサーとは異なる、多項式ベースの単純化されたモデルを実装しており、コンポーネントの選択肢を提供しています。
- **問題点:**
    - **メモリ管理:** これまでの派生クラスと同様に、`LeeCCCompresorVol`内で`new stTuboExtremo[1]`を実行し、デストラクタで`delete[]`しています。また、`FComposicion`配列も同様に手動で管理されています。`std::vector`への移行が強く推奨されます。
    - **データ構造:** 多数の多項式係数が`FC1Caudal`, `FC2Caudal`...のように個別の`double`変数として定義されており、煩雑です。`std::array<double, 3> caudalCoeffs;`のように配列や構造体でまとめることで、よりクリーンになります。
    - **I/O:** `fscanf`によるデータ読み込みは、依然として堅牢性に欠ける問題点です。

---

### 8. TCCDeposito (デポジット境界モデル)

- **ファイル:** `Source/Boundaries/TCCDeposito.cpp`, `Source/Boundaries/TCCDeposito.h`
- **概要:** `TCondicionContorno`から派生した、非常に汎用性の高い具象クラス。パイプとデポジット（0次元の気体溜め。サージタンクやプレナムチャンバーなど）との接続をモデル化します。

#### 主な責務
- **汎用的な流れの計算:** パイプとデポジット間の圧力差に基づき、接続部を通過するガスの質量流量と物理状態を計算する。
- **流れの制御:** 実際の物理的接続（固定オリフィス、スロットルバルブ、ウェイストゲート等）を表現する`TTipoValvula`オブジェクトを保持し、そのオブジェクトの特性（主に流量係数CD）に応じて流れを計算する。
- **仮想関数の実装:** 基底クラスの`CalculaCondicionContorno`を実装し、具体的な物理計算を行う。

#### データ構造と主要メソッド
- **`FDeposito`**: 接続先のデポジットオブジェクトへのポインタ。
- **`FValvula`**: この境界の流量特性を決定する`TTipoValvula`オブジェクトへのポインタ。このクラスの柔軟性の核となる部分。
- **`AsignaTipoValvula(...)`**: `TCCCilindro`と同様に、`new`を使い、設定ファイルで指定された具体的なバルブ/オリフィスオブジェクト（`TCDFijo`, `TMariposa`等）を生成し、`FValvula`ポインタに格納する。
- **`CalculaCoeficientesDescarga(...)`**: `FValvula`オブジェクトの状態を更新し（例：スロットル開度を計算）、現在の流量係数（CD値）を取得する。
- **`CalculaCondicionContorno(double Time)`**: `TCCCilindro`とほぼ同様のロジック。流れの方向を決定し、`CalculaCoeficientesDescarga`を呼び出し、`BoundaryFunctions.h`のファンクタを用いて流れの状態を解き、パイプの境界条件を更新する。

#### 特筆すべき設計と問題点
- **良い点:** `TCCCilindro`と同様、`TTipoValvula`のサブクラスを付け替えることで、単一のクラスで多様な物理的接続を表現できる、非常に優れたポリモーフィックな設計になっています。
- **問題点（メモリ管理）:** これまでのクラスと全く同じ問題を抱えています。
    - `ReadBoundaryData`内で`new stTuboExtremo[1]`を実行し、デストラクタで`delete[]`している。
    - `AsignaTipoValvula`内で`new`されたバルブオブジェクトを、デストラクタで`delete`している。
    - 改善策も同様で、基底クラスでの`std::vector`化と、`FValvula`の`std::unique_ptr`化が有効です。

---

### 9. TCCDescargaExtremoAbierto (開口端境界モデル)

- **ファイル:** `Source/Boundaries/TCCDescargaExtremoAbierto.cpp`, `Source/Boundaries/TCCDescargaExtremoAbierto.h`
- **概要:** `TCondicionContorno`から派生した具象クラス。パイプの端が大気に開放されている、あるいは圧力・温度・組成が一定の巨大な空間（リザーバー）に接続されている状態をモデル化します。

#### 主な責務
- **流れの計算:** パイプ端と外部空間との圧力差に基づき、流出または流入を計算する。
- **外部条件の保持:** 外部空間の圧力、温度、ガス組成を保持する。
- **仮想関数の実装:** `CalculaCondicionContorno`を実装し、特性曲線法に基づいた開口端の標準的な解法を適用する。

#### データ構造と主要メソッド
- **`FTipoDescarga`**: 境界の種類を定義するenum。`nmDescargaAtmosfera`（大気開放）、`nmDescargaRemanso`（指定されたリザーバー）など。
- **`FPressure`, `FTemperaturaDep`**: 外部空間の圧力と温度。
- **`FComposicion`**: 外部空間のガス組成を保持する配列。
- **`FPerdidaExtremo`**: 流れの出入り口における圧力損失係数。
- **`ReadBoundaryData(...)`**: `.wam`ファイルから、接続パイプを特定し、リザーバーの圧力・温度・組成などのデータを読み込む。
- **`AsignAmbientConditions(...)`**: `FTipoDescarga`が`nmDescargaAtmosfera`の場合に、グローバルな大気条件をこの境界に設定する。
- **`CalculaCondicionContorno(double Time)`**: メインの計算ロジック。パイプから来る特性曲線と外部空間の圧力状態を比較し、流れが流出か、流入か、停止しているかを判断する。それぞれのケースについて、音速や流速を計算し、パイプ端の境界条件を更新する。

#### 特筆すべき設計と問題点
- **設計:** 特性曲線法に基づく標準的な開口端モデルを実装しており、エンジンシミュレーションの基本的な要素として不可欠です。
- **問題点（メモリ管理）:** これまでの具象境界クラスと全く同じ問題を抱えています。
    - `ReadBoundaryData`内で`new stTuboExtremo[1]`を実行し、デストラクタで`delete[]`している。
    - `FComposicion`と`FFraccionMasicaEspecie`も`new[]`で確保され、デストラクタで`delete[]`されている。
    - 改善策も一貫しており、`std::vector`への置き換えが推奨されます。

---

### 10. TCCEntradaCompresor (コンプレッサー入口境界モデル)

- **ファイル:** `Source/Boundaries/TCCEntradaCompresor.cpp`, `Source/Boundaries/TCCEntradaCompresor.h`
- **概要:** `TCondicionContorno`から派生した具象クラス。コンプレッサー（`TCCCompresor`）にパイプからガスが流入する際の、そのパイプ側の境界条件をモデル化するための補助的なクラスです。

#### 主な責務
- **コンプレッサーとの連携:** 自身がどのコンプレッサー（`TCompresor`）に属する入口なのかを識別し、そのコンプレッサーオブジェクトへのポインタを保持する。
- **境界条件の計算:** `TCCCompresor`側で計算された質量流量`FGasto`を**入力として受け取り**、その流量がパイプ端で成立するような圧力`FPressure`をニュートン・ラフソン法で反復計算する。
- **パイプ状態の更新:** 計算された圧力、音速、流速に基づき、パイプのリーマン不変量を更新する。

#### データ構造と主要メソッド
- **`FNumeroCompresor`**: 自身が関連付けられているコンプレッサーのID。
- **`FCompresor`**: 関連付けられた`TCompresor`オブジェクトへのポインタ。
- **`ReadBoundaryData(...)`**: `.wam`ファイルから、接続パイプと、自身が属するコンプレッサーのIDを読み込む。
- **`AsignaCompresor(...)`**: 外部から`TCompresor`オブジェクトへのポインタを受け取り、メンバ変数に格納する。
- **`CalculaCondicionContorno(double Time)`**: メインロジック。`FCompresor->getMassflow()`で質量流量を取得し、それを満たすパイプ端の圧力を反復計算で求める。

#### 特筆すべき設計と問題点
- **設計:** このクラスの存在は、コンポーネント接続の設計がやや不自然であることを示唆しています。本来であれば、コンプレッサーという単一の物理コンポーネントは、入口と出口を持つ単一の境界条件オブジェクトで表現されるべきかもしれません。現状では、`TCCCompresor`（本体＋出口）と`TCCEntradaCompresor`（入口）という２つの境界条件クラスが協調して１つのコンプレッサーを表現しており、処理の順序に暗黙的な依存関係が生まれています。
- **問題点（メモリ管理）:** これまでのクラスと同様、`ReadBoundaryData`内で`new stTuboExtremo[1]`を実行し、デストラクタで`delete[]`しています。改善計画は他の境界クラスと共通です。

---

### 11. TCCExternalConnection (外部接続境界モデル)

- **ファイル:** `Source/Boundaries/TCCExternalConnection.cpp`, `Source/Boundaries/TCCExternalConnection.h`
- **概要:** `TCondicionContorno`から派生した具象クラス。OpenWAMシミュレーションと外部プログラム（例：制御モデル、別のシミュレーター）との**協調シミュレーション（コ・シミュレーション）**を可能にするための境界条件です。

#### 主な責務
- **外部データ入力:** 外部プログラムから、各タイムステップにおける境界の状態（圧力、温度、流速）を受け取るためのAPIを提供する。
- **境界条件の計算:** 外部から与えられた状態を、特性曲線法で用いられるリーマン不変量に変換し、パイプ端の境界条件として適用する。
- **結果の出力:** OpenWAM側で計算されたパイプ端の最終的な状態（圧力、温度、流速）を、外部プログラムが取得するためのAPIを提供する。

#### データ構造と主要メソッド
- **`FUExt`, `FTExt`, `FPExt`**: `std::vector<double>`のtypedefである`dVector`型。外部から与えられた速度、温度、圧力のデータを保持する。**このクラスが`std::vector`を使用している点は、他のクラスが従うべき良い手本です。**
- **`FID`**: この外部接続を識別するためのID。
- **`UpdateCurrentExternalProperties(...)`**: 外部プログラムがこの関数を呼び出し、境界の状態（P, T, U）をOpenWAMに渡すための**入力API**。
- **`ExternalCharacteristics(...)`**: `UpdateCurrentExternalProperties`で受け取った物理量を、シミュレーション内部で使われる特性値（リーマン不変量）に変換する。
- **`CalculaCondicionContorno(double Time)`**: OpenWAMのソルバーから呼び出されるメインロジック。パイプの内部状態と、`ExternalCharacteristics`で計算された外部状態を比較し、相互作用を解く。
- **`LoadNewData(...)`**: 外部プログラムがこの関数を呼び出し、OpenWAM側で計算された最終的な境界の状態を取得するための**出力API**。

#### 特筆すべき設計と問題点
- **良い点:**
    - コ・シミュレーションのための明確なAPI（`Update`と`Load`）を提供しており、アダプターパターンとしてうまく機能しています。
    - **`std::vector`を積極的に使用しており、このファイル単体ではメモリ管理の問題が少ないです。これはプロジェクト全体のリファクタリングにおける理想的な姿を示しています。**
- **問題点:**
    - 基底クラスの設計に起因する問題は残存しています。`ReadBoundaryData`内で依然として`new stTuboExtremo[1]`が呼び出されており、手動メモリ管理から完全には脱却できていません。

---

### 12. TCCExternalConnectionVol (外部接続境界モデル - 時間平均)

- **ファイル:** `Source/Boundaries/TCCExternalConnectionVol.cpp`, `Source/Boundaries/TCCExternalConnectionVol.h`
- **概要:** `TCCExternalConnection`とほぼ同じ目的を持つ、協調シミュレーション用の境界条件クラス。主な違いは、外部プログラムとのデータ交換の方法にあります。

#### 主な責務とロジック
- **データ交換の差異:**
    - **入力:** `UpdateCurrentExternalProperties`は、`TCCExternalConnection`が2点の状態（勾配を定義するため）を受け取るのに対し、このクラスは単一の状態点（P, T, U）を受け取る。
    - **出力:** `LoadNewData`は、瞬時値を返す`TCCExternalConnection`とは異なり、前回この関数が呼ばれてからの**時間平均値**を返す。これは、時間ステップの異なるソルバー同士を結合する際に、より安定した結果を得るために役立つ。
- **計算ロジック:** `CalculaCondicionContorno`の物理的な計算ロジックは`TCCExternalConnection`と同一。違いは、計算結果をタイムステップごとに積算し、`LoadNewData`が呼ばれた際に平均値を計算して返す点にある。

#### 特筆すべき設計と問題点
- **良い点:** 異なる時間スケールを持つモデル間の結合を考慮した、時間平均という実用的な機能を提供しています。
- **問題点:**
    - **コードの重複:** `TCCExternalConnection`と機能・コードが大部分重複しています。これは、単一の`TCCExternalConnection`クラスに「平均化モード」のようなフラグや戦略を持たせることで、一つのクラスに統合できる可能性が高いです。コードの重複はメンテナンスコストを増大させます。
    - **メモリ管理:** `TCCExternalConnection`と異なり、こちらはメンバ変数に`std::vector`を使用していません（単一の値しか保持しないため）。しかし、やはり基底クラスに起因する`FTuboExtremo`の手動メモリ管理問題は抱えています。

---

### 13. TCCExtremoAnecoico (無響端境界モデル)

- **ファイル:** `Source/Boundaries/TCCExtremoAnecoico.cpp`, `Source/Boundaries/TCCExtremoAnecoico.h`
- **概要:** `TCondicionContorno`から派生した具象クラス。計算領域の末端で圧力波が反射しないようにするための、純粋に数学的な境界条件です。「無響端」や「非反射端」と呼ばれます。

#### 主な責務
- **波の無反射:** パイプの端に到達した波が、反射せずにドメイン外にスムーズに流れ出るように境界条件を設定する。
- **仮想関数の実装:** `CalculaCondicionContorno`を実装し、無響端の物理モデルを適用する。

#### データ構造と主要メソッド
- **`AsignaTubos(...)`**: 接続される単一のパイプを特定し、そのパイプの特性（`FCC`, `FCD`）へのポインタを設定する。
- **`CalculaCondicionContorno(double Time)`**: このクラスの核心となる、非常にシンプルなロジック。
    - `*FCD = FTuboExtremo[0].Entropia;` という一行で実装されています。
    - これは、パイプから出ていく特性（`*FCD`）が、パイプ端の局所的なエントロピー（流れに乗って運ばれる特性）と等しい、という条件を課しています。これにより、外部からの波の侵入（反射）がゼロになり、無響端として機能します。

#### 特筆すべき設計と問題点
- **設計:** 1Dシミュレーションにおいて、対象とする配管系以外の部分を無視したり、非常に長いパイプを模擬したりする場合に不可欠な、標準的で重要な境界条件です。実装も非常にシンプルで効率的です。
- **問題点（メモリ管理）:** これまでのクラスと全く同じ問題を抱えています。
    - `AsignaTubos`内で`new stTuboExtremo[1]`を実行し、デストラクタで`delete[]`している。
    - `FFraccionMasicaEspecie`も`new[]`で確保され、デストラクタで`delete[]`されている。
    - 改善策も一貫しており、`std::vector`への置き換えが推奨されます。

---

### 14. TCCExtremoCerrado (閉鎖端境界モデル)

- **ファイル:** `Source/Boundaries/TCCExtremoCerrado.cpp`, `Source/Boundaries/TCCExtremoCerrado.h`
- **概要:** `TCondicionContorno`から派生した具象クラス。パイプの端が固い壁で閉じられている状態をモデル化します。

#### 主な責務
- **流れの完全な反射:** パイプ端での流速をゼロに設定し、到達した圧力波を完全に反射させる。
- **仮想関数の実装:** `CalculaCondicionContorno`を実装し、閉鎖端の物理モデルを適用する。

#### データ構造と主要メソッド
- **`AsignaTubos(...)`**: 接続される単一のパイプを特定し、そのパイプの特性（`FCC`, `FCD`）へのポインタを設定する。
- **`CalculaCondicionContorno(double Time)`**: このクラスの核心となる、非常にシンプルなロジック。
    - `*FCD = *FCC;` という一行で実装されています。
    - これは、閉鎖端では流速がゼロ `U=0` であるという物理条件を意味します。リーマン不変量の定義（`Landa = A + k*U`, `Beta = A - k*U`）から、`U=0`ならば`Landa = Beta`となります。つまり、出ていく特性（`*FCD`）と入ってくる特性（`*FCC`）が等しくなり、波が完全に反射します。

#### 特筆すべき設計と問題点
- **設計:** 無響端と並び、1Dシミュレーションにおける最も基本的で重要な境界条件の一つです。実装は極めてシンプルかつ効率的です。
- **問題点（メモリ管理）:** これまでの具象境界クラスと全く同じ問題を抱えています。
    - `AsignaTubos`内で`new stTuboExtremo[1]`を実行し、デストラクタで`delete[]`している。
    - `FFraccionMasicaEspecie`も`new[]`で確保され、デストラクタで`delete[]`されている。
    - 改善策も一貫しており、`std::vector`への置き換えが推奨されます。

---

### 15. TCCExtremoInyeccion (噴射端境界モデル)

- **ファイル:** `Source/Boundaries/TCCExtremoInyeccion.cpp`, `Source/Boundaries/TCCExtremoInyeccion.h`
- **概要:** `TCondicionContorno`から派生した具象クラス。パイプの端から、指定された質量流量・温度・ガス組成の流体を、指定された期間（クランク角ベース）だけ噴射する境界をモデル化します。

#### 主な責務
- **時間制御噴射:** クランク角で定義された開始時期と期間に基づき、噴射のON/OFFを制御する。
- **噴射流のモデル化:** 噴射がONの場合、指定された質量流量と温度を持つ流れを境界条件として設定する。
- **非噴射時の挙動:** 噴射がOFFの場合、閉鎖端として振る舞う。

#### データ構造と主要メソッド
- **`FGastoIny`, `FTemperaturaIny`**: 噴射される流体の質量流量(kg/s)と温度(℃)。
- **`FInicioIny`, `FDuracionIny`**: 噴射の開始角度と持続期間（クランク角°CA）。
- **`FComposicion`**: 噴射される流体のガス組成。
- **`ReadBoundaryData(...)`**: `.wam`ファイルから上記の噴射パラメータを`fscanf`で読み込む。
- **`ObtencionValoresInstantaneos(...)`**: 現在のクランク角を受け取り、噴射期間内かどうかを判定する。
- **`CalculaCondicionContorno(double Time)`**: メインロジック。噴射期間内であれば、噴射条件（質量流量、温度）とパイプから来る特性波を連立させて解き、パイプ端の状態を決定する。期間外であれば、`TCCExtremoCerrado`と同様に`*FCD = *FCC`として振る舞う。

#### 特筆すべき設計と問題点
- **設計:** 燃料噴射（ポート噴射）や二次空気導入など、時間制御される質量流量の境界をモデル化するための汎用的なクラスです。
- **問題点（メモリ管理）:** これまでのクラスと同様に、`FTuboExtremo`, `FComposicion`, `FFraccionMasicaEspecie`が手動でメモリ管理されており、リファクタリングが必要です。

---

### 16. TCCPerdidadePresion (圧力損失モデル)

- **ファイル:** `Source/Boundaries/TCCPerdidadePresion.cpp`, `Source/Boundaries/TCCPerdidadePresion.h`
- **概要:** `TCondicionContorno`から派生した具象クラス。2本のパイプを接続し、その間の圧力損失をモデル化します。触媒コンバーターやフィルターなど、流れに対する抵抗要素を単純化して表現するために使用されます。

#### 主な責務
- **圧力損失の計算:** 2本のパイプ間の流れに対し、設定ファイルで指定された抵抗係数 `FK` に基づいて圧力損失を計算する。
- **モデル選択:** 圧力損失を流速の1乗に比例させる「線形モデル」(`nmLinearPressureLoss`)と、2乗に比例させる「二次モデル」(`nmQuadraticPressureLoss`)を選択できる。
- **境界条件の解決:** `BoundaryFunctions.h`のファンクタ (`stPerdPresAdL` または `stPerdPresAd`) を使用して、圧力損失を考慮した非線形方程式を解き、両パイプ端の状態を決定する。

#### データ構造と主要メソッド
- **`FTipoPP`**: 圧力損失のモデル（線形/二次）を保持するenum。
- **`FK`**: 圧力損失の大きさを決定する抵抗係数。
- **`ReadBoundaryData(...)`**: `.wam`ファイルから抵抗係数 `FK` を読み込み、接続する2本のパイプを特定する。
- **`CalculaCondicionContorno(double Time)`**: メインロジック。流れの方向を判断し、対応するファンクタをインスタンス化して根探索ソルバー `FindRoot` を呼び出し、両パイプ端のリーマン不変量を更新する。

#### 特筆すべき設計と問題点
- **設計:** 異なる圧力損失モデルをenumで切り替えるシンプルな実装です。
- **問題点（メモリ管理）:** これまでのクラスと同様に、`FTuboExtremo`や`FFraccionMasicaEspecie`などの配列が `new[]` で確保され、デストラクタで `delete[]` されています。RAIIへの移行が強く推奨されます。

---

### 17. TCCUnionEntreTubos (断面積変化モデル)

- **ファイル:** `Source/Boundaries/TCCUnionEntreTubos.cpp`, `Source/Boundaries/TCCUnionEntreTubos.h`
- **概要:** `TCondicionContorno`から派生した具象クラス。直径の異なる2本のパイプを接続し、流れの**急拡大（Sudden Expansion）**または**急縮小（Sudden Contraction）**をモデル化します。

#### 主な責務
- **流れの方向判断:** 2本のパイプ間の圧力差から、流れが小径→大径（急拡大）か、大径→小径（急縮小）かを判断する。
- **境界条件の計算:**
    - **急拡大:** `BoundaryFunctions.h`の`stExpansion`ファンクタを使用し、運動量保存則とエネルギー保存則に基づいた方程式を解く。
    - **急縮小:** `BoundaryFunctions.h`の`stContraction`ファンクタを使用し、経験的な損失係数を考慮した方程式を解く。
- **状態の更新:** 計算結果に基づき、両パイプ端のリーマン不変量とエントロピーを更新する。

#### データ構造と主要メソッド
- **`ReadBoundaryData(...)`**: 接続する2本のパイプを特定し、直径の大小関係から自動的にパイプを `FTuboExtremo[0]` (小径) と `FTuboExtremo[1]` (大径) に割り当てる。
- **`CalculaCondicionContorno(double Time)`**: メインロジック。流れの方向に応じて `stExpansion` または `stContraction` ファンクタを呼び出し、`FindRoot` で解を求める。

#### 特筆すべき設計と問題点
- **設計:** ガス力学の標準的なモデルをファンクタとしてカプセル化し、それを呼び出すことで実装されており、物理モデルと境界条件クラスの関心が分離されています。
- **問題点（メモリ管理）:** 他の境界クラスと全く同じ手動メモリ管理の問題を抱えています。`FTuboExtremo`配列などが `new[]` で確保されています。

---

### 18. TCCRamificacion (配管分岐モデル)

- **ファイル:** `Source/Boundaries/TCCRamificacion.cpp`, `Source/Boundaries/TCCRamificacion.h`
- **概要:** `TCondicionContorno`から派生した具象クラス。3本以上のパイプが一点で接続する**分岐管**をモデル化します。

#### 主な責務
- **圧力と質量の保存:** 分岐点において、全パイプで圧力が等しく、流入する質量流量と流出する質量流量の合計がゼロになる、という物理法則を適用する。
- **エントロピーの混合:** 複数のパイプから流れ込む場合、それらの流れの質量流量で加重平均されたエントロピーを計算し、流出するパイプの境界条件として適用する。
- **反復計算:** 分岐点での圧力（に相当する音速）を仮定し、そこから各パイプの流速を計算し、質量保存が満たされるまで圧力を修正する、という反復計算を行う。

#### データ構造と主要メソッド
- **`AsignaTubos(...)`**: この境界に接続されている全てのパイプを検出し、`FTuboExtremo`配列に格納する。
- **`CalculaCondicionContorno(double Time)`**: メインロジック。`do-while`ループ内で、分岐点の音速を反復計算し、全てのパイプの境界条件を同時に決定する。

#### 特筆すべき設計と問題点
- **設計:** 複数のパイプを扱うため、他の境界クラスよりも複雑なロジックを持っています。質量とエネルギーの保存則に基づいた、標準的な分岐管モデルです。
- **問題点（メモリ管理）:** 接続するパイプの数が可変であるにも関わらず、全ての動的配列 (`FTuboExtremo`, `FVelocity`, `FDensidad`など) がC言語スタイルの `new[]`/`delete[]` で管理されており、特にリファクタリングの恩恵が大きいクラスです。`std::vector`への置き換えが必須です。

---

### 19. TCCUnionEntreDepositos (デポジット間接続モデル)

- **ファイル:** `Source/Boundaries/TCCUnionEntreDepositos.cpp`, `Source/Boundaries/TCCUnionEntreDepositos.h`
- **概要:** `TCondicionContorno`から派生した具象クラス。2つの0次元チャンバー（`TDeposito`）を、バルブやオリフィスなどの流量制限要素を介して接続します。

#### 主な責務
- **デポジット間の流量計算:** 2つのデポジットの圧力差と、間にあるバルブ等の流量特性（`TTipoValvula`）に基づき、それらの間を流れる質量流量を計算する。
- **ポリモーフィックなバルブ利用:** `TCCDeposito`と同様に、`TTipoValvula`のサブクラス（`TCDFijo`, `TValvula4T`など）へのポインタを保持し、様々な種類の接続をポリモーフィズムによって実現する。
- **状態の更新:** 計算された質量流量を、接続されている両方のデポジットに（一方は流入、もう一方は流出として）渡す。

#### データ構造と主要メソッド
- **`FDeposito1`, `FDeposito2`**: 接続される2つの`TDeposito`オブジェクトへのポインタ。
- **`FValvula`**: 流量特性を決定する`TTipoValvula`オブジェクトへのポインタ。
- **`LeeUEDepositos(...)`**: `.wam`ファイルから接続する2つのデポジトのIDを読み込む。
- **`AsignaTipoValvula(...)`**: `TCCDeposito`と同様に、具体的なバルブオブジェクトを`new`で生成し、`FValvula`ポインタに格納する。
- **`CalculaCondicionContorno(double Time)`**: メインロジック。デポジット間の圧力差から流れの方向を判断し、準定常流れの式を用いて質量流量を計算する。

#### 特筆すべき設計と問題点
- **良い点:** `TCCDeposito`や`TCCCilindro`と共通の、ポリモーフィズムを活用した柔軟な設計です。
- **問題点:** このクラスはパイプ（1D）に直接接続されないため、`TCondicionContorno`から派生しているのは設計としてやや不自然です。`FTuboExtremo`配列は使用されませんが、`FValvula`の手動メモリ管理など、共通の問題は抱えています。将来的には、`TCondicionContorno`とは別の、0Dコンポーネント間接続のための基底クラスを設けるべきかもしれません。

---

### 20. TEntradaPulso, TCCPulso, TCCPreVble (時系列データ境界)

- **ファイル:** `Source/Boundaries/TEntradaPulso.h`, `TCCPulso.cpp`, `TCCPreVble.cpp`など
- **概要:** `TEntradaPulso`は、時系列データ（時間, 圧力, 温度/エントロピー）をファイルから読み込み、指定された時刻の値を線形補間で提供するヘルパークラスです。`TCCPulso`と`TCCPreVble`は、この`TEntradaPulso`を利用して、パイプ端に時間変動する圧力や温度を境界条件として与えるための、ほぼ同一の機能を持つ境界条件クラスです。

#### 主な責務
- **`TEntradaPulso`**:
    - `LeeEntradaPulso`: ファイルから時系列データを読み込み、`FTiempo`, `FPresionRelativa`, `FNivelEntropia`配列に格納する。
    - `InterpolaPresion`, `InterpolaEntropia`: 指定された時刻における圧力とエントロピーの値を、配列から線形補間して返す。
- **`TCCPulso` / `TCCPreVble`**:
    - `ReadBoundaryData`: `TEntradaPulso`オブジェクトを`new`で生成し、データファイルを読み込ませる。
    - `CalculaCondicionContorno`: `TEntradaPulso`から現在の時刻に対応する圧力・温度を取得し、それをパイプ端の境界条件としてリーマン不変量を計算する。

#### 特筆すべき設計と問題点
- **コードの重複:** `TCCPulso`と`TCCPreVble`は、クラス名と僅かな計算式の違いを除いて、コードがほぼ完全に重複しています。これはリファクタリングによって単一のクラスに統合すべきです。
- **メモリ管理:** `TEntradaPulso`クラス内でデータ点数分の配列を`new[]`で確保し、デストラクタで`delete[]`しています。`TCCPulso`/`TCCPreVble`クラスは、`TEntradaPulso`オブジェクト自体を`new`で生成し、デストラクタで`delete`しています。これらはすべて、`std::vector`と`std::unique_ptr`で置き換えるべき典型的な例です。

---

### 21. TCFDConnection (CFD連携境界モデル)

- **ファイル:** `Source/Boundaries/TCFDConnection.cpp`, `Source/Boundaries/TCFDConnection.h`
- **概要:** `TCondicionContorno`から派生した具象クラス。OpenWAM（1Dシミュレーション）と外部のCFD（3Dシミュレーション）コードとの**協調シミュレーション**を実現するための境界です。

#### 主な責務
- **データ交換（ファイルベース）:**
    - **出力:** 各タイムステップで、OpenWAM側のパイプ端の状態（特性、エントロピー、ガス組成）をファイル（`.1d`）に書き出す。
    - **入力:** CFDコード側が書き出したファイル（`.cfd`）を監視し、更新があればそれを読み込み、CFD側の状態（特性、エントロピー、ガス組成）を境界条件として取り込む。
- **同期:** ファイルのタイムスタンプを監視することで、相手側の計算が進むのを待つ、という単純な同期機構を持つ。

#### データ構造と主要メソッド
- **`FCFDModel`, `FCFDout`, `FCFDin`**: 連携に使うファイル名を管理する。
- **`CalculaCondicionContorno(double Time)`**: メインロジック。
    1. OpenWAM側の状態を`.1d`ファイルに追記する。
    2. `.cfd`ファイルが更新されるのを待つ。
    3. `.cfd`ファイルから最新のデータを読み込む。
    4. 読み込んだデータを線形補間し、パイプ端の境界条件として適用する。

#### 特筆すべき設計と問題点
- **設計:** ファイルを介した非常にシンプルなコ・シミュレーション実装です。より高度な連携（MPIなど）も考えられますが、これは最も手軽な方法です。
- **問題点:**
    - **堅牢性の欠如:** ファイルI/Oと単純な待機ループに依存しているため、ファイル名の衝突、書き込みタイミングのズレ、デッドロックなど、多くの潜在的な問題を抱えています。
    - **非効率:** 計算のたびにファイルI/Oと待機が発生するため、パフォーマンスは良くありません。
    - **メモリ管理:** 他のクラスと同様に、`FTuboExtremo`の手動メモリ管理問題を抱えています。

---

### 22. TConcentrico (同軸配管 熱交換モデル群)

- **ファイル:** `Source/Concentric Pipe/TConcentrico.h`, `TConcentricoTubos.h`, `TConcentricoDPF.h`
- **概要:** 同軸に配置された2つのコンポーネント間の熱交換を計算するためのクラス群です。`TConcentrico`が抽象基底クラスとして共通のインターフェースを定義し、具象クラスが具体的な計算を実装します。

#### 主な責務と設計
- **`TConcentrico` (抽象基底クラス):**
    - 内側と外側のコンポーネント（パイプやDPF）へのポインタ、およびそれらの壁面温度分布、熱抵抗、熱容量などを保持するためのデータ構造（主にC言語スタイルのポインタ配列）を定義します。
    - `CalculaTemperaturaPared`（壁温計算）や`CalculaResistenciasdePared`（熱抵抗計算）といった、熱計算の核となる処理を純粋仮想関数として宣言し、派生クラスに実装を強制します。
- **`TConcentricoTubos` (具象クラス):**
    - **パイプとパイプ**の同軸配置における熱交換をモデル化します。内側パイプから外側パイプへの熱伝達、および外側パイプから外部環境への熱損失を計算します。
- **`TConcentricoDPF` (具象クラス):**
    - **DPFとパイプ**の同軸配置における熱交換をモデル化します。DPF内部の再生（燃焼）による発熱も考慮された、より複雑な熱計算を行います。

#### 特筆すべき設計と問題点
- **良い点:** `TCondicionContorno`などと同様に、ポリモーフィズムを利用して異なる種類の同軸コンポーネントを統一的に扱える設計になっています。
- **問題点（メモリ管理）:** このクラス群も、温度分布などを保持する`FTPared`などの多次元配列が`new[]`/`delete[]`で手動管理されており、コードの複雑化とメモリリークのリスクを抱えています。`std::vector`への移行が強く推奨されます。

---

### 23. TTipoValvula とその派生クラス群 (バルブ・オリフィスモデル)

- **ファイル:** `Source/Connections/*.h`, `Source/Connections/*.cpp`
- **概要:** パイプやチャンバー間の流れを制御する、多種多様なバルブ、オリフィス、ポートなどをモデル化するコンポーネント群です。OpenWAMのモジュール性を支える重要な役割を担っています。

#### 主な責務と設計
- **`TTipoValvula` (抽象基底クラス):**
    - すべてのバルブ/オリフィスモデルの共通インターフェースを定義します。中心的な役割は、流れの有効断面積を表す**流量係数（CD値）**を提供することです。
    - `FCDTubVol`（パイプ→容積）と`FCDVolTub`（容積→パイプ）という2つの流量係数を持ち、流れの方向に応じて使い分けられます。
    - `TCCDeposito`や`TCCCilindro`などの境界条件クラスは、この`TTipoValvula`へのポインタを保持することで、具体的なバルブの種類を意識することなく、ポリモーフィックに流量計算を行えます。
- **具象クラス群の例:**
    - **`TCDFijo` (固定オリフィス):** 設定ファイルで与えられた固定のCD値を使用します。
    - **`TValvula4T` (4ストロークポペットバルブ):** クランク角に連動したバルブリフト量を計算し、リフト量に応じたCD値をテーブルから補間して求めます。VVT（可変バルブタイミング）機能も有し、外部の`TController`によって開閉タイミングを動的に変更できます。
    - **`TMariposa` (スロットルバルブ):** 外部の`TController`からの指令値（スロットル開度）を受け取り、開度に応じたCD値をテーブルから補間します。
    - **`TLamina` (リードバルブ), `TWasteGate` (ウェイストゲート):** バルブ前後の圧力差によって開度が決まる動的モデル。内部で運動方程式を解き、バルブのリフト量を計算してCD値を決定します。
    - **`TDiscoRotativo`, `TLumbrera` (ロータリーバルブ, 2ストポート):** クランク角に同期して開口面積が変化するモデルです。

#### 特筆すべき設計と問題点
- **良い点:** ポリモーフィズムを最大限に活用した、非常に柔軟で拡張性の高い設計です。新しいバルブモデルを追加する場合も、`TTipoValvula`を継承してCD値の計算ロジックを実装するだけで、既存の境界条件クラスとシームレスに連携できます。
- **問題点:** 各具象クラスは、CD値のテーブルなどを`new[]`で確保しており、デストラクタで解放しています。これらのデータ構造も`std::vector`に置き換えることで、より安全で簡潔なコードになります。

---

### 24. TController とその派生クラス群 (制御システムモデル)

- **ファイル:** `Source/Control/*.h`, `Source/Control/*.cpp`
- **概要:** シミュレーション内の物理量（回転数、圧力など）を監視し、アクチュエーター（バルブ開度など）を操作するためのフィードバック制御システムを構築するコンポーネント群です。

#### 主な責務と設計
- **`TSensor` (センサー):**
    - シミュレーション内の任意のオブジェクト（パイプ、デポジット、エンジンなど）から、指定された物理量（圧力、温度、回転数など）を読み取る役割を担います。センサー自体の応答遅れ（一次遅れ）もモデル化できます。
- **`TController` (抽象基底クラス):**
    - すべての制御ロジック（PID、マップなど）の共通インターフェースを定義します。入力として`TSensor`からの信号を受け取り、`Output`メソッドで操作量を出力します。
- **具象コントローラークラス群:**
    - **`TPIDController` (PIDコントローラー):** センサーからの入力値と目標値との偏差に基づき、P（比例）、I（積分）、D（微分）動作によって操作量を計算します。ECUの基本的なフィードバック制御を模擬します。
    - **`TTable1D`, `TTable` (ルックアップテーブル):** 1つまたは2つのセンサー入力を基に、設定ファイルから読み込んだ制御マップ（テーブル）を補間し、出力値を決定します。ECUの燃料噴射マップや点火時期マップなどを模擬するための重要なコンポーネントです。
    - **`TDecisor` (デシジョン):** センサー入力がある閾値を超えたかどうかで、2つの異なるコントローラー出力のどちらかを選択する、といった条件分岐ロジックを実装します。

#### 特筆すべき設計と問題点
- **良い点:** センサー、コントローラー、アクチュエーター（`TTipoValvula`など）の役割が明確に分離されており、これらを組み合わせることで複雑なエンジン制御戦略をシミュレーション上で再現できる、非常に強力なフレームワークです。
- **問題点:** 各クラスは、センサーや他のコントローラーへのポインタを保持することで連携を実現していますが、これらのオブジェクトの生存期間管理は、シミュレーションのメインループ（`TOpenWAM`）が一元的に行っており、現代的なC++のスマートポインタによる管理は行われていません。

---

### 25. TBloqueMotor, TCilindro (エンジン・シリンダーモデル)

- **ファイル:** `Source/Engine/*.h`, `Source/Engine/*.cpp`
- **概要:** エンジン本体の物理モデルを構成する中核的なクラス群です。`TBloqueMotor`がエンジン全体を統括し、`TCilindro`の派生クラスが各気筒の複雑な熱力学サイクルを計算します。

#### 主な責務と設計
- **`TBloqueMotor` (エンジンブロック):**
    - エンジン全体を管理する最上位クラス。気筒数分の`TCilindro`オブジェクトを生成・保持します。
    - エンジン全体の運転条件（回転数、燃料噴射量）や物理諸元（ジオメトリ、熱伝達モデル、燃焼モデル）を管理します。
    - シミュレーション完了後、各シリンダーの仕事量を集計し、トルクや出力などの最終的な性能指標を計算します。
- **`TCilindro` (抽象基底クラス):**
    - 単一シリンダーの熱力学状態（圧力、温度、質量）と、その時間変化を計算するための共通インターフェースを定義します。
    - `ActualizaPropiedades`という純粋仮想関数が、各タイムステップでの状態更新を行う中心的なメソッドです。
    - 吸排気ポート（`TCCCilindro`境界）を介したガス交換、燃焼モデル（`ACT`またはWiebe関数）による熱発生、壁面への熱損失、ピストンの動きによる仕事量を計算します。
- **`TCilindro4T` / `TCilindro2T` (具象クラス):**
    - `ActualizaPropiedades`メソッドを具体的に実装します。
    - クランク角に基づき、現在のサイクルが「サイクル閉鎖中（圧縮・燃焼・膨張）」か「ガス交換中（吸排気）」かを判断し、適用する物理法則を切り替えます。
    - 特に、吸気バルブが閉じるタイミングで筒内のガスを「閉じ込められた質量」として確定し、閉鎖サイクル計算を開始するロジックは、エンジンシミュレーションの根幹をなす部分です。

#### 特筆すべき設計と問題点
- **良い点:** エンジン全体と単一シリンダーの役割が明確に分離されており、`TCilindro`の派生クラスを切り替えることで異なる種類のエンジン（2ストローク/4ストローク）に対応できる、ポリモーフィズムを活用した優れた設計です。
- **問題点:**
    - **巨大なクラス:** `TBloqueMotor`と`TCilindro`は、非常に多くのパラメータと責務を抱える巨大なクラス（God Class）になっており、可読性とメンテナンス性を著しく低下させています。ジオメトリ、熱伝達、燃焼、ガス交換などの各物理モデルは、本来それぞれ別のクラスに分離されるべきです。
    - **複雑な状態管理:** `TCilindro::ActualizaPropiedades`メソッドは、クランク角に応じた多数の`if`文で状態遷移を管理しており、処理の流れを追うのが困難です。ステートマシンパターンなどを導入することで、より見通しの良い設計に改善できる可能性があります。
    - **メモリ管理:** これまでのクラスと同様、燃焼モデル`ACT`に関連するC言語スタイルの配列など、手動でのメモリ管理が随所に残っています。

---

### 25. TBloqueMotor, TCilindro (エンジン・シリンダーモデル)

- **ファイル:** `Source/Engine/*.h`, `Source/Engine/*.cpp`
- **概要:** エンジン本体の物理モデルを構成する中核的なクラス群です。`TBloqueMotor`がエンジン全体を統括し、`TCilindro`の派生クラスが各気筒の複雑な熱力学サイクルを計算します。

#### 主な責務と設計
- **`TBloqueMotor` (エンジンブロック):**
    - エンジン全体を管理する最上位クラス。気筒数分の`TCilindro`オブジェクトを生成・保持します。
    - エンジン全体の運転条件（回転数、燃料噴射量）や物理諸元（ジオメトリ、熱伝達モデル、燃焼モデル）を管理します。
    - シミュレーション完了後、各シリンダーの仕事量を集計し、トルクや出力などの最終的な性能指標を計算します。
- **`TCilindro` (抽象基底クラス):**
    - 単一シリンダーの熱力学状態（圧力、温度、質量）と、その時間変化を計算するための共通インターフェースを定義します。
    - `ActualizaPropiedades`という純粋仮想関数が、各タイムステップでの状態更新を行う中心的なメソッドです。
    - 吸排気ポート（`TCCCilindro`境界）を介したガス交換、燃焼モデル（`ACT`またはWiebe関数）による熱発生、壁面への熱損失、ピストンの動きによる仕事量を計算します。
- **`TCilindro4T` / `TCilindro2T` (具象クラス):**
    - `ActualizaPropiedades`メソッドを具体的に実装します。
    - クランク角に基づき、現在のサイクルが「サイクル閉鎖中（圧縮・燃焼・膨張）」か「ガス交換中（吸排気）」かを判断し、適用する物理法則を切り替えます。
    - 特に、吸気バルブが閉じるタイミングで筒内のガスを「閉じ込められた質量」として確定し、閉鎖サイクル計算を開始するロジックは、エンジンシミュレーションの根幹をなす部分です。

#### 特筆すべき設計と問題点
- **良い点:** エンジン全体と単一シリンダーの役割が明確に分離されており、`TCilindro`の派生クラスを切り替えることで異なる種類のエンジン（2ストローク/4ストローク）に対応できる、ポリモーフィズムを活用した優れた設計です。
- **問題点:**
    - **巨大なクラス:** `TBloqueMotor`と`TCilindro`は、非常に多くのパラメータと責務を抱える巨大なクラス（God Class）になっており、可読性とメンテナンス性を著しく低下させています。ジオメトリ、熱伝達、燃焼、ガス交換などの各物理モデルは、本来それぞれ別のクラスに分離されるべきです。
    - **複雑な状態管理:** `TCilindro::ActualizaPropiedades`メソッドは、クランク角に応じた多数の`if`文で状態遷移を管理しており、処理の流れを追うのが困難です。ステートマシンパターンなどを導入することで、より見通しの良い設計に改善できる可能性があります。
    - **メモリ管理:** これまでのクラスと同様、燃焼モデル`ACT`に関連するC言語スタイルの配列など、手動でのメモリ管理が随所に残っています。

---

### 26. Externフォルダのコンポーネント群 (外部連携インターフェース)

- **ファイル:** `Source/Extern/*.h`, `Source/Extern/*.cpp`
- **概要:** OpenWAMのシミュレーション中に、外部のプログラム（特にMATLAB/Simulink）からパラメータを動的に変更したり、計算の一部を外部に委譲したりするための「フック」や「インターフェース」を提供するコンポーネント群です。これにより、高度な協調シミュレーション（Co-simulation）を実現します。

#### 主な責務と設計
- **`TCalculoExtern` (外部計算統括クラス):**
    - このフォルダの中心的なクラス。シミュレーション内の各種センサー（`TSensor`）からの情報を集約し、外部プログラム（MATLABなど）に渡します。
    - 逆に、外部プログラムからの出力（操作量）を受け取り、それをOpenWAM内のアクチュエーター（バルブ、燃料噴射装置など）に指令として伝達します。
    - `LlamadaECU`（ECU呼び出し）メソッドが、この一連のデータ交換と制御指令の伝達を実行する心臓部です。
- **`TMatlab` (MATLAB連携クラス):**
    - MATLAB Engine APIをラップし、OpenWAMのプログラム内からMATLABを起動して、データの送受信や`.m`ファイルの実行を可能にします。
    - `TCalculoExtern`は、このクラスを介してMATLAB/Simulinkで構築された制御モデルと連携します。
- **各種制御インターフェースクラス:**
    - `TRegimenMotor`: 外部ファイルから読み込んだ時系列データに基づき、エンジン回転数を強制的に設定します。
    - `TControlFuel`, `TControlInyeccion`: 燃料噴射量、噴射タイミング、噴射圧などを、外部からの指令や内部のマップに基づいて制御します。
    - `TTGV`, `TEGRV`: ターボチャージャーの可変ジオメトリやEGRバルブの開度を、PID制御やマップ参照によって制御します。
    - `TCoefDescarga`: バルブなどの流量係数を外部から動的に上書きします。

#### 特筆すべき設計と問題点
- **良い点:** OpenWAMの物理モデルと、MATLABなどで構築される高度な制御モデルとを連携させるための、明確なインターフェースを提供しています。これにより、ECUの制御ロジックを含めた、より現実的なエンジンシステム全体のシミュレーション（MILS: Model-in-the-Loop Simulation）が可能になります。
- **問題点:** `TCalculoExtern`クラスが多数のセンサーや制御オブジェクトへのポインタを管理しており、依存関係が複雑になりがちです。また、連携はファイルベースやMATLAB Engine APIに依存しており、セットアップが複雑になる可能性があります。

---

### 27. Includesフォルダ (グローバル定義・定数・ユーティリティ)

- **ファイル:** `Source/Includes/*.h`
- **概要:** プロジェクト全体で共有される基本的な定義、物理定数、単位換算、共通のデータ構造、ユーティリティ関数などを提供するヘッダーファイルの集合です。コードベース全体の一貫性と再利用性を支える基盤となっています。

#### 主なファイルと役割
- **`Constantes.h`:**
    - **物理定数:** ガス定数（`__R::Universal`）、円周率（`__cons::Pi`）などの普遍的な定数を`namespace`で整理して提供します。
    - **単位換算:** `__units::BarToPa`, `__units::RPMToRad_s`など、物理単位を変換するためのインライン関数群を定義しており、コード全体での単位の一貫性を保証します。
    - **幾何計算:** `__geom::Circle_area`など、基本的な形状計算を行うユーティリティ関数を提供します。
- **`Globales.h`:**
    - **グローバル`enum`:** `nmTypeBC`（境界条件の種類）、`nmTipoMotor`（エンジン形式）、`nmCombustion`（燃焼モデル）など、シミュレーションの挙動を切り替えるための多数の`enum`型を定義しています。これにより、コード内でマジックナンバーを使用することを避け、可読性を高めています。
    - **グローバル構造体:** `stResMediosTubo`（配管の平均結果）、`stResInstantCilindro`（シリンダーの瞬時結果）など、コンポーネント間でデータを受け渡したり、結果を保持したりするための共通のデータ構造を多数定義しています。
- **`fluids.h`, `THTM_Fluids.h`:**
    - **流体物性値モデル:** 作動流体（空気、排気ガス、水、オイルなど）の熱力学的な物性値（粘度、比熱、熱伝導率など）を、主に温度の関数として計算するためのクラス群です。
    - `stHTM_Fluid`という抽象基底クラスと、それを継承した`stHTMair`（空気）、`stHTMoil`（オイル）などの具象クラスから構成され、ポリモーフィズムを活用しています。
- **`NewCompSolver.h`, `SolverCompresor.h`:**
    - **特定用途ソルバー:** `BoundaryFunctions.h`と同様に、特定のコンポーネント（主に圧縮機）の物理モデルを解くための関数オブジェクト（ファンクタ）を定義しています。

#### 特筆すべき設計と問題点
- **良い点:**
    - 定数や単位換算、型定義を`namespace`や`enum`を用いて一元管理している点は、コードの可読性、再利用性、保守性を高める非常に優れた設計です。
    - 流体の物性値計算をポリモーフィックなクラスとして分離しているため、新しい作動流体モデルの追加が容易です。
- **問題点:** `Globales.h`に非常に多くの定義が含まれており、ファイルが肥大化しています。関連する定義ごとにファイルを分割することで、より見通しが良くなる可能性があります。

---

### 28. Labelsフォルダ (多言語ラベル管理)

- **ファイル:** `Source/Labels/labels.hpp`, `Source/Labels/labels.cpp`
- **概要:** シミュレーションの出力ファイルなどで使用されるテキストラベル（物理量の名前や単位など）を、多言語で管理するための仕組みです。

#### 主な責務と設計
- **文字列の一元管理:** コード内に直接文字列（例: `"Pressure (bar)"`）をハードコーディングするのではなく、数値ID（例: `1661`）で管理します。
- **`labels.cpp`**: `init_labels()`関数内で、`std::map`を用いて数値IDと対応する文字列（現在は英語とスペイン語）のペアを大量に定義しています。
- **`PutLabel(int idx)`**: この中心的な関数が、与えられたIDをキーとしてマップから対応する文字列を検索して返します。言語設定用の特別なID（`10000`）の値に応じて、使用するIDの範囲を切り替えることで多言語対応を実現しています。

#### 特筆すべき設計と問題点
- **良い点:** コードロジックとUI/出力テキストを分離する、優れた設計です。これにより、将来的に言語を追加したり、出力テキストの文言を修正したりする際に、プログラムのコアロジックに触れる必要がなく、メンテナンス性が向上します。
- **問題点:** ラベルの定義がすべて`labels.cpp`内の単一の巨大な関数にハードコードされています。将来的には、言語ごとに別のリソースファイル（例: `labels_en.txt`, `labels_es.txt`）に分離し、プログラム起動時に読み込む形式にすることで、より管理しやすくなります。

---

### 29. Math_wamフォルダ (数値計算ユーティリティ)

- **ファイル:** `Source/Math_wam/*.h`, `Source/Math_wam/*.cpp`, `Source/Includes/interp_1d.h`など
- **概要:** 補間、根探索、連立一次方程式の求解など、シミュレーション全体で必要とされる基本的な数値計算アルゴリズムを提供する、プロジェクト固有の数学ライブラリです。

#### 主な機能と役割
- **補間 (Interpolation):**
    - **`interp_1d.h`**: `Base_interp`という抽象基底クラスと、それを継承した`Linear_interp`（線形補間）、`Hermite_interp`（3次エルミート補間）などの具象クラスが定義されています。これにより、バルブのリフトカーブやECUの制御マップなどを、設定に応じて異なる補間方法で評価できます。
    - **`Interpolacion_bidimensional`**: 2次元のテーブルデータを線形補間するための関数です。VANOSの制御マップなど、2つの入力（例: 回転数と負荷）から1つの出力を決定する際に使用されます。
- **根探索 (Root Finding):**
    - **`FindRoot` / `zbrent`**: 非線形方程式 `f(x) = 0` の根を、指定された区間内で高速かつ安定して求める**ブレント法**を実装しています。
    - この機能は、OpenWAMの物理モデルを解く上で極めて重要です。例えば、「質量流量が特定の値になるようなパイプ端の流速を求める」といった、解析的に解くのが難しい問題を数値的に解くために、`BoundaryFunctions.h`で定義された**ファンクタ**と組み合わせて頻繁に使用されます。
- **その他のユーティリティ:**
    - `pow2`, `pow3`などの単純な累乗を高速に計算するインライン関数や、LU分解で連立一次方程式を解く`LUdcmp`クラスなどが含まれています。

#### 特筆すべき設計と問題点
- **良い点:** シミュレーションで頻出する数値計算タスク（補間、根探索）を、再利用可能な関数やクラスとしてうまく抽象化・コンポーネント化しています。特に、物理方程式をファンクタとして定義し、それを汎用の根探索アルゴリズムに渡す設計は、コードの関心を分離し、拡張性を高める上で非常に効果的です。
- **問題点:** C言語スタイルの関数がグローバルスコープに多く定義されており、現代的なC++の観点からは、これらを`namespace`で囲むことで、より名前空間の衝突を避けやすくなります。

---

### 30. ODModelsフォルダ (0次元コンポーネントモデル)

- **ファイル:** `Source/ODModels/*.h`, `Source/ODModels/*.cpp`
- **概要:** サージタンク、タービン、ベンチュリ管など、体積は持つが空間的な広がりを考慮しない「0次元（集中定数系）」のコンポーネントをモデル化するクラス群です。1Dの配管モデルと組み合わせることで、エンジンシステム全体を構築します。

#### 主なコンポーネント群と役割

- **デポジット（チャンバー）モデル群:**
    - **`TDeposito` (抽象基底クラス):** すべての0Dモデルの基本クラス。内部の熱力学状態（圧力、温度、ガス組成）を保持し、接続された境界からの質量とエネルギーの流入・流出に基づいて、熱力学第一法則を用いて状態を更新します。
    - **`TDepVolCte` (固定容積デポジット):** サージタンクやプレナムチャンバーなど、容積が一定の気体溜めをモデル化します。
    - **`TDepVolVariable` (可変容積デポジット):** クランク角に連動して容積が変化するモデル。エンジンシリンダーの簡易版として使用されることがあります。

- **タービンモデル群:**
    - **`TTurbina` (抽象基底クラス):** タービンモデルの共通インターフェースを定義します。`TDeposito`を継承しており、タービン自体を一種のチャンバーとして扱います。
    - **`TTurbinaSimple` / `TTurbinaTwin` (具象クラス):** それぞれシングルエントリー、ツインスクロールタービンをモデル化します。
    - **`TTurbineMap` (タービンマップ):** タービンの性能マップ（回転数、圧力比、流量、効率などの関係）をファイルから読み込み、管理する重要なヘルパークラスです。`TTurbina`クラスは、このマップを補間計算することで、現在の運転条件における仕事量や効率を決定します。
    - **ロジック:** `CalculaCondicionTurbina`メソッド内で、タービンマップから得られた有効断面積を、タービン入口・出口に接続された境界条件の流量係数として設定することで、タービンの存在が1D配管網のガス流れに影響を与えます。

- **その他の0Dモデル:**
    - **`TVenturi`**: ベンチュリ管をモデル化し、入口、スロート（喉部）、出口の圧力・流速関係を計算します。

#### 特筆すべき設計と問題点
- **良い点:** 複雑なコンポーネントを0Dモデルとして抽象化し、それらを1D配管網に境界条件を介して接続するというアプローチは、エンジンシステム全体を柔軟に構築するための効果的な方法です。特に、タービンモデルがマップデータに基づいて性能を決定する部分は、実際のターボチャージャーの挙動をよく模擬しています。
- **問題点:** `TDeposito`や`TTurbina`クラスも、接続情報や内部状態を保持するために多くのC言語スタイルのポインタ配列を使用しており、これまでのクラスと同様のメモリ管理の問題を抱えています。

---

### 31. Outputフォルダ (結果出力管理)

- **ファイル:** `Source/Output/TOutputResults.h`, `Source/Output/TOutputResults.cpp`
- **概要:** シミュレーションの計算結果（瞬時値・平均値）を収集し、整形してテキストファイル（`.DAT`）に書き出す機能を集約したクラスです。

#### 主な責務と設計
- **結果収集の一元管理:** `TOutputResults`クラスは、エンジン、シリンダー、パイプ、デポジット、タービンなど、シミュレーションを構成する様々なコンポーネントへのポインタを保持します。
- **出力設定の読み込み:** `ReadAverageResults`および`ReadInstantaneousResults`メソッドが、設定ファイルから「どのコンポーネント」の「どの物理量」を出力するかを読み込み、出力対象を決定します。
- **ヘッダー生成:** `Header...`系のメソッドが、出力ファイルのヘッダー行（列名）を生成します。この際、`Labels`フォルダの`PutLabel`関数を利用して、物理量のIDから多言語対応されたテキストラベルを取得します。
- **データ書き込み:**
    - `OutputInstantaneousResults`: シミュレーションのタイムステップごとに呼び出され、各コンポーネントの瞬時値計算メソッドを呼び出し、結果を`stringstream`に溜め込みます。
    - `OutputAverageResults`: サイクル終了時などに呼び出され、各コンポーネントの平均値計算メソッドを呼び出し、結果を`stringstream`に溜め込みます。
    - `Copy...ResultsToFile`: `stringstream`に溜め込まれた整形済みのテキストを、最終的にファイルへ書き出します。

#### 特筆すべき設計と問題点
- **良い点:** 計算ロジックと出力処理という、異なる関心事が明確に分離されています。各物理モデルのクラスは、自身の状態を返すメソッドを提供するだけでよく、ファイルI/Oの詳細を意識する必要がありません。これにより、コードのモジュール性とメンテナンス性が向上しています。
- **問題点:** `Read...Results`メソッド内での`fscanf`の多用や、出力対象オブジェクトをポインタの`std::vector`で管理している点など、これまでのコンポーネントと同様のC言語スタイルの実装が多く残っています。

---

### 32. Turbocompressorフォルダ (ターボチャージャーモデル)

- **ファイル:** `Source/Turbocompressor/*.h`, `Source/Turbocompressor/*.cpp`
- **概要:** ターボチャージャーのコンプレッサー、およびタービンとコンプレッサーを連結するシャフト（軸）の回転動力学をモデル化するコンポーネント群です。`ODModels`フォルダのタービンモデルと連携し、ターボチャージャーシステム全体の動的な挙動をシミュレートします。

#### 主なコンポーネント群と役割

- **`TEjeTurbogrupo` (ターボチャージャー軸):**
    - **役割:** このフォルダの最上位に位置するクラス。タービンとコンプレッサーを力学的に結合し、ターボチャージャー全体の回転動力学を計算します。
    - **ロジック:** `CalculaEjesTurbogrupo`メソッド内で、アタッチされたタービンが発生する仕事量と、コンプレッサーが消費する仕事量、そして軸受けの摩擦損失のバランスを計算します。この仕事の差分から角加速度を求め、ニュートンの運動方程式 `I * dω/dt = Σ(トルク)` に基づいて、次のタイムステップのターボ回転数を更新します。これにより、ターボラグなどの過渡現象が再現されます。

- **`TCompresor` (コンプレッサー基底クラス):**
    - **役割:** コンプレッサーモデルの共通インターフェースを定義します。
    - **ロジック:** `CondicionCompresor`メソッドが1D配管ソルバーから呼び出されると、現在の回転数と入口のガス状態を基に、性能マップ（`TCompressorMap`）を参照します。マップから得られる圧力比と効率を満たすように、出口のガス状態（圧力、温度）と消費仕事量を計算し、結果を`TEjeTurbogrupo`と1D配管ソルバーに返します。

- **`TCompressorMap` とその派生クラス群 (性能マップ):**
    - **役割:** コンプレッサーの性能特性（圧力比、流量、効率、回転数の関係）を定義するマップデータを管理します。
    - **設計:** `TCompressorMap`が抽象基底クラスとなり、`TMapaComp`（WAM独自形式）や`TSAEMap`（SAE標準形式）など、様々な形式のマップファイルに対応するための具象クラスが用意されています。このポリモーフィックな設計により、多様なデータソースに柔軟に対応できます。
    - **ロジック:** `InterpolaMapa`メソッドで、現在の回転数に対応する等回転数線を補間して生成し、`EvaluaRCHermite`（圧力比評価）や`EvaluaRendSplines`（効率評価）メソッドで、流量に応じた性能値を補間計算します。

- **`turbo_bearings.hpp` (軸受け損失モデル):**
    - ターボチャージャーの軸受けにおける摩擦損失を、回転数やオイルの温度・粘度などから物理的に計算します。この損失は`TEjeTurbogrupo`の回転動力学計算に組み込まれます。

#### 特筆すべき設計と問題点
- **良い点:** タービン、コンプレッサー、軸という物理的なコンポーネントが、それぞれ`TTurbina`, `TCompresor`, `TEjeTurbogrupo`というクラスに明確に対応付けられています。特に、`TEjeTurbogrupo`が両者のエネルギーバランスから回転数を動的に決定する部分は、ターボチャージャーの過渡応答を捉える上で非常に重要な実装です。
- **問題点:** コンプレッサーマップを扱うクラス群（`TMapaComp`など）は、内部で多数の動的配列や補間係数を保持しており、C言語スタイルの手動メモリ管理が多用されています。これらのクラスは、リファクタリングによる恩恵が大きい部分です。

---

### 30. ODModelsフォルダ (0次元モデル群)

- **ファイル:** `Source/ODModels/*.h`, `Source/ODModels/*.cpp`
- **概要:** 1次元の波動計算を行わず、内部の状態（圧力、温度）が均一であると仮定する「0次元（集中定数系）」コンポーネントの物理モデルを実装したクラス群です。サージタンクのような単純なチャンバーから、複雑な性能マップを持つターボチャージャーのタービンまで、様々な要素が含まれます。

#### 主なコンポーネントと役割

##### 1. デポジット（チャンバー）モデル群
- **`TDeposito` (抽象基底クラス):**
    - 0Dモデルの基本クラス。内部の熱力学状態（圧力、温度、ガス組成）を保持します。
    - `ActualizaPropiedades`メソッドで、接続された境界からの質量とエンタルピーの流入・流出を時間積分し、熱力学第一法則に基づいて内部状態を更新します。
- **`TDepVolCte` (固定容積デポジット):**
    - `TDeposito`を継承した、体積が一定のチャンバー（サージタンク、プレナム等）をモデル化する具象クラスです。
- **`TDepVolVariable` (可変容積デポジット):**
    - `TDeposito`を継承し、クランク角に応じて容積が変化するモデルです。主に往復動コンプレッサーのシリンダーなどを簡易的に表現するために使用されます。

##### 2. タービンモデル群
- **`TTurbina` (タービン抽象基底クラス):**
    - `TDeposito`から派生しており、タービン自体を0次元のチャンバーとして扱います。
    - `TTurbineMap`オブジェクトを保持し、タービンの性能マップを参照して計算を行います。
    - `CalculaCondicionTurbina`メソッドが、タービンの運転点（仕事量、効率など）を計算する中心的な処理を担います。
- **`TTurbinaSimple` / `TTurbinaTwin` (具象クラス):**
    - それぞれシングルエントリータービンとツインスクロールタービンをモデル化します。
- **`TTurbineMap`, `TTurbPosition`, `TIsoSpeedLine` (マップデータ構造):**
    - タービンの性能マップを、「ラック位置」→「等回転数線」→「圧力比ごとの性能点」という階層構造で保持し、運転条件に応じた性能値を2段階の補間計算で求めるためのデータ構造クラス群です。

##### 3. その他の0Dモデル
- **`TVenturi`**: 入口、出口、側面の3ポートを持つベンチュリ管をモデル化します。
- **`TUnionDireccional`**: 流れの方向によって抵抗特性が変わる非対称な合流管をモデル化します。

#### 特筆すべき設計と問題点
- **良い点:** 0Dモデル群も、`TDeposito`や`TTurbina`といった抽象基底クラスを用いたポリモーフィックな設計になっており、様々な種類のコンポーネントを統一的に扱えるようになっています。特にタービンモデルは、性能マップを詳細にモデル化するための専用データ構造を持っており、精緻なシミュレーションが可能です。
- **問題点:** `TDeposito::ActualizaPropiedades`メソッド内の反復計算ループなど、一部のロジックが複雑です。また、これまでと同様に、動的に確保される配列のメモリ管理は手動で行われています。

---

### 31. Wrappersとユーティリティ

- **ファイル:** `Source/Wrappers/*`, `Source/wasm_wrapper.cpp`
- **概要:** プロジェクト全体で利用される例外処理クラスと、C++コアエンジンを外部環境（特にWebAssembly）から利用可能にするためのラッパーコードが含まれています。

#### 主なコンポーネントと役割

- **`Exception`クラス (`Source/Wrappers/`):**
    - `std::exception`を継承した、プロジェクト固有のカスタム例外クラスです。
    - コンストラクタでエラーメッセージを受け取り、`what()`メソッドでそれを返すという標準的な実装を提供します。
    - これにより、`throw Exception("エラー内容");` のように、プロジェクト全体で一貫したエラーハンドリングが可能になります。

- **`wasm_wrapper.cpp` (WebAssemblyラッパー):**
    - OpenWAMのC++コア機能をWebブラウザ上で動作させるための重要なインターフェースです。
    - **Emscripten**ツールチェインでコンパイルされることを前提としており、`emscripten/bind.h`や`EMSCRIPTEN_KEEPALIVE`マクロが使用されています。
    - **`run_simulation_wrapper`関数:** この関数がJavaScript側から呼び出されるエントリーポイントです。
        1.  **JSON入力:** シミュレーションパラメータ（エンジン回転数、VVT角度など）をJSON形式の文字列として受け取ります。
        2.  **パラメータ設定:** `nlohmann::json`ライブラリでJSONをパースし、`TOpenWAM`オブジェクトを生成した後、`TBloqueMotor`や`TValvula4T`といったC++オブジェクトのメンバ変数に値を直接設定します。これにより、`.wam`設定ファイルなしで動的にシミュレーション条件を変更できます。
        3.  **シミュレーション実行:** OpenWAMのメインループを実行します。
        4.  **JSON出力:** シミュレーション結果（筒内圧、トルク、出力など）を再びJSONオブジェクトにまとめ、文字列としてJavaScript側に返します。

#### 特筆すべき設計
- `wasm_wrapper.cpp`は、複雑なC++のシミュレーションエンジンを、Web技術（JavaScript, JSON）とシームレスに連携させるための見事な「ラッパー」として機能しています。これにより、強力な計算カーネルを維持しつつ、モダンでインタラクティブなWebベースのUIを構築することが可能になっています。

---

### 32. TOpenWAM, TCGestorWAM, TTimeControl (最上位管理クラス群)

- **ファイル:** `Source/TOpenWAM.h`, `Source/TOpenWAM.cpp`, etc.
- **概要:** これまで解析してきた個々のコンポーネントを統合し、シミュレーションの構築、実行、結果出力という全体のライフサイクルを管理する、アプリケーションの最上位クラス群です。

#### 主な責務と設計
- **`TOpenWAM` (シミュレーション統括クラス):**
    - **モデル構築:** `ReadInputData`メソッドがシミュレーションの開始点となり、設定ファイル（`.wam`）を読み込みます。そして、`ReadPipes`, `ReadEngine`, `ReadConnections`といった内部メソッドを呼び出し、必要なすべてのコンポーネントオブジェクトを`new`で生成し、パラメータを設定します。その後、`ConnectFlowElements`メソッドで各コンポーネント間の接続（ポインタの相互設定）を行い、シミュレーションモデル全体を構築します。
    - **メインループ:** `DetermineTimeStepIndependent`と`CalculateFlowIndependent`がシミュレーションのメインループを構成します。ループの各ステップで、CFL条件から安定する最大時間ステップを決定し、すべてのコンポーネントの更新メソッド（`ActualizaPropiedades`など）を呼び出して時間を進めます。
    - **結果出力:** `ManageOutput`メソッドを呼び出し、`TOutputResults`オブジェクトを介して、各ステップの計算結果をファイルに書き出します。
- **`TCGestorWAM` (プロセス間通信マネージャー):**
    - "Gestor"はスペイン語で「マネージャー」を意味します。このクラスは、Windowsの名前付きパイプ（Named Pipes）を利用したプロセス間通信を担当します。
    - OpenWAMの計算進捗（例:「Reading input data」）や結果を、WAMerなどの外部GUIアプリケーションにリアルタイムで通知するために使用されます。シミュレーションのコアな物理計算とは直接関係ありません。
- **`TTimeControl` (時間管理クラス):**
    - シミュレーションの実行時間を計測・管理するためのシンプルなヘルパークラスです。パフォーマンス測定などに利用されます。

#### 特筆すべき設計
- **ビルダーパターン:** `TOpenWAM`クラスは、設定ファイルという「設計図」に基づき、多数のコンポーネントオブジェクトを段階的に生成・設定・接続することで、シミュレーションモデルという複雑なオブジェクトを構築します。これはビルダーパターンに近い設計思想です。
- **明確な役割分担:** `TOpenWAM`が計算の実行、`TCGestorWAM`が外部との通信、`TTimeControl`が時間管理、と役割が明確に分離されています。

---

## 全体的な問題点と分析

複数のコンポーネントを解析した結果、プロジェクト全体に共通する根深い問題点が明らかになりました。

1.  **C言語スタイルのメモリ管理:**
    - `new`/`delete` や `malloc`/`free` による手動でのメモリ管理が多用されています。
    - デストラクタやコードの各所に解放処理が散在しており、コードが複雑化しています。
    - RAII（Resource Acquisition Is Initialization）の原則が適用されておらず、例外発生時などにメモリリークを引き起こすリスクが非常に高い状態です。

2.  **手続き的なC言語スタイル:**
    - `ACT_Sub_DLL`のように、データ（`struct`）とそれを操作する関数が分離しており、カプセル化が行われていません。これにより、データの不整合や意図しない副作用が発生しやすくなっています。
    - `TTubo`はクラスですが、内部実装が手続き的で、多くの計算ロジックが単一の巨大なクラスに集中しています（God Classアンチパターン）。

3.  **安全でないデータアクセスとI/O:**
    - 関数のインターフェースが、膨大な数の生ポインタの引数リストで構成されています。これは型安全性が低く、呼び出し側のミス（例: 配列サイズの間違い）がクラッシュに直結します。
    - `fscanf` を使ったファイル読み込みは、フォーマットの変更に非常に脆弱であり、堅牢性に欠けます。

4.  **低い可読性とメンテナンス性:**
    - すべて大文字の関数名や、`F`プレフィックスなど、一貫性のない命名規則が混在しています。
    - `FUNCTION_NOX`に見られるような、巨大なマジックナンバーのテーブルがコード内に直接ハードコーディングされており、モデルの調整や検証を著しく困難にしています。

---

## 改善計画（リファクタリング計画）

上記の分析に基づき、**フェーズ1（安定性・安全性向上）**として以下の改善計画を提案します。

### ステップ1: メモリ管理の近代化 (RAIIの導入)

- **目的:** 手動メモリ管理を撤廃し、メモリリークのリスクを根絶する。
- **アクション:**
    - プロジェクト内のすべての `new`/`delete` および `malloc`/`free` を `std::vector` に置き換えます。
    - `double*` は `std::vector<double>` に、`double**` は `std::vector<std::vector<double>>` に変更します。
    - `TCCCilindro`の`FValvula`のようなポリモーフィックな所有ポインタは `std::unique_ptr` に置き換えます。
    - これにより、デストラクタ内の解放コードは不要になり、コードが劇的に簡潔かつ安全になります。

### ステップ2: ロジックのカプセル化 (クラスベース設計への移行)

- **目的:** データとロジックを一体化し、モジュールの独立性と再利用性を高める。
- **アクション:**
    - **`ACT_Sub_DLL`:** 関連する関数群と構造体を `InCylinderCombustionModel` クラスとして再設計します。グローバル関数はクラスのプライベートメソッドとし、`ACT`関数は `calculate()` のような単一の公開メソッドに置き換えます。
    - **`TTubo`:** 現在巨大すぎるため、将来的には責務（ジオメトリ、熱計算、数値計算）ごとにクラスを分割することを目指します。（フェーズ3の布石）

### ステップ3: インターフェースの健全化

- **目的:** 安全で分かりやすいコンポーネント間の連携を実現する。
- **アクション:**
    - 長大なポインタ引数リストを廃止します。代わりに、関連データをまとめた構造体やクラスオブジェクトを `const`参照や値で渡すように変更します。
    - `fscanf` を使用したファイル読み込みを廃止し、`TTubo`で既に部分的に実装されている `configure_from_json` のような、よりモダンで堅牢な方法に統一します。

### ステップ4: コード品質の向上

- **目的:** 可読性とメンテナンス性を高め、将来の機能追加やデバッグを容易にする。
- **アクション:**
    - プロジェクト全体で一貫したC++の命名規則（例: `camelCase` or `snake_case`）を導入します。
    - `#define` で定義された定数を `constexpr` や `enum class` に置き換えます。
    - `FUNCTION_NOX` のようなハードコードされたデータテーブルは、外部のデータファイル（JSON/CSV）に分離し、プログラム起動時に読み込むように変更します。

この計画に沿ってリファクタリングを進めることで、OpenWAMのコードベースはより安全、堅牢、かつ現代的なC++プロジェクトへと進化します。